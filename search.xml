<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello, World!</title>
    <url>/2018/04/07/Hello-World-0/</url>
    <content><![CDATA[<figure>
<img
src="http://static.zybuluo.com/Ukn/5aen2grrjkkki1zq7vwb736j/Hello.png"
alt="Hello.png-15.9kB" />
<figcaption aria-hidden="true">Hello.png-15.9kB</figcaption>
</figure>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>等比矩阵求和的另一种思路</title>
    <url>/2018/04/07/DB/</url>
    <content><![CDATA[<h2 id="引言"><strong>引言</strong></h2>
<p>当我们对一个矩阵进行快速幂时，我们可能需要对矩阵的某一行进行求和，即计算矩阵
<span class="math inline">\(A\)</span> <span class="math inline">\(A^1 +
A^2 + A^3 + A^4 + A^5 + \ldots + A^n\)</span> 中的第一行的和。</p>
<h2 id="如何解决"><strong>如何解决？</strong></h2>
<span id="more"></span>
<p>考虑对矩阵右侧加一行 <span class="math inline">\(1\)</span>
例如，假设原矩阵是 <span class="math display">\[
\begin{bmatrix}
a_1&amp;a_2\\
a_3&amp;a_4\\
\end{bmatrix}
\]</span> 对于矩阵转换后，我们有: <span class="math display">\[
\begin{bmatrix}
a_1&amp;a_2&amp;1\\
a_3&amp;a_4&amp;1\\
0&amp;0&amp;1\\
\end{bmatrix}
\]</span> 考虑对这个矩阵进行乘方 矩阵的二次幂为 <span
class="math display">\[
\begin{bmatrix}
a_1^2+a_2a_3+0&amp;a_1a_2+a_2a_4+0&amp;a_1+a_2+1\\
a_1a_3+a_3a_4+0&amp;a_2a_3+a_4^2+0&amp;a_3+a_4+1\\
0+0+0&amp;0+0+0&amp;0+0+1\\
\end{bmatrix}
\]</span> 首先我们可以观察到
<strong>右侧增加的一行1对矩阵的本身乘方无影响</strong>
其次，考虑右侧的一列的数值，可发现其数值等于第一行的 <span
class="math inline">\(1\)</span> 次方的和。 由矩阵乘法的性质：
最右一列的值在数值上等于对应列的第一个元素+对应列的第二个元素+对应列的第三个元素+...+1</p>
<p>考虑再乘一次转换后的矩阵，我们可以得到一个喜闻乐见的性质：
最右一列的数值，等于该矩阵的一次方的对应行的和 +
该矩阵二次方的对应行的和 + 1</p>
<p>至此，我们的问题已经解决，最后某一行的和，就等于对应行的和减去 <span
class="math inline">\(1\)</span></p>
<h2 id="为什么这样做是正确的"><strong>为什么这样做是正确的</strong></h2>
<p>首先，我们在末尾一行补了 <span class="math inline">\(0\)</span>
，这样便不会影响到原矩阵的乘法(即最后的一项始终是 <span
class="math inline">\(0\)</span>)</p>
<p>其次，最后一行的值在矩阵乘法中不会发生变化，该为 <span
class="math inline">\(0\)</span> 的始终为 <span
class="math inline">\(0\)</span> ，为 <span
class="math inline">\(1\)</span> 的始终为 <span
class="math inline">\(1\)</span></p>
<p>最后，我们考虑最后一列的值，以第一行举例： 在第一次乘方后，数值上等于
第一行矩阵各元素的和 + 1
第二次乘方前，由于第一行除了最后一列外所有的元素均为原本矩阵二次幂后的值，因此最后一列数值上等于
原本矩阵第一行二次幂后的值 + 原本矩阵一次幂后的值 + 1.
此时考虑原矩阵，最后一列的值已经不是 <span
class="math inline">\(1\)</span> 而是一次幂元素的和 + 1，因此 <span
class="math inline">\(1\)</span> 不会被重复累计。</p>
<p>这样乘下去，最终第一行前 <span class="math inline">\(n\)</span>
次幂的和会等于矩阵第一行的和 - 1</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>数论</tag>
        <tag>证明</tag>
      </tags>
  </entry>
  <entry>
    <title>How Many Hougong题解</title>
    <url>/2018/04/07/How-many-hougong/</url>
    <content><![CDATA[<h3 id="题目简述"><strong>题目简述</strong></h3>
<p>给定一串长度为 <span class="math inline">\(n\)</span>
的序列，每个点上有一个权值 <span class="math inline">\(a_i\)</span>
，现在你需要处理 <span class="math inline">\(q\)</span>
个操作，有以下两种操作：</p>
<p><span class="math inline">\(1\)</span> <span
class="math inline">\(val\)</span></p>
<p>表示你需要构造一个序列，序列中每一个元素 <span
class="math inline">\(seq_i\)</span> 小于等于 <span
class="math inline">\(a_i\)</span> 且大于 <span
class="math inline">\(0\)</span>，问所有合法的序列中 <span
class="math inline">\(val\)</span> 出现了几次。</p>
<p><span class="math inline">\(2\)</span> <span
class="math inline">\(pos\)</span> <span
class="math inline">\(val\)</span></p>
<p>表示把 <span class="math inline">\(pos\)</span> 号节点的点权修改为
<span class="math inline">\(val\)</span>，点的编号从 <span
class="math inline">\(0\)</span> 开始。</p>
<p>对于每一个询问 <span class="math inline">\(2\)</span>
，请输出操作的结果 <span class="math inline">\(mod\)</span> <span
class="math inline">\(p\)</span>，<span class="math inline">\(p\)</span>
为质数。</p>
<span id="more"></span>
<h3 id="solution"><strong>Solution</strong></h3>
<p>考虑每个节点对答案的贡献： 显然总方案数为 <span
class="math display">\[\prod_{i=0}^{n-1} a_i\]</span> 显然若第 <span
class="math inline">\(i\)</span> 号节点的 <span
class="math inline">\(a_i &lt; val\)</span> ，则 <span
class="math inline">\(i\)</span> 节点对答案贡献为 <span
class="math inline">\(0\)</span> 若第 <span
class="math inline">\(i\)</span> 号节点 <span class="math inline">\(a[i]
&gt;= val\)</span> ，则 <span class="math inline">\(i\)</span>
节点对答案的贡献为 <span
class="math display">\[\frac{\prod_{i=0}^{n-1}a_i}{a_i}\]</span></p>
<p>考虑一次询问，我们要求的就是：</p>
<p><span class="math display">\[\frac{\prod_{i=0}^{n-1}a_i}{a_{i1}} +
\frac{\prod_{i=0}^{n-1}a_i}{a_{i2}} +
\frac{\prod_{i=0}^{n-1}a_i}{a_{i3}} + \cdots +
\frac{\prod_{i=0}^{n-1}a_i}{a_{im}}\]</span></p>
<p>并且</p>
<p><span class="math display">\[a_{i1},a_{i2},a_{i3},\cdots,a_{im} &gt;=
val\]</span></p>
<p>这显然是不能快速求的。 观察题目发现 <span
class="math inline">\(p\)</span>
为质数，考虑使用费马小定理求解，则得到：</p>
<p><span class="math display">\[\prod_{i=0}^{n-1}a_i \times (a_{i1}^{mod
- 2} + a_{i2}^{mod - 2} + \cdots + a_{im}^{mod - 2})\]</span></p>
<p>有人可能会说： &gt; Wen_kr, 你这样不会重复累计吗？</p>
<p>实际上并不会，由于 <span class="math display">\[\prod_{i=0}^{n-1}a_i
\times a_{i1}^{mod-2}\]</span> 累积的是当 <span
class="math inline">\(a_{i1}\)</span> 为 <span
class="math inline">\(val\)</span> 时对答案的贡献，即在其他所有情况时，
<span class="math inline">\(a_{i1}\)</span>
对答案的贡献，因此，这样的统计是<strong>无重复无遗漏</strong>的。</p>
<p>这样一来，我们只需要把 <span class="math inline">\(a_{i}^{mod -
2}\)</span> 用数据结构维护起来就可以求解了！ 考虑使用线段树。 把所有的
<span class="math inline">\(a_i\)</span> 与所有询问的 <span
class="math inline">\(val\)</span> 插入同一个数组排序，再把数组 <span
class="math inline">\(unique\)</span> 一下，我们设现在的数组大小为 <span
class="math inline">\(tot\)</span> ，修改操作，我们把 <span
class="math inline">\(a_i\)</span> <span
class="math inline">\(lowerbound\)</span> 一下，在 <span
class="math inline">\(lowerbound\)</span> 的位置处修改。
对于查询操作，我们把查询的 <span class="math inline">\(val\)</span>
<span class="math inline">\(lowerbound\)</span> 一下，设<span
class="math inline">\(lowerbound\)</span>结果为 <span
class="math inline">\(p\)</span>，则最终结果即为从 <span
class="math inline">\(p\)</span> 到 <span
class="math inline">\(tot\)</span> 所有元素的和。
这样使用线段树就十分方便。</p>
<p>接着考虑操作 <span class="math inline">\(2\)</span></p>
<p>线段树的修改是很好完成的，只需要回滚一次+修改一次即可得到解。</p>
<p>就只剩下一个问题：怎么维护新的累乘之积。</p>
<p>考虑使用费马小定理，新的累乘之和即为：</p>
<p><span class="math display">\[\prod_{i=0}^{n-1}a_i \times a_{pos}^{mod
- 2} \times val\]</span></p>
<p><strong>就可以完成啦...吗？</strong></p>
<p>当你欣喜地写完程序，测完样例，却发现，样例都无法过去……</p>
<p>因此，我们目前的方法，仍然有严重的漏洞。</p>
<h3 id="是什么呢"><strong>是什么呢？</strong></h3>
<p>我们考虑一个数 <span class="math inline">\(a_i\)</span> ，假设$a_i %
mod = 0 $，当我们修改 <span class="math inline">\(a_i\)</span>
回滚操作的时候，能显然发现这样是不对的，因为这样回滚，就是把累乘之积除上了一个
<span class="math inline">\(0\)</span> !</p>
<p>考虑用一个新的变量 <span class="math inline">\(c\)</span>
来记录当前序列中有多少个 <span class="math inline">\(a_i\)</span> 使
<span class="math inline">\(a_i \% mod = 0\)</span>
新开一棵线段树，维护一段区间内有多少个 <span
class="math inline">\(a_i\)</span> 满足这个条件。 对于每个满足条件的
<span class="math inline">\(a_i\)</span> ，因为 <span
class="math inline">\(a_i^{mod - 2} = 0\)</span>
，因此我们没有必要将它插入原线段树，并且因为乘了 <span
class="math inline">\(a_i\)</span>
之后，我们维护累乘之积的变量会始终为零并会出现错误，因此累计累乘时也不累计
<span class="math inline">\(a_i\)</span>。</p>
<p>查询操作，若 <span class="math inline">\(c = 0\)</span>
，我们就像如上文所述的查询查值。 若 <span class="math inline">\(c =
1\)</span> ，我们在 <span class="math inline">\(p\)</span> 到 <span
class="math inline">\(tot\)</span> 上求一遍有多少个 <span
class="math inline">\(a_i\)</span> 满足条件，<span
class="math inline">\(p\)</span>的意义如上文所述。
这样一来，假如查询的结果为 <span class="math inline">\(0\)</span>
，那么无论如何，累乘的结果 $ % mod$ 始终为 <span
class="math inline">\(0\)</span> ，这样结果为 <span
class="math inline">\(0\)</span> 否则由于当且仅当 <span
class="math inline">\(a_i\)</span> (<span
class="math inline">\(a_i\)</span> 符合上文条件) 对答案的贡献为 <span
class="math inline">\(1\)</span>，即当 <span class="math inline">\(a_i =
val\)</span> 时，我们的答案才有值，因此答案为 <span
class="math inline">\(\prod_{i=0}^{n-1}a_i,a_i\text{不符合上文条件}\)</span>
可以看出这个答案为上文的累乘之和。</p>
<p>若<span class="math inline">\(c &gt; 1\)</span>
无论我们把哪个值对累乘的贡献置为 <span
class="math inline">\(1\)</span>，让其等于 <span
class="math inline">\(val\)</span>，最终的结果均为 <span
class="math inline">\(0\)</span></p>
<p>对于修改操作，若被修改的原值 <span class="math inline">\(\% mod =
0\)</span>，我们则更新 <span class="math inline">\(c\)</span>
值与另一棵线段树的值，否则则按原操作方法处理。
对于修改后的值，我们同样考虑其 <span class="math inline">\(\%
mod%\)</span> 的值，分类处理即可。</p>
<h3 id="ac-code"><strong>AC Code</strong></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> all[<span class="number">400050</span>],a[<span class="number">400050</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tot,sum[<span class="number">800050</span>],cnt[<span class="number">800050</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mod,n,q,t,c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Caozuo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> op,pos,val;</span><br><span class="line">&#125;op[<span class="number">400050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base,<span class="type">long</span> <span class="type">long</span> tms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">1</span>;</span><br><span class="line">    base %= mod;</span><br><span class="line">    <span class="keyword">while</span>(tms)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tms &amp; <span class="number">1</span>) tmp = tmp * base % mod;</span><br><span class="line">        base = base * base % mod;</span><br><span class="line">        tms &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">long</span> <span class="type">long</span> val[],<span class="type">long</span> <span class="type">long</span> rt,<span class="type">long</span> <span class="type">long</span> pos,<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r,<span class="type">long</span> <span class="type">long</span> valx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        val[rt] = ((val[rt] + valx) % mod + mod) % mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= pos) <span class="built_in">Update</span>(val,rt &lt;&lt; <span class="number">1</span>,pos,l,mid,valx);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">Update</span>(val,rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,pos,mid + <span class="number">1</span>,r,valx);</span><br><span class="line">    val[rt] = val[rt &lt;&lt; <span class="number">1</span>] + val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    val[rt] %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Query</span><span class="params">(<span class="type">long</span> <span class="type">long</span> val[],<span class="type">long</span> <span class="type">long</span> rt,<span class="type">long</span> <span class="type">long</span> l,<span class="type">long</span> <span class="type">long</span> r,<span class="type">long</span> <span class="type">long</span> l1,<span class="type">long</span> <span class="type">long</span> r1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= l1 &amp;&amp; r &lt;= r1) <span class="keyword">return</span> val[rt] % mod;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= l1) tmp = (tmp + <span class="built_in">Query</span>(val,rt &lt;&lt; <span class="number">1</span>,l,mid,l1,r1)) % mod;</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; r1) tmp = (tmp + <span class="built_in">Query</span>(val,rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid + <span class="number">1</span>,r,l1,r1)) % mod;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="built_in">sizeof</span>(sum));<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;mod,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        all[++tot] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i &lt;= q; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;op[i].op);</span><br><span class="line">        <span class="keyword">if</span>(op[i].op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;op[i].val);</span><br><span class="line">            all[++tot] = op[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;op[i].pos,&amp;op[i].val);</span><br><span class="line">            all[++tot] = op[i].val;</span><br><span class="line">            op[i].pos ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(all + <span class="number">1</span>,all + tot + <span class="number">1</span>);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mul = <span class="number">1</span>;</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">    tot = <span class="built_in">unique</span>(all + <span class="number">1</span>,all + tot + <span class="number">1</span>) - all - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> p = <span class="built_in">lower_bound</span>(all + <span class="number">1</span>,all + <span class="number">1</span> + tot,a[i]) - all;</span><br><span class="line">        <span class="keyword">if</span>(a[i] % mod == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c ++;</span><br><span class="line">            <span class="built_in">Update</span>(cnt,<span class="number">1</span>,p,<span class="number">1</span>,tot,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mul = mul * a[i] % mod;</span><br><span class="line">            <span class="built_in">Update</span>(sum,<span class="number">1</span>,p,<span class="number">1</span>,tot,<span class="built_in">qpow</span>(a[i],mod - <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i &lt;= q; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> val = op[i].val;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> p = <span class="built_in">lower_bound</span>(all + <span class="number">1</span>,all + <span class="number">1</span> + tot,val) - all;</span><br><span class="line">        <span class="keyword">if</span>(op[i].op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,mul * <span class="built_in">Query</span>(sum,<span class="number">1</span>,<span class="number">1</span>,tot,p,tot) % mod);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">Query</span>(cnt,<span class="number">1</span>,<span class="number">1</span>,tot,p,tot) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,mul);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> pos = op[i].pos;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> px = <span class="built_in">lower_bound</span>(all + <span class="number">1</span>,all + <span class="number">1</span> + tot,a[pos]) - all;</span><br><span class="line">            <span class="keyword">if</span>(a[pos] % mod == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c --;</span><br><span class="line">                <span class="built_in">Update</span>(cnt,<span class="number">1</span>,px,<span class="number">1</span>,tot,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mul = mul * <span class="built_in">qpow</span>(a[pos],mod - <span class="number">2</span>) % mod;</span><br><span class="line">                <span class="built_in">Update</span>(sum,<span class="number">1</span>,px,<span class="number">1</span>,tot,-<span class="built_in">qpow</span>(a[pos],mod - <span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(val % mod == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c ++;</span><br><span class="line">                <span class="built_in">Update</span>(cnt,<span class="number">1</span>,p,<span class="number">1</span>,tot,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mul = mul * val % mod;</span><br><span class="line">                <span class="built_in">Update</span>(sum,<span class="number">1</span>,p,<span class="number">1</span>,tot,<span class="built_in">qpow</span>(val,mod - <span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            a[pos] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Input</span>();</span><br><span class="line">        <span class="built_in">Work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流相关模板</title>
    <url>/2018/04/08/NWF/</url>
    <content><![CDATA[<p>包含 Dinic 费用流 无/有源汇网络流</p>
<span id="more"></span>
<p>网络流 Dinic: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,nxt,flow;</span><br><span class="line">&#125;e[<span class="number">5000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ecnt,head[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adde</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u];</span><br><span class="line">    head[u] = ecnt;</span><br><span class="line">    e[ecnt].flow = flow;</span><br><span class="line">    ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s,t;</span><br><span class="line"><span class="type">int</span> dep[<span class="number">100050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    dep[t] = <span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(u == s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u];~i;i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i ^ <span class="number">1</span>].flow &amp;&amp; dep[v] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//printf(&quot;%d %d\n&quot;,v,u);</span></span><br><span class="line">                que.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> curedge[<span class="number">100050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="type">int</span> delta = flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[s];~i;i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(dep[v] == dep[s] - <span class="number">1</span> &amp;&amp; e[i].flow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;%d %d\n&quot;,s,v);</span></span><br><span class="line">            <span class="type">int</span> g = <span class="built_in">dfs</span>(v,t,<span class="built_in">min</span>((<span class="type">int</span>)e[i].flow,delta));</span><br><span class="line">            delta -= g;</span><br><span class="line">            e[i].flow -= g;</span><br><span class="line">            e[i ^ <span class="number">1</span>].flow += g;</span><br><span class="line">            <span class="keyword">if</span>(!delta)</span><br><span class="line">                <span class="keyword">return</span> flow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dep[s] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> flow - delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(curedge,head,<span class="built_in">sizeof</span>(head));</span><br><span class="line">        ans += <span class="built_in">dfs</span>(s,t,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>费用流 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,nxt,flow,w;</span><br><span class="line">&#125;e[<span class="number">50000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adde</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> flow,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[ecnt].v = v;</span><br><span class="line">    e[ecnt].nxt = head[u];</span><br><span class="line">    e[ecnt].w = w;</span><br><span class="line">    head[u] = ecnt;</span><br><span class="line">    e[ecnt].flow = flow;</span><br><span class="line">    ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="built_in">sizeof</span>(inq));</span><br><span class="line">    dep[t] = <span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u];~i;i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i ^ <span class="number">1</span>].flow &amp;&amp; dep[u] - e[i].w &lt; dep[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dep[v] = dep[u] + e[i ^ <span class="number">1</span>].w;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(que.<span class="built_in">empty</span>() || dep[v] &lt; dep[que.<span class="built_in">front</span>()])</span><br><span class="line">                        que.<span class="built_in">push_front</span>(v);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        que.<span class="built_in">push_back</span>(v);</span><br><span class="line">                    inq[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[s] &lt; <span class="number">1061109567</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="type">int</span> delta = flow;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[s];~i;i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v] &amp;&amp; dep[v] == dep[s] - e[i].w &amp;&amp; e[i].flow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;%d %d\n&quot;,s,v);</span></span><br><span class="line">            <span class="type">int</span> g = <span class="built_in">dfs</span>(v,t,<span class="built_in">min</span>((<span class="type">int</span>)e[i].flow,delta));</span><br><span class="line">            delta -= g;</span><br><span class="line">            ans += g * e[i].w;</span><br><span class="line">            e[i].flow -= g;</span><br><span class="line">            e[i ^ <span class="number">1</span>].flow += g;</span><br><span class="line">            <span class="keyword">if</span>(!delta)</span><br><span class="line">                <span class="keyword">return</span> flow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow - delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> anss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        vis[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(vis[t])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">            anss += <span class="built_in">dfs</span>(s,t,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终结果为ans</p>
<p>无源汇上下界网络流(只有建图) <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(inv,<span class="number">0</span>,<span class="built_in">sizeof</span>(inv));</span><br><span class="line"><span class="built_in">memset</span>(ouv,<span class="number">0</span>,<span class="built_in">sizeof</span>(ouv));</span><br><span class="line">ecnt = <span class="number">0</span>;</span><br><span class="line">s = <span class="number">0</span>,t = <span class="number">50050</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fr,to,liml,limr;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;fr,&amp;to,&amp;liml,&amp;limr);</span><br><span class="line">    <span class="built_in">adde</span>(fr,to,limr - liml,liml);</span><br><span class="line">    <span class="built_in">adde</span>(to,fr,<span class="number">0</span>,liml);</span><br><span class="line">    inv[to] += liml;</span><br><span class="line">    ouv[fr] += liml;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> qsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(inv[i] &gt; ouv[i])</span><br><span class="line">        <span class="built_in">adde</span>(s,i,inv[i] - ouv[i],<span class="number">0</span>),<span class="built_in">adde</span>(i,s,<span class="number">0</span>,<span class="number">0</span>),qsum += inv[i]-ouv[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">adde</span>(i,t,ouv[i]-inv[i],<span class="number">0</span>),<span class="built_in">adde</span>(t,i,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dinic</span>() == qsum) 有解;</span><br><span class="line"><span class="keyword">else</span> 无解;</span><br></pre></td></tr></table></figure></p>
<p>有源汇上下界网络流 <span class="math inline">\(ss\)</span> <span
class="math inline">\(tt\)</span>为源汇 <span
class="math inline">\(s\)</span> <span
class="math inline">\(t\)</span>为超级源点汇点 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= tt; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(inf[i] &gt; ouf[i])</span><br><span class="line">        <span class="built_in">adde</span>(s,i,inf[i]-ouf[i]),<span class="built_in">adde</span>(i,s,<span class="number">0</span>),sum += inf[i] - ouf[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">adde</span>(i,t,ouf[i]-inf[i]),<span class="built_in">adde</span>(t,i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot1 = <span class="built_in">dinic</span>();</span><br><span class="line"><span class="built_in">adde</span>(tt,ss,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line"><span class="built_in">adde</span>(ss,tt,<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> tot2 = <span class="built_in">dinic</span>();</span><br><span class="line"><span class="keyword">if</span>(tot1 + tot2 == sum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,e[ecnt - <span class="number">1</span>].flow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>最大流</tag>
        <tag>费用流</tag>
        <tag>网络流</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相关模板</title>
    <url>/2018/04/08/Str/</url>
    <content><![CDATA[<p>包含 KMP Trie AC自动机 dp/矩阵优化AC自动机</p>
<span id="more"></span>
<p>KMP: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[<span class="number">1000050</span>],b[<span class="number">1000050</span>];</span><br><span class="line"><span class="type">int</span> nxt[<span class="number">1000050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>,a + <span class="number">1</span>,b + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(nxt,<span class="number">0</span>,<span class="built_in">sizeof</span>(nxt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= len; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> lst = nxt[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(a[lst + <span class="number">1</span>] != a[i] &amp;&amp; lst) lst = nxt[lst];</span><br><span class="line">            <span class="keyword">if</span>(a[lst + <span class="number">1</span>] == a[i]) lst ++;</span><br><span class="line">            nxt[i] = lst;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len2 = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= len2; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(b[i] != a[cur + <span class="number">1</span>] &amp;&amp; cur) </span><br><span class="line">                cur = nxt[cur];</span><br><span class="line">            <span class="keyword">if</span>(a[cur + <span class="number">1</span>] == b[i]) cur ++;</span><br><span class="line">            <span class="keyword">if</span>(cur == len) ans ++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Trie树 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[<span class="number">5000050</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> val[<span class="number">5000050</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(son[<span class="number">0</span>],<span class="number">0</span>,<span class="built_in">sizeof</span>(son[<span class="number">0</span>]));</span><br><span class="line">        val[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init_pos</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(son[pos],<span class="number">0</span>,<span class="built_in">sizeof</span>(son[pos]));</span><br><span class="line">        val[pos] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= len; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = son[cur][s[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(u == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                u = ++cnt;</span><br><span class="line">                <span class="built_in">init_pos</span>(u);</span><br><span class="line">                son[cur][s[i] - <span class="string">&#x27;0&#x27;</span>] = cnt;</span><br><span class="line">                cur = u;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(val[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                cur = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        val[cur] ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">(<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> yn;</span><br><span class="line">        <span class="keyword">if</span>(val[rt]) yn = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> yn = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">9</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = son[rt][i];</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(yn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">work</span>(v)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Tr;</span><br></pre></td></tr></table></figure></p>
<p>AC自动机 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[<span class="number">3000050</span>][<span class="number">26</span>],val[<span class="number">3000050</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> fail[<span class="number">3000050</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">3000050</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie_AC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_id</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(son[pos],<span class="number">0</span>,<span class="built_in">sizeof</span>(son[pos]));</span><br><span class="line">        val[pos] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *c,<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(c);</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = <span class="built_in">get_id</span>(c[i]);</span><br><span class="line">            <span class="type">int</span> tmp = u;</span><br><span class="line">            u = son[u][v];</span><br><span class="line">            <span class="keyword">if</span>(u == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">init</span>(++cnt);</span><br><span class="line">                son[tmp][v] = cnt;</span><br><span class="line">                u = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        val[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        fail[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line">            <span class="keyword">if</span>(son[<span class="number">0</span>][i])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(son[<span class="number">0</span>][i]);</span><br><span class="line">                fail[son[<span class="number">0</span>][i]]  = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> f = fail[u];</span><br><span class="line">                <span class="keyword">if</span>(!son[u][i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(f &amp;&amp; !son[f][i]) f = fail[f];</span><br><span class="line">                fail[son[u][i]] = son[f][i];</span><br><span class="line">                <span class="comment">//lst[son[u][i]] = val[fail[son[u][i]]] ? fail[son[u][i]] : lst[fail[son[u][i]]];</span></span><br><span class="line">                q.<span class="built_in">push</span>(son[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(c);</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = <span class="built_in">get_id</span>(c[i]);</span><br><span class="line">            <span class="keyword">while</span>(cur &amp;&amp; !son[cur][v])</span><br><span class="line">                cur = fail[cur];</span><br><span class="line">            cur = son[cur][v];</span><br><span class="line">            <span class="type">int</span> tmp = cur;</span><br><span class="line">            <span class="keyword">while</span>(tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += val[tmp];</span><br><span class="line">                val[tmp] = <span class="number">0</span>;</span><br><span class="line">                tmp = fail[tmp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Trie;</span><br></pre></td></tr></table></figure> 带dp的AC自动机 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[<span class="number">2500</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> lst[<span class="number">205</span>],fail[<span class="number">250</span>];</span><br><span class="line"><span class="type">int</span> val[<span class="number">205</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>][<span class="number">101</span>][<span class="number">202</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_id</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c == <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        son[pos][<span class="number">0</span>] = son[pos][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        val[pos] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span>* c,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(c);</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = son[u][<span class="built_in">get_id</span>(c[i])];</span><br><span class="line">            <span class="keyword">if</span>(!v)</span><br><span class="line">            &#123;</span><br><span class="line">                son[u][<span class="built_in">get_id</span>(c[i])] = ++cnt;</span><br><span class="line">                <span class="built_in">init</span>(cnt);</span><br><span class="line">                u = cnt;        </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                u = v;</span><br><span class="line">        &#125;</span><br><span class="line">        val[u] |= id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        lst[<span class="number">0</span>] = fail[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = son[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">if</span>(v)</span><br><span class="line">            &#123;</span><br><span class="line">                lst[v] = fail[v] = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            val[u] |= val[lst[u]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v = son[u][i];</span><br><span class="line">                <span class="keyword">if</span>(!v) </span><br><span class="line">                &#123;</span><br><span class="line">                    son[u][i] = son[fail[u]][i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> f = fail[u];</span><br><span class="line">                <span class="keyword">while</span>(f &amp;&amp; !son[f][i]) f = fail[f];</span><br><span class="line">                fail[v] = son[f][i];</span><br><span class="line">                lst[v] = val[fail[v]] ? fail[v] : lst[fail[v]];</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Do_DP</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m; ++ j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt;= cnt; ++ k)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>;l &lt; <span class="number">4</span>; ++ l)</span><br><span class="line">                        dp[i][j][k][l] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m; ++ j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt;= cnt; ++ k)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>;l &lt; <span class="number">4</span>; ++ l)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i][j][k][l] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i &lt; n)</span><br><span class="line">                            dp[i + <span class="number">1</span>][j][son[k][<span class="number">1</span>]][l | val[son[k][<span class="number">1</span>]]] += dp[i][j][k][l],dp[i + <span class="number">1</span>][j][son[k][<span class="number">1</span>]][l | val[son[k][<span class="number">1</span>]]] %= mod;</span><br><span class="line">                        <span class="keyword">if</span>(j &lt; m)</span><br><span class="line">                            dp[i][j + <span class="number">1</span>][son[k][<span class="number">0</span>]][l | val[son[k][<span class="number">0</span>]]] += dp[i][j][k][l],dp[i][j + <span class="number">1</span>][son[k][<span class="number">0</span>]][l | val[son[k][<span class="number">0</span>]]] %= mod;</span><br><span class="line">                    &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> qsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= cnt; ++ i)</span><br><span class="line">            qsum += dp[n][m][i][<span class="number">3</span>],qsum %= mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,qsum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Trie;</span><br></pre></td></tr></table></figure>
带矩阵优化的AC自动机 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> son[<span class="number">2500</span>][<span class="number">26</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lst[<span class="number">205</span>],fail[<span class="number">250</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> val[<span class="number">205</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cnt;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> sum[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sz;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">long</span> <span class="type">long</span> _sz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sz = _sz;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;i &lt;= sz; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j = <span class="number">0</span>;j &lt;= sz; ++ j)</span><br><span class="line">                sum[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix c;</span><br><span class="line">        c.<span class="built_in">init</span>(a.sz);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> lim = c.sz;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;i &lt;= sz; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j = <span class="number">0</span>;j &lt;= sz; ++ j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> k = <span class="number">0</span>;k &lt;= sz; ++ k)</span><br><span class="line">                    c.sum[i][j] += a.sum[k][j] * sum[i][k];</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix A,<span class="type">long</span> <span class="type">long</span> tms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tms == <span class="number">1</span>) <span class="keyword">return</span> A;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tms == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix E;</span><br><span class="line">        E.<span class="built_in">init</span>(A.sz);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= A.sz; ++ i)</span><br><span class="line">            E.sum[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix tmp = A;</span><br><span class="line">    tms -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tms)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tms &amp; <span class="number">1</span>) tmp = tmp * A;</span><br><span class="line">        A = A * A;</span><br><span class="line">          tms &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">qpow</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> tms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tms)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tms &amp; <span class="number">1</span>) tmp *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        tms &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get_id</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">long</span> <span class="type">long</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(son[pos],<span class="number">0</span>,<span class="built_in">sizeof</span>(son[pos]));</span><br><span class="line">        val[pos] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span>* c,<span class="type">long</span> <span class="type">long</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> len = <span class="built_in">strlen</span>(c);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;i &lt; len; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> v = son[u][<span class="built_in">get_id</span>(c[i])];</span><br><span class="line">            <span class="keyword">if</span>(!v)</span><br><span class="line">            &#123;</span><br><span class="line">                son[u][<span class="built_in">get_id</span>(c[i])] = ++cnt;</span><br><span class="line">                <span class="built_in">init</span>(cnt);</span><br><span class="line">                u = cnt;        </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                u = v;</span><br><span class="line">        &#125;</span><br><span class="line">        val[u] |= id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue &lt;<span class="type">long</span> <span class="type">long</span>&gt; q;</span><br><span class="line">        lst[<span class="number">0</span>] = fail[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;i &lt;= <span class="number">25</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> v = son[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">if</span>(v)</span><br><span class="line">            &#123;</span><br><span class="line">                lst[v] = fail[v] = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> u = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">            val[u] |= val[lst[u]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> v = son[u][i];</span><br><span class="line">                <span class="keyword">if</span>(!v) </span><br><span class="line">                &#123;</span><br><span class="line">                    son[u][i] = son[fail[u]][i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> f = fail[u];</span><br><span class="line">                <span class="keyword">while</span>(f &amp;&amp; !son[f][i]) f = fail[f];</span><br><span class="line">                fail[v] = son[f][i];</span><br><span class="line">                lst[v] = val[fail[v]] ? fail[v] : lst[fail[v]];</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_mat</span><span class="params">(Matrix&amp; mat)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;i &lt;= cnt; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(val[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> k = son[i][j];</span><br><span class="line">                <span class="keyword">if</span>(val[k]) <span class="keyword">continue</span>;</span><br><span class="line">                mat.sum[i][k] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;i &lt;= cnt + <span class="number">1</span>; ++ i)</span><br><span class="line">            mat.sum[i][cnt] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Trie;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑学笔记</title>
    <url>/2023/09/21/%E6%8B%93%E6%89%91%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Markdown 源代码：https://pastebin.ubuntu.com/p/hZSTNRm7jc/</p>
<p>分节次的笔记（清华云盘）：https://cloud.tsinghua.edu.cn/d/2c4efaca588a4326958d/</p>
<h2 id="lecture-info">00. Lecture Info</h2>
<h3 id="考核">1. 考核</h3>
<p>作业 20%、期中 30%、期末 50%</p>
<h3 id="作业">2. 作业</h3>
<p>每周四上午 9：50 之前提交</p>
<h3 id="答疑">3. 答疑</h3>
<p>周二下午 2:00-3:00 荷二 103</p>
<h3 id="内容">4. 内容</h3>
<ul>
<li>基础内容：点集拓扑、代数拓扑</li>
<li>拓展内容；</li>
</ul>
<span id="more"></span>
<h3 id="一点牢骚">一点牢骚</h3>
<p>很好，又是用 md
追赶手写板书的一门课程，竟然也是英文板书。希望不要像复分析一样上到一半就没兴趣追了（</p>
<h2 id="引入范畴与连续映射入门">01. 引入：范畴与连续映射入门</h2>
<h3 id="拓扑学研究的范畴">拓扑学研究的范畴</h3>
<ul>
<li><h4
id="范畴的观点categories"><strong>范畴</strong>的观点（Categories）</h4>
<ul>
<li>研究对象（Objects）</li>
<li>态射（Morphism）</li>
</ul>
<p>这些观点通常对应了数学中的不同分支（Subjects）</p>
<p>eg.</p>
<p>线性代数 对应 线性范畴（研究对象：线性空间；态射：线性映射）</p>
<p>抽象代数 对应 群范畴（研究对象：群；态射：群同态）</p>
<p>类似：环范畴、环、环同态</p>
<p>拓扑学 对应
拓扑空间范畴（研究对象：拓扑空间；态射：连续映射）</p></li>
<li><h4 id="拓扑学研究的例子">拓扑学研究的例子</h4>
<p>凸多面体的欧拉公式（Euler's Formula）：设 <span
class="math inline">\(\chi=v-e+f\)</span> ，其中 <span
class="math inline">\(v\)</span> 是顶点个数，<span
class="math inline">\(e\)</span> 是棱的个数，<span
class="math inline">\(f\)</span> 是面的个数（vertice, edge, face），则
<span class="math inline">\(\chi=2\)</span>。称 <span
class="math inline">\(\chi\)</span> 为欧拉示性数（Euler
Characteristic）</p>
<p>另一个例子：仍然取一个凸多面体，但在上面挖掉小立方体，如下图所示：</p>
<figure>
<img src="/01-1.png" alt="image-20230919153324783" />
<figcaption aria-hidden="true">image-20230919153324783</figcaption>
</figure>
<p>在这种情况下，上半面不能再称之为面（不再单连通），需要多加一条棱如下图所示：</p>
<figure>
<img src="/01-2.png" alt="image-20230919153445258" />
<figcaption aria-hidden="true">image-20230919153445258</figcaption>
</figure>
<p>在增加一条棱后，计算此时的欧拉示性数有 <span
class="math inline">\(\chi=2\)</span>.</p>
<p>进一步地：</p>
<p>仍然对大的立方体做操作，如图所示：</p>
<figure>
<img src="/01-3.png" alt="image-20230919153756873" />
<figcaption aria-hidden="true">image-20230919153756873</figcaption>
</figure>
<p>我们做类似的操作切面：</p>
<figure>
<img src="/01-4.png" alt="image-20230919153821373" />
<figcaption aria-hidden="true">image-20230919153821373</figcaption>
</figure>
<p>然而此时的 <span class="math inline">\(\chi=0\)</span>，不再为 <span
class="math inline">\(2\)</span>
了。（为什么？最后一个图形无法通过连续形变变成球面，只能变成环面（Torus=:<span
class="math inline">\(T\)</span>））</p>
<p>将来我们会证明关于欧拉示性数的事实：<span
class="math inline">\(\chi(S^2)=2\)</span>；<span
class="math inline">\(\chi(T)=0\)</span></p>
<p>更一般地，令 <span class="math inline">\(\sum_g\)</span>
为形如下图的曲面：</p>
<figure>
<img src="/01-5.png" alt="image-20230919154302800" />
<figcaption aria-hidden="true">image-20230919154302800</figcaption>
</figure>
<p>那么有 <span class="math inline">\(\chi(\Sigma_g)=2-2g\)</span>.</p>
<p>于是有下述结论：欧拉示性数 <span class="math inline">\(\chi\)</span>
是一个<strong>拓扑不变量</strong>（Topological
Invariant），拓扑不变量也将是这门课程研究的重点。</p>
<p>所谓<strong>拓扑不变量</strong>指的是：</p>
<ul>
<li>其被连续的形状变化所保持。</li>
<li>拓扑不变量可以是数字，也可以是更复杂的代数结构，例如群或环。</li>
<li>拓扑不变量是拓扑学这门课程主要研究的对象。</li>
</ul></li>
<li><h4 id="连续映射">连续映射</h4>
<ul>
<li><h5 id="数学分析对连续映射的定义">数学分析对连续映射的定义</h5>
<p><span class="math inline">\(f:\mathbb R^m\to \mathbb R^n\)</span></p>
<p>定义：映射 <span class="math inline">\(f\)</span> 被称为是在 <span
class="math inline">\(x\in \mathbb{R}^m\)</span> 连续的，如果有 <span
class="math inline">\(\forall \varepsilon&gt;0,\exists
\delta&gt;0\)</span>，使得若 <span
class="math inline">\(|x&#39;-x|&lt;\delta\)</span>，则 <span
class="math inline">\(|f(x&#39;)-f(x)|&lt;\varepsilon\)</span>。</p>
<p>如果 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(\mathbb R^m\)</span> 处处连续，则称 <span
class="math inline">\(f\)</span> 是连续函数。</p></li>
<li><h5 id="度量-metric">度量 (Metric)</h5>
<p>回顾欧氏空间中在 $R^n $ 上的 <span class="math inline">\(|\cdot
|\)</span>，它诱导了连续性。</p></li>
<li><h5 id="度量空间-metric-space">度量空间 (Metric Space)</h5>
<p>定义：集合 <span class="math inline">\(X\)</span>
被称为是一个度量空间，如果存在映射 <span class="math inline">\(d:X\times
X\to \mathbb R\)</span>，满足下面几个公理</p>
<ul>
<li><span class="math inline">\(d(x_1,x_2)=0\)</span> 当且仅当 <span
class="math inline">\(x_1=x_2\)</span>；</li>
<li><span
class="math inline">\(d(x_1,x_2)=d(x_2,x_1)\)</span>（对称性）；</li>
<li><span class="math inline">\(d(x_1,x_3)\leq
d(x_1,x_2)+d(x_2,x_3)\)</span>（三角不等式）；</li>
</ul>
<p><span class="math inline">\(\forall x_1,x_2,x_3\in X\)</span>，则称
<span class="math inline">\(d\)</span> 是一个度量，<span
class="math inline">\((X,d)\)</span> 是一个度量空间。</p>
<p>注：由三条公理可以推出距离的非负性：令 <span
class="math inline">\(x_1=x_3\)</span>，有 <span
class="math inline">\(d(x_1,x_3)\leq 2 d(x_1,x_2)\)</span>，从而 <span
class="math inline">\(d(x_1,x_2)\geq 0\)</span>.</p></li>
<li><h5 id="基础的度量空间例子">基础的度量空间例子</h5>
<ul>
<li><span class="math inline">\(\forall
x_1=(x_1^1,\cdots,x_1^n),x_2=(x_2^1,\cdots,x_2^n)\in \mathbb
R^n\)</span>，令 <span
class="math inline">\(d(x_1,x_2)=\sqrt{\sum_{i=1}^n(x_1^i-x_2^i)^2}\)</span>，则
<span class="math inline">\((\mathbb R^n,d)\)</span>
是一个度量空间（最熟悉的欧式空间）</li>
<li>更一般地，考虑令 <span class="math inline">\(p\geq 1\)</span>，令
<span
class="math inline">\(d_p(x_1,x_2)=(\sum_{i=1}^n|x_1^i-x_2^i|^p)^{1/p}\)</span>，则
<span class="math inline">\((\mathbb R^n,d_p)\)</span>
也是一个度量空间</li>
<li>有度量空间 <span class="math inline">\((X,d)\)</span>，考虑子集
<span class="math inline">\(Y\subset X\)</span>，则 <span
class="math inline">\((Y,d|_{Y})\)</span> 是一个度量空间</li>
</ul></li>
<li><h5 id="度量空间连续性的定义">度量空间连续性的定义</h5>
<p>令 <span class="math inline">\(f:X\to Y\)</span>
度量空间间的映射，定义：</p>
<p>称 <span class="math inline">\(f\)</span> 在点 <span
class="math inline">\(x\in X\)</span> 处是连续的，如果 <span
class="math inline">\(\forall
\varepsilon&gt;0,\exists\delta&gt;0\)</span>，使得 <span
class="math inline">\(d(f(x),f(x&#39;))&lt;\varepsilon\)</span> 若 <span
class="math inline">\(d(x,x&#39;)&lt;\delta\)</span>.</p>
<p>称 <span class="math inline">\(f\)</span> 是连续的如果 <span
class="math inline">\(f\)</span> 对于每一个 <span
class="math inline">\(x\in X\)</span> 都是连续的。</p></li>
<li><h5 id="引入球的概念">引入：球的概念</h5>
<p>对于 <span class="math inline">\(\varepsilon&gt;0\)</span> 以及任意的
<span class="math inline">\(x\in X\)</span>，记 <span
class="math inline">\(B(x,\varepsilon):=\{y\in X\mid
d(x,y)&lt;\varepsilon\}\)</span>，称该集合为一个球，球心为 <span
class="math inline">\(x\)</span>，半径为 <span
class="math inline">\(\varepsilon\)</span>。</p>
<p>用以改进连续性：<span class="math inline">\(f\)</span> 是 <span
class="math inline">\(x\)</span> 是连续的等价于 <span
class="math inline">\(\forall\varepsilon&gt;0,\exists
\delta&gt;0\)</span>，使得 <span
class="math inline">\(f(B(x,\delta))\subset
B(f(x),\varepsilon)\)</span>.</p></li>
<li><h5 id="定义开集-open-set">定义：开集 (Open Set)</h5>
<p>定义 <span class="math inline">\(X\)</span>
是一个度量空间（今后度量空间略去 <span
class="math inline">\(d\)</span>），一个集合 <span
class="math inline">\(U\subset X\)</span> 称为是开集，若 <span
class="math inline">\(\forall x\in U\)</span>，<span
class="math inline">\(\exists\varepsilon&gt;0\)</span>，使得 <span
class="math inline">\(B(x,\varepsilon)\subset U\)</span>.</p>
<p>与此同时，<span class="math inline">\(\forall x\in U\)</span>，我们将
<span class="math inline">\(U\)</span> 称作 <span
class="math inline">\(x\)</span> 的一个<strong>邻域
(Neighborhood)</strong>。</p>
<p>事实：<span class="math inline">\(\forall x\in
X,\varepsilon&gt;0\)</span>，则 <span
class="math inline">\(B(x,\varepsilon)\)</span> 一定是开集。</p></li>
<li><h5 id="定理-开集">定理 (开集)</h5>
<ul>
<li><ol type="1">
<li>任取一个指标集 <span
class="math inline">\(I\)</span>（可以为无限集），并集 <span
class="math inline">\(\bigcup_{i\in I}U_i\)</span> 是 <span
class="math inline">\(X\)</span> 中开集若 <span
class="math inline">\(U_i\)</span> <span class="math inline">\(\forall
i\in I\)</span> 都是开集.（开集的无限并是开）</li>
</ol></li>
<li><ol start="2" type="1">
<li>取交集 <span class="math inline">\(\bigcap_{i=1}^n U_i\)</span>
仍然是开集若 <span class="math inline">\(U_i\ \forall
i=1,2,\cdots,n\)</span> 都是开集.（开集的有限交是开）</li>
</ol></li>
<li><ol start="3" type="1">
<li>全空间 <span class="math inline">\(X\)</span> 与空集 <span
class="math inline">\(\varnothing\)</span> 都是开集.</li>
</ol></li>
</ul>
<p>证明：</p>
<ul>
<li><ol type="1">
<li>任取 <span class="math inline">\(x\in \bigcup_{i\in
I}U_i\)</span>，则 <span class="math inline">\(x\in U_i\)</span>
对于某个特定的 <span class="math inline">\(i\)</span>，于是 <span
class="math inline">\(\exists B(x,\varepsilon)\subset U_i\)</span>，因而
<span class="math inline">\(B(x,\varepsilon)\subset \bigcup_{i\in
I}U_i\)</span>.</li>
</ol></li>
<li><ol start="2" type="1">
<li><span class="math inline">\(\forall x\in \bigcap_{i=1}^n
U_i\)</span>，则 <span class="math inline">\(x\in U_i, \forall
i\)</span>，则 <span class="math inline">\(\exists
B(x,\varepsilon_i)\subset U_i\)</span>，因而 <span
class="math inline">\(B(x,\min_i{\varepsilon_i})\subset \bigcap_{i\in
I}U_i\)</span>.</li>
</ol></li>
<li><ol start="3" type="1">
<li>显然。</li>
</ol></li>
</ul>
<p>注：如果取任意交集 <span class="math inline">\(\bigcap_{i\in I}
U_i\)</span>，一般情况下，该交集可以不是开集（其中 <span
class="math inline">\(U_i\)</span> 皆为开集）。</p>
<p>例如令 <span class="math inline">\(U_i=\mathbb R \setminus
\{\cfrac{1}{i}\}\)</span>，取交集 <span
class="math inline">\(\bigcap_{i=1}^\infty U_i=\mathbb R\setminus
\{1,\cfrac{1}{2},\cdots\}\)</span>，该集合不再是 <span
class="math inline">\(\mathbb R\)</span> 里的开集。（对于 <span
class="math inline">\(0\)</span>，不存在一个球使其包含在该集合中）</p></li>
<li><h5 id="定义闭集-close-set">定义：闭集 (Close Set)</h5>
<p>一个集合 <span class="math inline">\(F\subset X\)</span>
被称为是<strong>闭 (Close)</strong>的，若 <span
class="math inline">\(X\setminus F\)</span> 是开集。</p></li>
<li><h5 id="关键定理-连续性">关键定理 (连续性)</h5>
<p>令 <span class="math inline">\(f:X\to Y\)</span> 其中 <span
class="math inline">\(X,Y\)</span> 是度量空间，则 <span
class="math inline">\(f\)</span> 是连续映射当且仅当 <span
class="math inline">\(f^{-1}(U)\)</span> 在 <span
class="math inline">\(X\)</span> 中是开的，<span
class="math inline">\(\forall U\subset Y\)</span> 开集。</p>
<p>证明：</p>
<p><span class="math inline">\((\Rightarrow)\)</span>：考虑 <span
class="math inline">\(\forall x\in f^{-1}(U)\)</span>，我们选取 <span
class="math inline">\(B(f(x),\varepsilon)\subset U\)</span>，由于 <span
class="math inline">\(f\)</span> 是连续的，有 <span
class="math inline">\(\exists \delta\)</span> 使得 <span
class="math inline">\(f(B(x,\delta))\subset B(f(x),\varepsilon)\subset
U\)</span>.</p>
<p>换言之，<span class="math inline">\(B(x,\delta)\subset
f^{-1}(U)\)</span>，于是 <span class="math inline">\(f^{-1}(U)\)</span>
是开集。</p>
<p><span class="math inline">\((\Leftarrow)\)</span>：考虑 <span
class="math inline">\(\forall x\in X\)</span>，考虑小球 <span
class="math inline">\(B(f(x),\varepsilon)\subset Y\)</span>，于是 <span
class="math inline">\(f^{-1}(B(f(x),\varepsilon))\subset X\)</span>
是开集。</p>
<p>于是 <span class="math inline">\(\exists \delta&gt;0\)</span>，使得
<span class="math inline">\(B(x,\delta)\subset
f^{-1}(B(f(x),\varepsilon))\)</span>，于是 <span
class="math inline">\(f(B(x,\delta))\subset
B(f(x),\varepsilon)\)</span>，于是 <span
class="math inline">\(f\)</span> 是连续函数。</p></li>
<li><h5 id="定义拓扑空间-topological-space">定义：拓扑空间 (Topological
Space)</h5>
<p>一个集合 <span class="math inline">\(X\)</span>
被称为是<strong>拓扑空间</strong>，若存在 <span
class="math inline">\(X\)</span> 的子集族 <span
class="math inline">\(\tau\)</span>，将该子集族中的集合称之为开集，使得：</p>
<ul>
<li><span class="math inline">\(X,\varnothing\in \tau\)</span></li>
<li><span class="math inline">\(\forall\)</span> 指标集 <span
class="math inline">\(I\)</span>，若 <span class="math inline">\(\forall
i\in I,U_i\in \tau\)</span>，则 <span
class="math inline">\(\bigcup_{i\in I}U_i\in \tau\)</span></li>
<li><span class="math inline">\(U_i\in\tau,\forall
i=1,\cdots,n\)</span>，则 <span class="math inline">\(\bigcap_{i=1}^n
U_i\in \tau\)</span></li>
</ul>
<p>则称 <span class="math inline">\(X\)</span> 是一个拓扑空间，称 <span
class="math inline">\(\tau\)</span> 为 <span
class="math inline">\(X\)</span>
上的一个<strong>拓扑</strong>。</p></li>
<li><h5 id="例子">例子</h5>
<ul>
<li><p>度量空间是特殊的拓扑空间：若 <span
class="math inline">\((X,d)\)</span> 是一个度量空间，则 <span
class="math inline">\(d\)</span> 一定诱导了一个 <span
class="math inline">\(X\)</span> 上的拓扑。</p></li>
<li><p>（子空间拓扑）若 <span class="math inline">\(Y\)</span> 是 <span
class="math inline">\(X\)</span> 的子集，<span
class="math inline">\(\tau\)</span> 是 <span
class="math inline">\(X\)</span> 上的一个拓扑，则 <span
class="math inline">\(\tau\)</span> 可以诱导一个 <span
class="math inline">\(Y\)</span> 上的拓扑 <span
class="math inline">\(\tau|_Y\)</span>：</p>
<p><span class="math inline">\(\forall V\subset Y\)</span>，我们称 <span
class="math inline">\(V\)</span> 是 <span
class="math inline">\(Y\)</span> 里的开集，若 <span
class="math inline">\(V\)</span> 可以被写成如下的形式：<span
class="math inline">\(U\cap Y\)</span>，其中 <span
class="math inline">\(U\in \tau\)</span>.</p>
<p>可以验证 <span class="math inline">\((Y,\tau|_Y)\)</span>
是一个拓扑空间。将这个拓扑空间称为 <span
class="math inline">\((X,\tau)\)</span> 的子空间。</p></li>
</ul></li>
<li><h5 id="定义连续映射">定义：连续映射</h5>
<p>令 <span class="math inline">\(f:X\to Y\)</span>
是一个拓扑空间间的映射，<span class="math inline">\(f\)</span>
被称为连续映射，如果 <span class="math inline">\(\forall U\subset
Y\)</span> 开集，<span class="math inline">\(f^{-1}(U)\)</span> 是 <span
class="math inline">\(X\)</span> 中开集。</p>
<p>由此推出拓扑范畴：拓扑空间与拓扑空间的连续映射。</p></li>
</ul></li>
</ul>
<h3
id="一个可能不那么典型的例子拓扑可以非常丰富">*一个可能不那么典型的例子（拓扑可以非常丰富）</h3>
<p>通常地，<span class="math inline">\(\mathbb R\)</span>
上的欧式度量会诱导 <span class="math inline">\(\mathbb R\)</span>
上的拓扑；继续取子空间，则其可以诱导一个 <span
class="math inline">\(\mathbb Q\)</span> 上的拓扑。</p>
<p>我们换一种度量的观点：令 <span class="math inline">\(p\)</span>
是一个素数，对于非零有理数 <span
class="math inline">\(a=p^m\cfrac{b}{c}\)</span>，其中 <span
class="math inline">\(b,c\)</span> 与 <span
class="math inline">\(p\)</span> 互素。定义 <span
class="math inline">\(p\text{-adic}\)</span> 测量 (p-adic
evaluation)：<span class="math inline">\(v_p:\mathbb Q\to\mathbb
Z\cup\{\infty\}\)</span>，<span
class="math inline">\(v_p(a)=m\)</span>，<span
class="math inline">\(v_p(0)=\infty\)</span>.</p>
<p>于是：</p>
<ol type="1">
<li><p><span class="math inline">\(v_p(a)=\infty\)</span> 当且仅当 <span
class="math inline">\(v_p(a)=0\)</span></p></li>
<li><p><span
class="math inline">\(v_p(ab)=v_p(a)+v_p(b)\)</span></p></li>
</ol>
<p>于是定义 <span class="math inline">\(p\text{-adic}\)</span>
绝对值：<span class="math inline">\(||\cdot||_p\)</span> 为 <span
class="math inline">\(||a||_p=p-v_p(a)\)</span></p>
<p>定义 <span class="math inline">\(d(a,b):=||a-b||_p\)</span> 称为一个
<span class="math inline">\(p\text{-adic}\)</span> 度量（p-adic
metric），这会诱导 <span class="math inline">\(p\text{-adic}\)</span>
拓扑。</p>
<h2 id="闭集与连续映射">02. 闭集与连续映射</h2>
<h3 id="对闭集的研究">对闭集的研究</h3>
<ul>
<li><h4 id="回忆闭集的定义">回忆：闭集的定义</h4>
<p>一个集合 <span class="math inline">\(A\subset X\)</span> 是闭集当
<span class="math inline">\(X\setminus A\)</span> 是开集。</p></li>
<li><h4 id="一些例子">一些例子</h4>
<p><span class="math inline">\(A=\{(x,y)\mid x^2+y^2=1\}\subseteq
\mathbb R^2\)</span> （此后，若不加特殊说明，空间皆使用欧氏拓扑）</p>
<p>它是一个闭集。</p>
<p><span class="math inline">\(A=\{(x,y)\mid x^2+y^2\leq 1\}\subseteq
\mathbb R^2\)</span></p>
<p>它也是一个闭集。</p>
<p><span class="math inline">\(A=\{(x,y)\mid x^2+y^2=1,y&gt;0\}\subseteq
\mathbb R^2\)</span></p>
<p>它不是开集，也不是闭集。</p></li>
<li><h4 id="极限点-limit-point-的定义">极限点 (limit point) 的定义</h4>
<p>定义：令 <span class="math inline">\(A\subset X\)</span>，<span
class="math inline">\(p\in X\)</span>，<span
class="math inline">\(p\)</span> 是集合 <span
class="math inline">\(A\)</span> 的<strong>极限点 (limit point)</strong>
如果其任意一个邻域都包含了 <span class="math inline">\(A-\{p\}\)</span>
中至少一个点。</p>
<p>例子：</p>
<ul>
<li><p>令 <span class="math inline">\(X=\mathbb R\)</span>，欧氏拓扑，令
<span class="math inline">\(A=\{\cfrac{1}{n}\mid
n=1,2,3,\cdots\}\)</span>，则 <span class="math inline">\(A\)</span>
有唯一一个极限点 <span class="math inline">\(0\)</span>.</p></li>
<li><p>令 <span class="math inline">\(X=\mathbb R\)</span>，<span
class="math inline">\(A=[0,1)\)</span>，则 <span
class="math inline">\(\forall p\in A\)</span>，<span
class="math inline">\(p\)</span> 是 <span
class="math inline">\(A\)</span> 的一个极限点，与此同时 <span
class="math inline">\(1\)</span> 也是 <span
class="math inline">\(A\)</span> 的极限点。</p></li>
<li><p>令 <span class="math inline">\(X=\mathbb R\)</span>，<span
class="math inline">\(A=\mathbb Q\)</span>，则 <span
class="math inline">\(\forall p\in X\)</span> 都是 <span
class="math inline">\(A\)</span> 的极限点。</p></li>
<li><p>令 <span class="math inline">\(X=\mathbb C\)</span>，在 <span
class="math inline">\(\mathbb C\)</span> 上定义 Zariski Topology，定义
<span class="math inline">\(X\)</span>
的一个子集是开集，如果它的补集是有限集或全空间 <span
class="math inline">\(X\)</span>.</p>
<p>考虑 <span class="math inline">\(f(t)\in \mathbb C[t]\)</span>
是一个复系数单变量多项式，即 <span class="math inline">\(f(t)\)</span>
可以写成如下形式：<span
class="math inline">\(a(t-a_1)\cdots(t-a_n)\)</span>. 其中 <span
class="math inline">\(a_1,\cdots,a_n\in \mathbb C\)</span>。</p>
<p>一个集合 <span class="math inline">\(A\subset X\)</span>
是闭集，当且仅当 <span class="math inline">\(A\)</span> 是有限集或 <span
class="math inline">\(A\)</span> 是全空间 <span
class="math inline">\(X\)</span>，这等价于 <span
class="math inline">\(A\)</span> 是某一个多项式的零点集。这即为 Zariski
Topology 的定义动机。</p>
<p>我们来考察极限点。若集合 <span class="math inline">\(A\)</span>
是有限集，那么 <span class="math inline">\(A\)</span> 没有极限点；若集合
<span class="math inline">\(A\)</span> 是无限集，则任意 <span
class="math inline">\(p\in X\)</span> 都是 <span
class="math inline">\(A\)</span> 的极限点。</p>
<p>(*)更多地，我们还可以考虑 Zariski Topology 在 <span
class="math inline">\(\mathbb C^n\)</span> 时的情形。</p>
<p>一个集合 <span class="math inline">\(A\subseteq \mathbb C^n\)</span>
是闭集，如果 <span class="math inline">\(A\)</span> 是某一些多项式的零点
<span class="math inline">\(f_1,f_2,\cdots,f_m\in \mathbb
C[t_1,\cdots,t_n]\)</span>.</p></li>
</ul></li>
<li><h4 id="闭集一般性的定义">闭集一般性的定义</h4>
<p>定理：一个集合是闭集，当且仅当它包含了自己的所有极限点。</p>
<p>证明：</p>
<p><span class="math inline">\((\Rightarrow)\)</span>：令 <span
class="math inline">\(A\subset X\)</span> 是一个闭集，根据定义，<span
class="math inline">\(X\setminus A\)</span> 是一个开集。于是 <span
class="math inline">\(\forall p\in X\setminus A\)</span>，有 <span
class="math inline">\(X\setminus A\)</span> 是 <span
class="math inline">\(p\)</span> 的邻域，且该邻域与 <span
class="math inline">\(A\)</span> 不交。于是 <span
class="math inline">\(p\)</span> 不是 <span
class="math inline">\(A\)</span> 的极限点。</p>
<p><span class="math inline">\((\Leftarrow)\)</span>：令 <span
class="math inline">\(p\in X\setminus A\)</span>，因为 <span
class="math inline">\(p\)</span> 不是 <span
class="math inline">\(A\)</span> 的极限点，<span
class="math inline">\(\exists\)</span> 邻域 <span
class="math inline">\(U_p\)</span>，使得 <span
class="math inline">\(U_p\subset X\setminus A\)</span>，因而 <span
class="math inline">\(X\setminus A=\bigcup_{p\in X\setminus A}
U_p\)</span> 是开集，因此 <span class="math inline">\(A\)</span>
是一个闭集。</p></li>
<li><h4 id="闭包-closure-的定义">闭包 (closure) 的定义</h4>
<p>定义：从集合 <span class="math inline">\(A\)</span> 出发，将 <span
class="math inline">\(A\)</span>
本身与它所有的极限点并起来，将这称作集合 <span
class="math inline">\(A\)</span> 的闭包，记作 <span
class="math inline">\(\bar A\)</span>.</p>
<p>定理：<span class="math inline">\(A\)</span> 的闭包是包含 <span
class="math inline">\(A\)</span> 的最小闭集。</p>
<ul>
<li><p>对定理中“最小”的解释</p>
<p>有两种不同的（等价的）表达方式。</p>
<ul>
<li><span class="math inline">\(\bar A=\bigcap_{B\supset A, B\text{ is
closed}} B\)</span></li>
<li><span class="math inline">\(\bar A\)</span> 是闭集，且对于 <span
class="math inline">\(\forall B\supset A\)</span> 且 <span
class="math inline">\(B\)</span> 为闭集，都有 <span
class="math inline">\(A\subset\bar A\subset B\)</span>.</li>
</ul></li>
</ul>
<p>证明：</p>
<p>首先证明 <span class="math inline">\(\bar A\)</span> 是一个闭集。</p>
<p><span class="math inline">\(\forall p\in X\setminus \bar
A\)</span>，<span class="math inline">\(p\)</span> 一定不是 <span
class="math inline">\(A\)</span> 的极限点，于是 <span
class="math inline">\(\exists\)</span> 邻域 <span
class="math inline">\(U_p\)</span> 使得 <span
class="math inline">\(U_p\cap A=\varnothing\)</span>.</p>
<p>另一方面，<span class="math inline">\(\forall q\in U_p\)</span>，有
<span class="math inline">\(U_p\)</span> 也是 <span
class="math inline">\(q\)</span> 的邻域，因此 <span
class="math inline">\(q\)</span> 不是 <span
class="math inline">\(A\)</span> 的极限点。因此 <span
class="math inline">\(U_p\cap \bar A=\varnothing\)</span>.</p>
<p>因此 <span class="math inline">\(U_p\subset X\setminus \bar
A\)</span>，因此 <span class="math inline">\(X\setminus \bar
A=\bigcup_{p\in X\setminus \bar A}U_p\)</span>，因此 <span
class="math inline">\(X\setminus \bar A\)</span> 是开集，因此 <span
class="math inline">\(\bar A\)</span> 是闭集。</p>
<p>接着我们来证明最小性。</p>
<p>若 <span class="math inline">\(B\)</span> 是一个闭集且 <span
class="math inline">\(A\subset B\)</span>，则有 <span
class="math inline">\(\forall\)</span> <span
class="math inline">\(A\)</span> 的极限点也是 <span
class="math inline">\(B\)</span> 的极限点。因为 <span
class="math inline">\(B\)</span> 是闭集，这些极限点都落在其中，于是
<span class="math inline">\(B\)</span> 包含了所有 <span
class="math inline">\(A\)</span> 的极限点。因此 <span
class="math inline">\(\bar A\subset B\)</span>.</p>
<p>推论：若 <span class="math inline">\(A\subset X\)</span>，则 <span
class="math inline">\(A\)</span> 是闭集当且仅当 <span
class="math inline">\(A=\bar A\)</span>.</p></li>
<li><h4 id="稠密-dense-的定义">稠密 (dense) 的定义</h4>
<p>定义：<span class="math inline">\(A\subset X\)</span>
被称为是稠密的，如果 <span class="math inline">\(\bar A=X\)</span>.</p>
<p>例子：<span
class="math inline">\(\mathbb{Q}\subseteq\mathbb{R}\)</span>
是稠密的。</p></li>
<li><h4 id="内部点-interior-point-的定义">内部点 (interior point)
的定义</h4>
<p>定义：<span class="math inline">\(x\subset A\)</span>
被称作一个内部点当 <span class="math inline">\(\exists\)</span> <span
class="math inline">\(x\)</span> 的邻域 <span
class="math inline">\(U\)</span> 使得 <span
class="math inline">\(U\subseteq A\)</span>.</p>
<p>记 <span class="math inline">\(\mathring A=\{x\in A\mid x \text{
是内部点}\}\)</span>.</p>
<p>例子：</p>
<p>令 <span class="math inline">\(A=\{(x,y)\mid x^2+y^2\leq 1\}\subseteq
\mathbb R^2\)</span>，则 <span class="math inline">\(\mathring
A=\{(x,y)\mid x^2+y^2&lt;1\}\subseteq \mathbb R^2\)</span></p></li>
<li><h4 id="边界点-frontier-point-boundary-point-的定义">边界点
(frontier point / boundary point) 的定义</h4>
<p>定义：<span class="math inline">\(x\in X\)</span> 被称为 <span
class="math inline">\(A\)</span> 的边界点（请注意定义域），如果 <span
class="math inline">\(x\)</span> 既不是 <span
class="math inline">\(A\)</span> 的内部点也不是 <span
class="math inline">\(X\setminus A\)</span> 的内部点。</p>
<p>例子：</p>
<p><span class="math inline">\(A_1=\{(x,y)\mid x^2+y^2\leq1\}\subseteq
\mathbb R^2\)</span>，若定义 <span class="math inline">\(C=\{(x,y)\mid
x^2+y^2=1\}\)</span>，则 <span class="math inline">\(C\)</span> 就是
<span class="math inline">\(A_1\)</span> 边界点的集合。</p>
<p><span class="math inline">\(A_2=\{(x,y)\mid x^2+y^2&lt;1\}\subseteq
\mathbb R^2\)</span>，仍如上定义 <span
class="math inline">\(C\)</span>，则 <span
class="math inline">\(C\)</span> 也是 <span
class="math inline">\(A_2\)</span> 边界点的集合。</p>
<p>（<span class="math inline">\(A\)</span> 的边界点未必包含于 <span
class="math inline">\(A\)</span> 中）</p>
<p><span class="math inline">\(0,1\)</span> 都是下面集合的边界点：<span
class="math inline">\([0,1)\subseteq \mathbb{R}\)</span>.</p></li>
<li><h4 id="拓扑基-basis-base-的定义">拓扑基 (basis / base) 的定义</h4>
<p>定义：令 <span class="math inline">\(\beta\)</span> 是一个由某一些
<span class="math inline">\(X\)</span> 中开集构成的集族，假设 <span
class="math inline">\(X\)</span> 中的每一个开集都可以表示为 <span
class="math inline">\(\beta\)</span> 中成员的并，则称 <span
class="math inline">\(\beta\)</span> 是 <span
class="math inline">\(X\)</span> 的一组<strong>基</strong>。把 <span
class="math inline">\(\beta\)</span> 中的元素称作基础开集。</p>
<p>例子：</p>
<p><span class="math inline">\(X\)</span> 是度量空间，则 <span
class="math inline">\(\beta:=\{B(x,\varepsilon)\mid x\in
X,\varepsilon&gt;0\}\)</span> 是 <span class="math inline">\(X\)</span>
的一组拓扑基。</p>
<p>定理：令 <span class="math inline">\(X\)</span> 是一个集合，令 <span
class="math inline">\(\beta\)</span> 是 <span
class="math inline">\(X\)</span> 中集族且 <span
class="math inline">\(\beta\)</span> 不为空，假设 <span
class="math inline">\(\bigcup_{B\in\beta}B=X\)</span> 且 <span
class="math inline">\(\forall B_1,B_2\in \beta\)</span>，<span
class="math inline">\(\forall x\in B_1\cap B_2\)</span>，<span
class="math inline">\(\exists B_{3}^x\in \beta\)</span>，使得 <span
class="math inline">\(x\in B_{3}^x\)</span> 且 <span
class="math inline">\(B_{3}^x\subset B_1\cap
B_2\)</span>，则我们可以定义 <span class="math inline">\(X\)</span>
中开集为 <span class="math inline">\(\beta\)</span>
中成员的任意并，则这个定义给出了 <span class="math inline">\(X\)</span>
上的一个拓扑。</p>
<p>证明：<span class="math inline">\(U_i=\bigcup_j
B_{ij}\)</span>，<span class="math inline">\(B_{ij}\in
\beta\)</span>，<span class="math inline">\(\bigcup_i
U_i=\bigcup_{ij}B_{ij}\)</span>，因此为开；</p>
<p><span class="math inline">\(U_1=\bigcup_{i}B_{1i}\)</span>，<span
class="math inline">\(U_2=\bigcup_{j}B_{2j}\)</span>，<span
class="math inline">\(B_{1i}B_{2j}\in \beta\)</span>，则 <span
class="math inline">\(U_1\cap U_2=\bigcup_{ij}(B_{1i}\cap
B_{2j})\)</span> ，因此只需要证明 <span class="math inline">\(\forall
B_1,B_2\in\beta\)</span>，有 <span class="math inline">\(B_1\cap
B_2\)</span> 为开集。证明：<span class="math inline">\(\forall x\in
B_1\cap B_2\)</span>，<span class="math inline">\(\exists
B_{3}^x\)</span> 使得 <span class="math inline">\(x\in
B_{3}^x\)</span>，有 <span class="math inline">\(B_{3}^x\subset B_1\cap
B_2\)</span>，因此 <span class="math inline">\(\bigcup_{x\in B_1\cap
B_2} B_{3}^x=B_1\cap B\)</span> 是开集.</p>
<p>显然 <span class="math inline">\(X,\varnothing\)</span>
都是开集。综上这构成拓扑。</p></li>
</ul>
<h3 id="对连续映射的研究">对连续映射的研究</h3>
<ul>
<li><h4 id="回忆连续映射">回忆：连续映射</h4>
<p><span class="math inline">\(f:X\to Y\)</span>
是连续映射，当且仅当开集的原像也是开集。</p></li>
<li><h4 id="连续映射的复合">连续映射的复合</h4>
<p>定理：若有映射 <span class="math inline">\(f:X\to Y\)</span> 与映射
<span class="math inline">\(g:Y\to
Z\)</span>，若两个映射都是连续映射，则 <span
class="math inline">\(g\circ f\)</span> 仍然是连续映射。</p>
<p>证明：根据定义，任取 <span class="math inline">\(U\subset Z\)</span>
为开集，根据连续性，有 <span class="math inline">\(g^{-1}(U)\)</span> 在
<span class="math inline">\(Y\)</span> 中是开集，进一步其在 <span
class="math inline">\(f^{-1}(g^{-1}(U))\)</span> 在 <span
class="math inline">\(X\)</span> 中是开集。因此得出结论。</p></li>
<li><h4 id="限制到子空间的连续性">限制到子空间的连续性</h4>
<p>定理：令 <span class="math inline">\(f:X\to Y\)</span>
是连续映射，取子空间 <span class="math inline">\(A\subseteq X\)</span>
采用子空间拓扑，则 <span class="math inline">\(f|_A:A\to Y\)</span>
仍然是连续映射。</p>
<p>证明：令 <span class="math inline">\(U\subset Y\)</span>
是一个开集，因此 <span class="math inline">\(f^{-1}(U)\)</span> 是 <span
class="math inline">\(X\)</span> 中开集，则 <span
class="math inline">\((f|_A)^{-1}(U)=A\cap f^{-1}(U)\)</span>，其为
<span class="math inline">\(A\)</span> 中开集。因此得出结论</p></li>
<li><h4 id="连续性的等价叙述">连续性的等价叙述</h4>
<p>定理：下面的叙述是等价的：</p>
<ol type="1">
<li><p><span class="math inline">\(f:X\to Y\)</span>
是连续映射；</p></li>
<li><p>若 <span class="math inline">\(\beta\)</span> 是 <span
class="math inline">\(Y\)</span>
的拓扑基，基础开集的原像还是开集；</p></li>
<li><p><span class="math inline">\(f(\bar A)\subset \overline{f(A)},
\forall A\subset X\)</span></p></li>
<li><p><span class="math inline">\(\overline{f^{-1}(B)}\subset
f^{-1}(\bar B),\forall B\subset Y\)</span>.</p></li>
<li><p><span class="math inline">\(f^{-1}(A)\)</span>
总是一个闭集，<span class="math inline">\(\forall\)</span> 闭集 <span
class="math inline">\(A\subset Y\)</span>.</p></li>
</ol>
<p>证明：</p>
<p><span class="math inline">\((1)\Rightarrow (2)\)</span>
显然成立；</p>
<p><span class="math inline">\((2)\Rightarrow(3)\)</span>：<span
class="math inline">\(f(A)\subset \overline{f(A)}\)</span> 是显然的。令
<span class="math inline">\(x\in \bar A\setminus A\)</span>。假设 <span
class="math inline">\(f(x)\not\in f(A)\)</span>，令 <span
class="math inline">\(U\)</span> 是一个 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(Y\)</span> 中邻域，可以找到一个基础开集 <span
class="math inline">\(B\)</span> 使得 <span
class="math inline">\(f(x)\in B\subset U\)</span>.</p>
<p>由于 <span class="math inline">\(f^{-1}(B)\)</span> 是开集且 <span
class="math inline">\(x\in f^{-1}(B),x\in \bar A\setminus A\)</span>，有
<span class="math inline">\(f^{-1}(B)\cap A\neq
\varnothing\)</span>，于是 <span class="math inline">\(f(A)\cap B\neq
\varnothing\)</span>，于是 <span class="math inline">\(f(A)\cap
U\neq\varnothing\)</span>。</p>
<p>介于 <span class="math inline">\(U\)</span> 的任意性，于是 <span
class="math inline">\(f(x)\)</span> 是 <span
class="math inline">\(f(A)\)</span> 的极限点，于是得出结论。</p>
<p><span class="math inline">\((3)\Rightarrow (4)\)</span>：<span
class="math inline">\(f(\overline{f^{-1}(B)})\subset
\overline{f(f^{-1}(B))}\subset \overline B\)</span>，因此 <span
class="math inline">\(\overline{f^{-1}(B)}\subset f^{-1}(\bar
B)\)</span>。</p>
<p><span class="math inline">\((4)\Rightarrow (5)\)</span>：令 <span
class="math inline">\(B\subset Y\)</span> 是闭集，则 <span
class="math inline">\(B=\bar B\)</span>，于是 <span
class="math inline">\(\overline{f^{-1}(B)}\subset f^{-1}(\bar
B)=f^{-1}(B)\)</span>，因此 <span
class="math inline">\(f^{-1}(B)=\overline{f^{-1}(B)}\)</span>，因此
<span class="math inline">\(f^{-1}(B)\)</span> 是闭集。</p>
<p><span
class="math inline">\((5)\Rightarrow(1)\)</span>：显然。</p></li>
</ul>
<h2 id="同胚距离与度量空间">03. 同胚、距离与度量空间</h2>
<h3 id="对连续映射的进一步研究">对连续映射的进一步研究</h3>
<ul>
<li><h4 id="同胚-homeomorphism-的定义">同胚 (Homeomorphism) 的定义</h4>
<p>称 <span class="math inline">\(f:X\to Y\)</span> 是同胚，如果 <span
class="math inline">\(f\)</span> 是连续，且存在逆映射：<span
class="math inline">\(g:Y\to X\)</span> 使得 <span
class="math inline">\(g\)</span> 也是连续映射，且 <span
class="math inline">\(f\circ g=id_Y,g\circ f=id_X\)</span>.</p>
<p>同胚就是拓扑范畴中的同构。</p>
<p>注：如果 <span class="math inline">\(f:X\to Y\)</span>
是一个连续映射，并且这个映射是一个双射，一般情况下 <span
class="math inline">\(f\)</span>
不是一个同胚。（拓扑范畴不能以以前的逻辑进行考虑）</p>
<p>例如：从半开半闭的线段映射到圆周，逆映射并不是一个连续映射。</p>
<figure>
<img src="/03-1.png" alt="image-20230926152609979" />
<figcaption aria-hidden="true">image-20230926152609979</figcaption>
</figure>
<p><span class="math inline">\([0,1)\to S&#39;=\{(x,y)\mid x^2+y^2=1\},
x\to (\cos 2\pi x,\sin 2\pi x)\)</span></p></li>
<li><h4
id="连续映射的局部性质-local-formulation-of-continuity">连续映射的局部性质
(Local formulation of continuity)</h4>
<ol type="1">
<li><p><span class="math inline">\(f:X\to Y\)</span>
是一个连续映射，如果 <span class="math inline">\(X\)</span>
可以被一些开集 <span class="math inline">\(U_\alpha\)</span> 覆盖，即
<span class="math inline">\(X=\bigcup_\alpha U_\alpha\)</span>，使得
<span class="math inline">\(f|_{U_\alpha}\)</span> 是连续的。</p></li>
<li><p><span class="math inline">\(f:X\to Y\)</span>
是一个连续映射，如果 <span class="math inline">\(X\)</span>
可以表示成一些闭集 <span class="math inline">\(F_i\)</span> 的并，即
<span class="math inline">\(X=\bigcup_{i=1}^n F_i\)</span>，且 <span
class="math inline">\(f|_{F_i}\)</span> 是连续的。</p></li>
</ol>
<p>证明：</p>
<ol type="1">
<li><p>任取 <span class="math inline">\(V\subset Y\)</span>
是开集，由定义，<span class="math inline">\(f^{-1}(V)=\bigcup_{\alpha}
f|_{U_\alpha}^{-1}(V)\)</span>，其中 <span
class="math inline">\(f|_{U_\alpha}^{-1}(V)\)</span> 是 <span
class="math inline">\(U_\alpha\)</span> 中开集. 由于 <span
class="math inline">\(U_\alpha\)</span> 是 <span
class="math inline">\(X\)</span> 中开集，有 <span
class="math inline">\(f|_{U_\alpha}^{-1}(V)\)</span> 也是 <span
class="math inline">\(X\)</span> 中开集，于是 <span
class="math inline">\(f^{-1}(V)\)</span> 是开集，因此 <span
class="math inline">\(f\)</span> 是连续函数。</p></li>
<li><p>任取 <span class="math inline">\(V\subset Y\)</span>
是闭集，有定义，<span class="math inline">\(f^{-1}(V)=\bigcup_{i=1}^n
f|_{F_i}^{-1}(V)\)</span>，其中 <span
class="math inline">\(f|_{F_i}^{-1}(V)\)</span> 是 <span
class="math inline">\(F_i\)</span> 中闭集. 由于 <span
class="math inline">\(F_i\)</span> 是 <span
class="math inline">\(X\)</span> 中闭集，有 <span
class="math inline">\(f|_{F_i}^{-1}(V)\)</span> 也是 <span
class="math inline">\(X\)</span> 中闭集，于是 <span
class="math inline">\(f^{-1}(V)\)</span> 是闭集，因此 <span
class="math inline">\(f\)</span> 是连续函数。</p></li>
</ol>
<p>例子：</p>
<p>考虑分段函数：<span
class="math inline">\(f(x)=\begin{cases}x-1&amp;x&lt;0\\x+1&amp;x\geq0\end{cases}\)</span>，这自然不是一个连续函数。</p>
<p>然而 <span class="math inline">\(f|_{[0,+\infty)},
f|_{(-\infty,0)}\)</span> 都是连续的，并且 <span
class="math inline">\(\mathbb
R=[0,+\infty)\cup(-\infty,0)\)</span>，因为该覆盖既并非全是开集，又并非全是闭集，故无法套用上述定理。（上述定理的“开”、“闭”是必要的）</p></li>
<li><h4 id="拓扑学中的极限-limit">拓扑学中的极限 (Limit)</h4>
<p>令 <span class="math inline">\(X\)</span> 是一个集合，令 <span
class="math inline">\(\beta\)</span> 是一个子集族，使得其满足：</p>
<ul>
<li><span class="math inline">\(\forall
B\in\beta,B\neq\varnothing\)</span></li>
<li><span class="math inline">\(\forall B_1,B_2\in\beta,\exists B_3\in
\beta,s.t. B_3\subset B_1\cap B_2\)</span></li>
</ul>
<p>则称 <span class="math inline">\(\beta\)</span> 是集合 <span
class="math inline">\(X\)</span> 的一组基 (basis)。</p>
<p><strong>定义</strong>：设映射 <span class="math inline">\(f:X\to
Y\)</span>，其中 <span class="math inline">\(X\)</span> 装备了一组基
<span class="math inline">\(\beta\)</span>，<span
class="math inline">\(Y\)</span> 是一个拓扑空间。考虑点 <span
class="math inline">\(p\in Y\)</span>，我们将 <span
class="math inline">\(p\)</span> 称作是 <span
class="math inline">\(f\)</span> 在基 <span
class="math inline">\(\beta\)</span> 下的极限，如果 <span
class="math inline">\(\forall\)</span> <span
class="math inline">\(p\)</span> 的邻域 <span
class="math inline">\(V\)</span>，<span class="math inline">\(\exists
A\in \beta\)</span>，使得 <span class="math inline">\(f(A)\subset
V\)</span>. 记作 <span class="math inline">\(\lim_{\beta}
f(x)=p\)</span>.</p>
<p>例子：</p>
<p>回忆：在数学分析中我们学过，<span class="math inline">\(\lim_{x\to a}
f(x)=p\in \mathbb R\)</span>，<span class="math inline">\(f:\mathbb
R\setminus\{a\}\to \mathbb R\)</span>.</p>
<p>我们令 <span class="math inline">\(X=\mathbb R\setminus
\{a\},Y=\mathbb R\)</span>. 令 <span
class="math inline">\(\beta=\{\mathring U(a)\setminus\set a\mid U(a)
\text{ 是 a 的邻域}\}\)</span>。</p>
<p>将 <span class="math inline">\(X\)</span> 看成集合，<span
class="math inline">\(Y\)</span> 是拓扑空间，<span
class="math inline">\(\beta\)</span> 是 <span
class="math inline">\(X\)</span> 上的一组基。</p>
<p>有 <span class="math inline">\(\lim_{x\to a}f(x)=p\Leftrightarrow
\lim_{\beta} f(x)=p\)</span></p>
<p>另一个例子（较为复杂的情形）：<strong>黎曼积分</strong> (Riemann
Integral)</p>
<p>令 <span class="math inline">\(I\subset \mathbb R\)</span>
是一段区间，令 <span class="math inline">\(I=\bigcup_{i=1}^n
I_i\)</span> 使得 <span class="math inline">\(I_i\)</span>
是区间且任意两个子区间 <span class="math inline">\(I_i,I_j\)</span>
内部没有公共内点，则我们称这组小区间 <span
class="math inline">\(\set{I_i}\)</span> 是大区间的<strong>分划</strong>
(Partition)。</p>
<p>有时我们把一个分划记作 <span class="math inline">\(P\)</span>.</p>
<figure>
<img src="\03-2.png" alt="image-20230926155837622" />
<figcaption aria-hidden="true">image-20230926155837622</figcaption>
</figure>
<p>给出一个分划，我们将分划中小区间的最大长度记作 <span
class="math inline">\(\lambda(P)\)</span>.</p>
<p>如果我们在每一个小区间里都固定一个点 <span
class="math inline">\(\xi_i\in
I_i\)</span>，则称我们有了一个<strong>带标志点的分划</strong>，记作
<span class="math inline">\((P,\xi)\)</span>。</p>
<p>令 <span class="math inline">\(\mathscr{P}\)</span>
为所有带标志点的分划组成的集合，考虑一组基 <span
class="math inline">\(\beta\)</span>：<span
class="math inline">\(\beta:=\set{B_d}_{d&gt;0}\)</span>，其中 <span
class="math inline">\(B_d:=\set{(P,\xi)\in\mathscr P\mid \lambda(P)\leq
d}\)</span>.</p>
<p>我们把 <span class="math inline">\(\beta\)</span> 记作 <span
class="math inline">\(\lambda(P)\to 0\)</span>.</p>
<p>进一步给出下面的定义：令 <span class="math inline">\(f\)</span> 是
<span class="math inline">\(I\to\mathbb R\)</span> 上的函数，<span
class="math inline">\((P,\xi)\)</span>
是一个带标志点的分划，则把下面的求和：<span
class="math inline">\(\sigma(f,P,\xi)=\sum_{i=1}^n
f(\xi_i)|I_i|\)</span> 称作 <span class="math inline">\(f\)</span> 在
<span class="math inline">\((P,\xi)\)</span> 上的<strong>黎曼和</strong>
(Riemann Sum)。</p>
<figure>
<img src="\03-3.png" alt="image-20230926161142528" />
<figcaption aria-hidden="true">image-20230926161142528</figcaption>
</figure>
<p>可以将 <span class="math inline">\(\sigma\)</span> 看成是一个 <span
class="math inline">\(\mathscr P\to \mathbb R\)</span> 的映射。</p>
<p>定义 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(I\)</span> 上的黎曼积分：<span
class="math inline">\(\lim_{\beta} \sigma(f,P,\xi)\)</span> 或者 <span
class="math inline">\(\lim_{\lambda(P)\to
0}\sigma(f,P,\xi)\)</span>.</p>
<p>如果该极限存在，则我们将其记作 <span class="math inline">\(\int_I
f(x)\text{d}x\)</span>.</p></li>
</ul>
<h3 id="对度量空间的研究">对度量空间的研究</h3>
<ul>
<li><h4 id="度量空间的扩张延拓-extension-problem">度量空间的扩张/延拓
(Extension Problem)</h4>
<p><span class="math inline">\(X\)</span> 是一个度量空间，<span
class="math inline">\(A\subset X\)</span>，考虑映射 <span
class="math inline">\(f:A\to \mathbb R\)</span>，使得 <span
class="math inline">\(f\)</span> 是一个连续映射。</p>
<p>扩张问题说的是，是否可以将 <span class="math inline">\(f\)</span>
连续地延拓到全空间 <span class="math inline">\(X\)</span> 上？</p>
<p>事实上，很多时候并不可以。例子：<span
class="math inline">\(X=[-\cfrac{\pi}{2},\cfrac{\pi}{2}],A=(-\cfrac{\pi}{2},\cfrac{\pi}{2})\)</span>，<span
class="math inline">\(f(x):\tan(x)\)</span>.</p>
<p>此时无法将 <span class="math inline">\(f\)</span> 连续地延拓至 <span
class="math inline">\(X\)</span> 上。</p></li>
<li><h4 id="点到集合距离的定义">点到集合距离的定义</h4>
<p>令 <span class="math inline">\(d\)</span> 是一个 <span
class="math inline">\(X\)</span> 上的度量，令 <span
class="math inline">\(A\subset X\)</span>，<span
class="math inline">\(\forall x\in X\)</span> 定义 <span
class="math inline">\(d(x,A):=\inf_{a\in A}d(x,a)\)</span>.</p>
<p><strong>引理</strong>：考虑函数 <span class="math inline">\(x\to
d(x,A)\)</span>，则该函数是一个连续函数。</p>
<p>证明：<span class="math inline">\(\forall
\varepsilon&gt;0\)</span>，考虑 <span
class="math inline">\((d(x,A)-\varepsilon,d(x,A)+\varepsilon)\)</span>，令
<span class="math inline">\(U=B(x,\cfrac{\varepsilon}{2})\)</span>，选取
<span class="math inline">\(a\in A\)</span> 使得 <span
class="math inline">\(d(x,a)&lt;d(x,A)+\cfrac{\varepsilon}{2}\)</span>.</p>
<p><span class="math inline">\(\forall y\in U\)</span>，有 <span
class="math inline">\(d(y,A)\leq d(y,a)\leq d(y,x) +
d(x,a)&lt;\cfrac{\varepsilon}{2}+\cfrac{\varepsilon}{2}+d(x,A)=d(x,A)+\varepsilon\)</span>.</p>
<p>反过来，还有 <span
class="math inline">\(d(x,a)&lt;d(y,a)+\varepsilon\)</span>，因而 <span
class="math inline">\(d(y,A)\in
(d(x,A)-\varepsilon,d(x,A)+\varepsilon)\)</span>.</p>
<p>因此 <span class="math inline">\(x\to d(x,A)\)</span>
是连续函数。</p>
<p><strong>引理</strong>：<span class="math inline">\(A,B\subset
X\)</span> 是闭集且 <span class="math inline">\(A\cap
B=\varnothing\)</span>，则 <span class="math inline">\(\exists f:X\to
\mathbb R\)</span> 是连续函数且 <span
class="math inline">\(f|_A=1,f|_B=-1\)</span>，<span
class="math inline">\(f|_{X\setminus (A\cup
B)}\subset(-1,1)\)</span>.</p>
<p>证明：对任意的 <span class="math inline">\(x\in X\)</span>，假设
<span class="math inline">\(d(x,A)=0\)</span> 且 <span
class="math inline">\(x\not \in A\)</span>，根据距离的定义，存在序列
<span class="math inline">\(\set{a_n}\subset A\)</span>，使得 <span
class="math inline">\(\lim_{n\to\infty} d(x,a_n)=0\)</span>，因此 <span
class="math inline">\(x\)</span> 是一个 <span
class="math inline">\(A\)</span> 的极限点. 由于 <span
class="math inline">\(A\)</span> 是闭的，一定有 <span
class="math inline">\(x\in A\)</span>，导出矛盾。</p>
<p>因此，如果 <span class="math inline">\(x\not\in A\)</span>，则 <span
class="math inline">\(d(x,A)&gt;0\)</span>. 类似地，如果 <span
class="math inline">\(x\not\in B\)</span>，则 <span
class="math inline">\(d(x,B)&gt;0\)</span>.</p>
<p>如果 <span
class="math inline">\(A\neq\varnothing,B\neq\varnothing\)</span>，令
<span
class="math inline">\(f(x)=\cfrac{d(x,B)-d(x,A)}{d(x,A)+d(x,B)}\)</span>，该函数分母一定
<span class="math inline">\(&gt;0\)</span>.</p>
<p>显然 <span class="math inline">\(f|_A=1,f|_B=-1\)</span>.</p>
<p>如果 <span class="math inline">\(x\in X\setminus (A\cup
B)\)</span>，则 <span
class="math inline">\(d(x,A)&gt;0,d(x,B)&gt;0\)</span>，有 <span
class="math inline">\(f(x)\in (-1,1)\)</span>.</p>
<p>且由前一个引理，<span class="math inline">\(f\)</span>
确实是连续函数。</p>
<p>如果 <span class="math inline">\(B=\varnothing\)</span>，则令 <span
class="math inline">\(f(x)=\cfrac{1}{d(x,A)+1}\)</span>；</p>
<p>如果 <span class="math inline">\(A=\varnothing\)</span>，则令 <span
class="math inline">\(f(x)=\cfrac{-1}{d(x,B)+1}\)</span>；</p>
<p>如果 <span class="math inline">\(A=B=\varnothing\)</span>，则令 <span
class="math inline">\(f(x)=0\)</span>.</p></li>
<li><h4 id="扩张定理-tietze-extension-theorem">扩张定理 (Tietze
extension theorem)</h4>
<p>令 <span class="math inline">\(X\)</span> 是度量空间，<span
class="math inline">\(C\subset X\)</span> 是闭集。若 <span
class="math inline">\(f:C\to \mathbb R\)</span> 连续，则 <span
class="math inline">\(f\)</span> 可以被连续地延拓到全空间 <span
class="math inline">\(X\)</span> 上。</p>
<p>证明：</p>
<p>Step 1. 假设 <span class="math inline">\(f:C\to \mathbb R\)</span>
是一个有界函数，也就是 <span class="math inline">\(\exists
M&gt;0\)</span>，使得 <span class="math inline">\(|f(x)|\leq M,\forall
x\in C\)</span>.</p>
<p>令 <span class="math inline">\(A_1:=f^{-1}([\cfrac{M}{3},+\infty)),
B_1:=f^{-1}((-\infty,-\cfrac{M}{3}])\)</span>，此时 <span
class="math inline">\(A_1,B_1\)</span> 是 <span
class="math inline">\(C\)</span> 中闭集。</p>
<p>由于 <span class="math inline">\(C\)</span> 是 <span
class="math inline">\(X\)</span> 中闭集，有 <span
class="math inline">\(A_1,B_1\)</span> 也是 <span
class="math inline">\(X\)</span> 中闭集。</p>
<p>由前一个引理，<span class="math inline">\(\exists g_1\)</span> 使得
<span class="math inline">\(g_1:X\to
[-\cfrac{M}{3},\cfrac{M}{3}]\)</span>，使得 <span
class="math inline">\(g_1|_{A_1}=\cfrac{M}{3},g_1|_{B_1}=-\cfrac{M}{3}\)</span></p>
<p><span class="math inline">\(g_1|_{X\setminus(A_1\cup
B_1)}\subset(-\cfrac{M}{3},\cfrac{M}{3})\)</span></p>
<p>于是 <span class="math inline">\(|f(x)-g_1(x)|\leq
\cfrac{2}{3}M\)</span> 于 <span class="math inline">\(C\)</span></p>
<p>类似地，考虑 <span
class="math inline">\(A_2=(f-g_1)^{-1}([\cfrac{2M}{9},+\infty))\)</span>，<span
class="math inline">\(B_2\)</span> 类似，</p>
<p>则 <span class="math inline">\(\exists g_2\)</span> 使得 <span
class="math inline">\(g_2|_{A_2}=\cfrac{2M}{9},g_2|_{B_2}=\cfrac{-2M}{9}\)</span></p>
<p>并且 <span class="math inline">\(g_2|_{X\setminus(A_2\cup
B_2)}\subset (-\cfrac{2M}{9},\cfrac{2M}{9})\)</span>，于是 <span
class="math inline">\(|f(x)-g_1(x)-g_2(x)|\leq
\cfrac{4M}{9}\)</span></p>
<p>继续执行这一过程，即可得到 <span
class="math inline">\(g_n:X\to[-\cfrac{2^{n-1}M}{3^{n}},\cfrac{2^{n-1}M}{3^{n}}]\)</span>，有
<span class="math inline">\(|f-\sum_{i=1}^n
g_i|\leq\cfrac{2^{n}}{3^n}M\)</span> 于 <span
class="math inline">\(C\)</span></p>
<p>因此 <span class="math inline">\(\sum_{n=1}^{\infty} g_n(x)\)</span>
在 <span class="math inline">\(X\)</span> 上一致收敛且连续，令 <span
class="math inline">\(g(x)=\sum_{n=1}^{\infty}
g_n(x)\)</span>，这就是一个 <span class="math inline">\(C\)</span> 至
<span class="math inline">\(X\)</span> 的延拓。</p>
<p>Step 2. 由于 <span class="math inline">\(|g(x)|\leq \sum_{i=1}^n
|g_i(x)|\leq \sum_{n=1}^{\infty} \cfrac{2^{n-1}}{3^n}M=M\)</span></p>
<p>有 <span class="math inline">\(|g(x)|&lt;M\)</span> 于 <span
class="math inline">\(X\setminus C\)</span>.</p>
<p>如果 <span class="math inline">\(f\)</span> 是无界的，则选取同胚
<span class="math inline">\(h:\mathbb R\to(-1,1)\)</span>. 考察 <span
class="math inline">\(h\circ f\)</span>，这是一个有界的函数，可以用 Step
1 延拓。</p>
<p>于是 <span class="math inline">\(\exists g\)</span> 使得 <span
class="math inline">\(g\)</span> 是 <span class="math inline">\(h\circ
f\)</span> 的延拓，且 <span class="math inline">\(|g(x)|&lt;M=1,\forall
x\in X\)</span>. 于是 <span class="math inline">\(h^{-1}\circ
g(x)\)</span> 是 <span class="math inline">\(f\)</span>
的一个延拓。</p></li>
</ul>
<h2 id="度量空间的完备化">04. 度量空间的完备化</h2>
<h3 id="度量空间的完备化-1">度量空间的完备化</h3>
<ul>
<li><h4 id="完备的度量空间-complete-metric-space">完备的度量空间
(Complete metric space)</h4>
<ul>
<li><h5 id="柯西序列-cauchy-sequence">柯西序列 (Cauchy Sequence)</h5>
<p>令 <span class="math inline">\((X,d)\)</span>
是一个度量空间，定义序列 <span class="math inline">\(\set{x_n\mid n\geq
1}\)</span> 被称为<strong>柯西序列 (Cauchy sequence)</strong>，如果
<span class="math inline">\(\forall \varepsilon&gt;0\)</span>，<span
class="math inline">\(\exists N\in \mathbb N\)</span>，使得 <span
class="math inline">\(d(x_m,x_n)&lt;\varepsilon,\forall
n,m&gt;N\)</span>.</p></li>
<li><h5 id="点列的极限">点列的极限</h5>
<p>对点列 <span class="math inline">\(\set{x_n}\in
X\)</span>，称其<strong>收敛</strong>于 <span
class="math inline">\(a\)</span>，如果 <span
class="math inline">\(\lim_{n\to\infty}d(x_n,a)=0\)</span>，把点 <span
class="math inline">\(a\)</span> 称作点列 <span
class="math inline">\(\set{x_n}\)</span>
的<strong>极限</strong>。</p></li>
<li><h5 id="完备度量空间的概念">完备度量空间的概念</h5>
<p>一个度量空间 <span
class="math inline">\((X,d)\)</span>，称其是完备的如果 <span
class="math inline">\(\forall\)</span> 柯西序列 <span
class="math inline">\(\set{x_n}\)</span> 都有极限。</p></li>
<li><h5 id="例子-1">例子</h5>
<p><span class="math inline">\(\mathbb R\)</span>
赋予欧氏度量后是完备的度量空间。</p>
<p><span class="math inline">\(\mathbb Q\subseteq \mathbb R\)</span>
不是完备的。</p>
<p><span class="math inline">\(\mathbb R\setminus\set{0}\)</span>
不是完备的。（考察 <span
class="math inline">\(\set{\cfrac{1}{n}}\)</span>）</p>
<p>令 <span class="math inline">\(C[a,b]\)</span> 表示所有 <span
class="math inline">\([a,b]\)</span> 区间上连续函数构成的集合，其中
<span class="math inline">\([a,b]\subset \mathbb
R\)</span>，我们定义度量 <span class="math inline">\(d(f,g)=\max_{a\leq
x\leq b} |f(x)-g(x)|\)</span>，则这是一个完备度量空间。</p>
<p>证明：设 <span class="math inline">\(\set{f_n}\)</span>
是一个柯西序列，使得 <span class="math inline">\(\forall
\varepsilon&gt;0\)</span>，<span class="math inline">\(\exists N\in
\mathbb N\)</span>，有 <span class="math inline">\(\forall
m,n&gt;N\)</span>，有 <span
class="math inline">\(|f_n(x)-f_m(x)|&lt;\varepsilon\)</span>.</p>
<p>固定 <span class="math inline">\(\forall x\in [a,b]\)</span>，则
<span class="math inline">\(\set{f_n(x)}\)</span> 是一个 <span
class="math inline">\(\mathbb R\)</span> 中的柯西序列，于是 <span
class="math inline">\(\exists\)</span> 极限 <span
class="math inline">\(f(x)\in\mathbb R\)</span>.</p>
<p><span
class="math inline">\(f(x):=\lim_{n\to\infty}f_n(x)\)</span>，<span
class="math inline">\(x\in [a,b]\)</span>.</p>
<p>目标：证明 <span class="math inline">\(f\in C[a,b]\)</span>. 我们考察
<span class="math inline">\(f(x+h)-f(x)\)</span>，</p>
<p><span
class="math inline">\(f(x+h)-f(x)=f(x+h)-f_n(x+h)+f_n(x+h)-f_n(x+h)-f_n(x)+f_n(x)-f(x)\)</span>.</p>
<p><span class="math inline">\(\forall \varepsilon&gt;0\)</span>，<span
class="math inline">\(\exists N\)</span>，使得 <span
class="math inline">\(n&gt;N\)</span>，有 <span
class="math inline">\(|f(x)-f_n(x)|&lt;\varepsilon\)</span>，类似地，我们选取合适的
<span class="math inline">\(h\)</span>，可以使得另外两项也 <span
class="math inline">\(&lt;\varepsilon\)</span>，因而得到 <span
class="math inline">\(|f(x+h)-f(x)|&lt;3\varepsilon\)</span>，连续。</p>
<p>仍然考虑连续函数空间，定义度量 <span
class="math inline">\(d(f,g)=\int_{a}^b
|f-g|(x)\text{d}x\)</span>，这将不是一个完备的度量空间。</p>
<p>构造 Cauchy 列：<span
class="math inline">\(f_n(x)=\begin{cases}-1&amp;a\leq x\leq
\cfrac{a+b}{2}-\cfrac{1}{n}\\n(x-\cfrac{a+b}{2})&amp;\cfrac{a+b}{2}-\cfrac{1}{n}\leq
x\leq \cfrac{a+b}{2}+\cfrac{1}{n}\\1&amp;\cfrac{a+b}{2}+\cfrac{1}{n}\leq
x\leq b\end{cases}\)</span></p>
<figure>
<img src="\04-1.png" alt="image-20230928102226353" />
<figcaption aria-hidden="true">image-20230928102226353</figcaption>
</figure>
<p>图：函数图像示例。</p>
<p>可以发现该 Cauchy 列的极限为 <span
class="math inline">\(f(x)=\begin{cases}-1&amp;a\leq
x&lt;\cfrac{a+b}{2}\\0&amp;x=\cfrac{a+b}{2}\\1&amp;\cfrac{a+b}{2}&lt;x\leq
b\end{cases}\)</span></p>
<p>这不可能是一个连续函数（即使由于度量定义导致 <span
class="math inline">\(x=\cfrac{a+b}{2}\)</span> 时取值可变）。</p></li>
</ul></li>
<li><h4
id="度量空间的完备化-completion-of-a-metric-space">度量空间的完备化
(Completion of a metric space)</h4>
<p>令 <span class="math inline">\((X,d)\)</span>
是一个度量空间，我们想要找到一个最小的完备空间，称之为 <span
class="math inline">\((Y,d)\)</span>，使得 <span
class="math inline">\(X\subset Y\)</span>.</p>
<p>例如，<span class="math inline">\(\mathbb Q\)</span>
不是一个完备的度量空间，我们将 <span class="math inline">\(\mathbb
R\)</span> 称作其的完备化。</p>
<p><strong>定义</strong>：如果 <span
class="math inline">\((X,d)\)</span> 是 <span
class="math inline">\((Y,d)\)</span> 的子空间，<span
class="math inline">\((Y,d)\)</span> 是完备的并且满足 <span
class="math inline">\(X\)</span> 在 <span
class="math inline">\(Y\)</span> 中是稠密的（<span
class="math inline">\(\bar X=Y\)</span>），则把 <span
class="math inline">\((Y,d)\)</span> 称作 <span
class="math inline">\((X,d)\)</span>
的<strong>完备化</strong>。更进一步地，这种完备化在下面的意义下是唯一的。</p></li>
<li><h4 id="度量空间间的-isometry">度量空间间的 Isometry</h4>
<p>称两个度量空间 <span class="math inline">\((X_1,d_1)\)</span>, <span
class="math inline">\((X_2,d_2)\)</span> 是 <strong>Isometric</strong>
的，当 <span class="math inline">\(\exists\)</span> 双射 <span
class="math inline">\(f:X_1\to X_2\)</span>，使得双射保持度量结构，即
<span class="math inline">\(d_2(f(a),f(b))=d_1(a,b),\forall a,b\in
X_1\)</span>. 将映射 <span class="math inline">\(f\)</span> 称作一个
isometry.</p>
<p>回忆：Isometry 与此前的同胚有什么不同？ <span
class="math inline">\(f\)</span> 是一个 isometry<span
class="math inline">\(\Rightarrow\)</span> <span
class="math inline">\(\exists g:X_2\to X_1\)</span>，使得 <span
class="math inline">\(d_1(g(a),g(b))=d_2(a,b),\forall a,b\in
X_2\)</span>，其中 <span class="math inline">\(f\circ g=id_{X_2},g\circ
f=id_{X_1}\)</span>.</p></li>
<li><h4
id="度量空间完备化的唯一性-uniqueness-of-completion">度量空间完备化的唯一性
(Uniqueness of Completion)</h4>
<p><strong>引理</strong>：令 <span class="math inline">\((X,d)\)</span>
是一个度量空间且 <span class="math inline">\(a,b,u,v\in X\)</span>，则
<span class="math inline">\(|d(a,b)-d(u,v)|\leq
d(a,u)+d(b,v)\)</span>。</p>
<p>证明：<span class="math inline">\(d(a,b)\leq d(a,u)+d(u,b)\leq
d(a,u)+d(u,v)+d(v,b)\)</span></p>
<p>于是 <span class="math inline">\(d(a,b)-d(u,v)\leq
d(a,u)+d(u,v)\)</span></p>
<p>类似地，<span class="math inline">\(d(u,v)\leq
d(u,a)+d(a,b)+d(b,v)\)</span></p>
<p>于是 <span class="math inline">\(d(u,v)-d(a,b)\leq
d(u,a)+d(b,v)\)</span></p>
<p>得出结论。</p>
<p><strong>定理</strong>：如果 <span
class="math inline">\((Y_1,d_1)\)</span> 以及 <span
class="math inline">\((Y_2,d_2)\)</span> 都是 <span
class="math inline">\((X,d)\)</span> 的完备化，则 <span
class="math inline">\((Y_1,d_1)\)</span> 与 <span
class="math inline">\((Y_2,d_2)\)</span> 是 Isometric 的。</p>
<p>证明：<span class="math inline">\(\forall x\in X\)</span>，令 <span
class="math inline">\(f(x)=x\)</span>；<span
class="math inline">\(\forall x_1,x_2\in X\)</span>，有 <span
class="math inline">\(d_2(f(x_1),f(x_2))=d(f(x_1),f(x_2))=d(x_1,x_2)=d_1(x_1,x_2)\)</span>.</p>
<p>我们考虑把 <span class="math inline">\(f\)</span> 延拓到 <span
class="math inline">\(Y_1\)</span>.</p>
<p>令 <span class="math inline">\(y_1\in Y_1\setminus X\)</span>，<span
class="math inline">\(y_1\)</span> 是 <span
class="math inline">\(X\)</span> 的一个极限点，因此存在序列 <span
class="math inline">\(\set{x_n}\subset X\)</span>，使得 <span
class="math inline">\(x_n\to y_1\)</span>（<span
class="math inline">\(\lim_{n\to\infty} d_1(x_n,y_1)=0\)</span>），同时
<span class="math inline">\(\set{x_n}\)</span>
是一个柯西序列。另一方面，由于 <span
class="math inline">\((Y_2,d_2)\)</span> 是一个完备的空间，则 <span
class="math inline">\(\set{x_n}\)</span> 在 <span
class="math inline">\(Y_2\)</span> 中也有极限 <span
class="math inline">\(y_2\in Y_2\)</span>.</p>
<p>我们定义 <span class="math inline">\(f(y_1)=y_2\)</span>.</p>
<p><span class="math inline">\(f\)</span> 自然是满射，这是因为 <span
class="math inline">\(\forall y_2\in Y_2\)</span>，有 <span
class="math inline">\(y_2\)</span> 总是 <span
class="math inline">\(X\)</span> 的极限点，自然可以对应一个序列 <span
class="math inline">\(\set{x_n}\to y_2\)</span> 进而对应一个 <span
class="math inline">\(Y_1\)</span> 中点 <span
class="math inline">\(y_1\)</span>，即有 <span
class="math inline">\(f(y_1)=y_2\)</span></p>
<p>接下来我们证明 <span class="math inline">\(f\)</span> 是保度量的，即
<span
class="math inline">\(d_2(f(y_1&#39;),f(y_1&#39;&#39;))=d_1(y_1&#39;,y_1&#39;&#39;),\forall
y_1&#39;,y_1&#39;&#39;\in Y_1\)</span>.</p>
<p>如果 <span class="math inline">\(y_1&#39;,y_1&#39;&#39;\in
X\)</span>，等式是平凡的；</p>
<p>否则，我们能找到 <span
class="math inline">\(\set{x_n&#39;},\set{x_n&#39;&#39;}\)</span>，使得
<span class="math inline">\(x_n&#39;\to y_1&#39;,x_n&#39;&#39;\to
y_1&#39;&#39;\)</span>.</p>
<p>由刚才的引理，有 <span
class="math inline">\(d_1(y_1&#39;,y_1&#39;&#39;)=\lim_{n\to\infty}
d_1(x_n&#39;,x_n&#39;&#39;)\)</span>. 我们记这个式为式 (1)；</p>
<p>同理，令 <span
class="math inline">\(y_2&#39;=f(y_1&#39;),y_2&#39;&#39;=f(y_1&#39;&#39;)\)</span>，由
<span class="math inline">\(f\)</span> 的定义有 <span
class="math inline">\(x_n&#39;\to y_2&#39;,x_n&#39;&#39;\to
y_2&#39;&#39;\)</span> 于 <span
class="math inline">\((Y_2,d_2)\)</span></p>
<p>于是 <span
class="math inline">\(d_2(y_2&#39;,y_2&#39;&#39;)=\lim_{n\to\infty}d_2(x_n&#39;,x_n&#39;&#39;)\)</span></p>
<p>因此 <span
class="math inline">\(d_2(y_2&#39;,y_2&#39;&#39;)=d_1(y_1&#39;,y_1&#39;&#39;)\)</span>，因此映射
<span class="math inline">\(f\)</span> 保度量。</p>
<p>由于若 <span class="math inline">\(y_1&#39;\neq
y_1&#39;&#39;\)</span>，<span
class="math inline">\(d_2(f(y_1&#39;),f(y_1&#39;&#39;))=d_1(y_1&#39;,y_1&#39;&#39;)&gt;0\)</span>，因此
<span class="math inline">\(f\)</span> 是单射，因此 <span
class="math inline">\(f\)</span> 双射且保度量，因此 <span
class="math inline">\((Y_1,d_1),(Y_2,d_2)\)</span> 是 Isometric
的。</p></li>
<li><h4
id="度量空间完备化的存在性-existence-of-completion">度量空间完备化的存在性
(Existence of Completion)</h4>
<p><strong>定理</strong>：如果我们将两个 Isometric
的空间等同起来（看成是同一个空间），则所有的度量空间都有完备化。</p>
<p><strong>证明</strong>：令 <span
class="math inline">\((X,d_X)\)</span> 是一个度量空间，考虑 <span
class="math inline">\(\set{x_n&#39;},\set{x_n&#39;&#39;}\)</span>
是两个柯西序列。称这两个柯西序列是等价的如果 <span
class="math inline">\(\lim_{n\to\infty}d_X(x_n&#39;,x_n&#39;&#39;)=0\)</span>。可以验证，这样的定义定义了一个等价关系。</p>
<p>令 <span class="math inline">\(S\)</span> 是所有 <span
class="math inline">\(X\)</span> 中柯西序列的等价类构成的集合，定义度量
<span class="math inline">\(d\)</span>：</p>
<p>考虑 <span class="math inline">\(s&#39;,s&#39;&#39;\in
S\)</span>，分别取代表元 <span
class="math inline">\(\set{x_n&#39;},\set{x_n&#39;&#39;}\)</span>，定义
<span class="math inline">\(d(s&#39;,s&#39;&#39;)=\lim_{n\to\infty}
d_X(x_n&#39;,x_n&#39;&#39;)\)</span>.
由之前的引理，该极限存在因为其是一个实数集中的柯西序列，并且该极限确实不依赖于代表元的选取。</p>
<p>于是 <span class="math inline">\((S,d)\)</span>
确实是一个度量空间。我们希望将 <span
class="math inline">\((X,d_X)\)</span> 嵌入到 <span
class="math inline">\((S,d)\)</span> 中.</p>
<p>考虑嵌入映射：考虑嵌入 <span
class="math inline">\(i:x\to\set{x_n=x}\)</span> 常数序列，则 <span
class="math inline">\((X,d_X)\)</span> 与其像 <span
class="math inline">\((i(X),d|_{i(X)})\)</span> 是 isometric 的。</p>
<p>我们证明 <span class="math inline">\((S,d)\)</span> 是 <span
class="math inline">\((i(X),d|_{i(X)})\)</span> 的完备化：</p>
<p>令 <span class="math inline">\(s\in S,\set{x_n}\)</span> 是 <span
class="math inline">\(s\)</span> 的代表元，则 <span
class="math inline">\(\set{i(x_n)}\)</span> 是一个 <span
class="math inline">\(i(X)\)</span> 中序列。我们有 <span
class="math inline">\(d(i(x_n),s)=\lim_{m\to\infty}
d_X(x_n,x_m)\)</span></p>
<p>因此 <span class="math inline">\(\lim_{n\to\infty}
d(i(x_n),s)=\lim_{n\to\infty}\lim_{m\to\infty}
d_X(x_n,x_m)=0\)</span></p>
<p>于是若 <span class="math inline">\(s\not\in i(X)\)</span>，则 <span
class="math inline">\(s\)</span> 是 <span
class="math inline">\(i(X)\)</span> 的极限点。因此 <span
class="math inline">\(\overline{(i(X))}=S\)</span></p>
<p>最后，我们只需证明 <span class="math inline">\(S\)</span>
是完备的。</p>
<p>根据定义，找柯西列 <span
class="math inline">\(\set{s_n}\)</span>，由于 <span
class="math inline">\(\overline{i(X)}=S\)</span>，我们总可以找到一些
<span class="math inline">\(\xi_n\in i(X),\forall n\)</span>，使得 <span
class="math inline">\(d(\xi_n,s_n)&lt;\cfrac{1}{n}\)</span>. 于是 <span
class="math inline">\(\set{\xi_n}\)</span> 是一个柯西列，因为 <span
class="math inline">\(d(\xi_n,\xi_m)\leq
d(\xi_n,s_m)+d(s_n,s_m)+d(s_m,\xi_m)\)</span>.</p>
<p>令 <span class="math inline">\(\xi_n=i(x_n)\)</span>，有 <span
class="math inline">\(\set{x_n}\)</span> 是柯西序列，则 <span
class="math inline">\(\set{x_n}\)</span> 所在的等价类为 <span
class="math inline">\(s\in S\)</span>.</p>
<p>我们考虑证明 <span class="math inline">\(s_n\to s\)</span>.</p>
<p>有 <span
class="math inline">\(d(s,s_n)=\lim_{m\to\infty}(\xi_m,s_n)&lt;\lim_{m\to\infty}(d(\xi_m,\xi_n)+\cfrac{1}{n})\)</span></p>
<p>于是 <span class="math inline">\(\lim_{n\to\infty}
d(s,s_n)=0\)</span>，于是 <span class="math inline">\((S,d)\)</span>
完备。</p></li>
</ul>
<h2 id="紧空间与hausdorff空间">05. 紧空间与Hausdorff空间</h2>
<h3 id="紧空间-compactness">紧空间 (Compactness)</h3>
<ul>
<li><h4 id="数学分析时的紧空间">数学分析时的紧空间</h4>
<ul>
<li><h5
id="闭区间的有限覆盖定理-heine-borel-theorem">闭区间的有限覆盖定理
(Heine-Borel Theorem)</h5>
考察闭区间 <span class="math inline">\(I=[a,b]\subseteq \mathbb
R\)</span>，考虑开覆盖 <span class="math inline">\(I\subset
\bigcup_\alpha U_\alpha\)</span>，其中 <span
class="math inline">\(U_\alpha\)</span> 是 <span
class="math inline">\(\mathbb R\)</span> 中开集。则其中存在有限多个开集
<span class="math inline">\(U_1,U_2,\cdots,U_n\in
\set{U_\alpha}\)</span>，使得 <span class="math inline">\(I\subset
\bigcup_{i=1}^n U_i\)</span>.</li>
</ul></li>
<li><h4 id="紧空间-compact-space">紧空间 (Compact Space)</h4>
<p>令 <span class="math inline">\(X\)</span> 是一个一般拓扑空间，把
<span class="math inline">\(X\)</span> 称作一个<strong>紧空间
(Compact)</strong>，如果任意一个开覆盖 <span
class="math inline">\(X=\bigcup_{\alpha}U_\alpha\)</span>，<span
class="math inline">\(U_\alpha\subset X\)</span> 为开，则 <span
class="math inline">\(\exists U_1,\cdots,U_n\in
\set{U_\alpha}\)</span>，使得 <span
class="math inline">\(X=\bigcup_{i=1}^n U_i\)</span>.</p></li>
<li><h4 id="紧集-compact-set">紧集 (Compact Set)</h4>
<p><span class="math inline">\(A\subset X\)</span> 是一个子集，把 <span
class="math inline">\(A\)</span> 称作是一个<strong>紧子集 (Compact
Set)</strong>，如果 <span class="math inline">\(A\)</span>
装备上子空间拓扑后是紧空间。</p>
<p>运用如上的概念，可以知道先前的有限覆盖定理说的就是：<span
class="math inline">\(\mathbb R\)</span> 中的闭区间是紧子集。</p>
<p>最终，我们希望证明下面的主定理：</p></li>
<li><h4 id="欧氏空间中的紧集主定理">欧氏空间中的紧集（主定理）</h4>
<p><span class="math inline">\(X\subset \mathbb R^n\)</span>
是一个紧集，当且仅当 <span class="math inline">\(X\)</span>
是一个有界闭集。</p></li>
<li><h4 id="紧集的简单性质">紧集的简单性质</h4>
<ul>
<li><h5 id="连续映射保持紧性">连续映射保持紧性</h5>
<p>考虑连续映射 <span class="math inline">\(f:X\to Y\)</span>，如果
<span class="math inline">\(X\)</span> 是紧空间，则 <span
class="math inline">\(f(X)\)</span> 是 <span
class="math inline">\(Y\)</span> 中的紧子集。</p>
<p>证明：</p>
<p>令 <span class="math inline">\(f(X)\subseteq \bigcup_\alpha
V_\alpha\)</span>，其中 <span class="math inline">\(V_\alpha\)</span> 是
<span class="math inline">\(Y\)</span> 中开集 <span
class="math inline">\(\forall \alpha\)</span>. 根据 <span
class="math inline">\(f\)</span> 是连续的，有 <span
class="math inline">\(f^{-1}(V_\alpha)\)</span> 是开集。</p>
<p>因为 <span class="math inline">\(X\)</span> 是紧空间，且 <span
class="math inline">\(X=\bigcup_\alpha f^{-1}(V_\alpha)\)</span>，因此
<span class="math inline">\(\exists
V_1,\cdots,V_n\in\set{V_\alpha}\)</span>，使得 <span
class="math inline">\(X=\bigcup_{i=1}^n f^{-1}(V_i)\)</span>，进而 <span
class="math inline">\(f(X)\subseteq \bigcup_{i=1}^n V_i\)</span>.</p>
<p>由于一开始取的覆盖是任意的，我们得到 <span
class="math inline">\(f(X)\)</span> 是一个紧集。</p></li>
<li><h5 id="闭子集保持紧性">闭子集保持紧性</h5>
<p><span class="math inline">\(C\subseteq X\)</span> 是一个闭集。则若
<span class="math inline">\(X\)</span> 是一个紧空间，<span
class="math inline">\(C\)</span> 是一个紧子集。</p>
<p>证明：</p>
<p>令 <span class="math inline">\(C\subseteq \bigcup_{\alpha}
U_\alpha\)</span>，其中 <span class="math inline">\(U_\alpha\)</span> 是
<span class="math inline">\(X\)</span> 中开集 <span
class="math inline">\(\forall \alpha\)</span>. 由于 <span
class="math inline">\(C\)</span> 是闭集，则 <span
class="math inline">\(X\setminus C\)</span> 是开集。</p>
<p>于是 <span class="math inline">\(X=\bigcup_{\alpha}U_\alpha \cup
(X\setminus C)\)</span>，这是一个开覆盖，由于 <span
class="math inline">\(X\)</span> 是紧的，因此 <span
class="math inline">\(\exists
U_1,\cdots,U_n\in\set{U_\alpha}\)</span>，使得 <span
class="math inline">\(X=\bigcup_{i=1}^n U_i\cup (X\setminus
C)\)</span>.</p>
<p>进而 <span class="math inline">\(C\subseteq \bigcup_{i=1}^n
U_i\)</span>，于是由取覆盖的任意性，有 <span
class="math inline">\(C\)</span> 是一个紧集。</p></li>
</ul></li>
<li><h4 id="hausdorff-空间">Hausdorff 空间</h4>
<p>称拓扑空间 <span class="math inline">\(X\)</span> 是
<strong>Hausdorff 空间</strong>，如果对于 <span
class="math inline">\(\forall x_1,x_2\in X,x_1\neq x_2\)</span>，<span
class="math inline">\(\exists\)</span> 邻域 <span
class="math inline">\(U_1,U_2\)</span>，有 <span
class="math inline">\(x_1\in U_1,x_2\in U_2\)</span>，使得 <span
class="math inline">\(U_1\cap U_2=\varnothing\)</span>.</p>
<ul>
<li><h5 id="例子-2">例子</h5>
<p>若 <span class="math inline">\((X,d)\)</span>
是一个度量空间，则它是一个 Hausdorff 空间。</p>
<p><span class="math inline">\(\forall x_1\neq x_2\in X\)</span>，有
<span class="math inline">\(d(x_1,x_2)=a&gt;0\)</span>. 于是 <span
class="math inline">\(B(x_1,\cfrac{a}{4})\cap
B(x_2,\cfrac{a}{4})=\varnothing\)</span> 且它们分别是 <span
class="math inline">\(x_1,x_2\)</span> 的邻域，于是 <span
class="math inline">\((X,d)\)</span> 是 Hausdorff 空间。</p>
<p>考虑 <span class="math inline">\(\mathbb C\)</span> 上的 Zariski
Topology （有限补拓扑），则 <span class="math inline">\(\mathbb
C\)</span> 不是一个 Hausdorff 空间。</p>
<p>根据定义，<span class="math inline">\(\forall x_1\neq x_2\in\mathbb
C\)</span>，令 <span class="math inline">\(U_1,U_2\)</span> 是 <span
class="math inline">\(x_1,x_2\)</span> 的两个邻域，则 <span
class="math inline">\(\mathbb C\setminus U_1\)</span> 与 <span
class="math inline">\(\mathbb C\setminus U_2\)</span>
都是有限集，它们不可能无交，<span class="math inline">\(U_1\cap
U_2\neq\varnothing\)</span>。于是 <span class="math inline">\(\mathbb
C\)</span> 上的 Zariski Topology 不是一个 Hausdorff 空间。</p></li>
<li><h5 id="hausdorff-空间的极限存在则唯一">Hausdorff
空间的极限存在则唯一</h5>
<p>如果 <span class="math inline">\(f:X\to Y\)</span> 是一个从集合 <span
class="math inline">\(X\)</span> 到 Hausdorff 空间 <span
class="math inline">\(Y\)</span> 的映射。令 <span
class="math inline">\(\beta\)</span> 是 <span
class="math inline">\(X\)</span> 的一组基，如果 <span
class="math inline">\(\lim_\beta f(x)\)</span> 存在，则极限唯一。</p>
<p>证明：</p>
<p>假设 <span class="math inline">\(\exists y_1\neq y_2\in
Y\)</span>，使得 <span class="math inline">\(y_1,y_2\)</span> 都是 <span
class="math inline">\(f\)</span> 关于基 <span
class="math inline">\(\beta\)</span> 的极限。</p>
<p>于是 <span class="math inline">\(\exists V_1\)</span> 与 <span
class="math inline">\(V_2\)</span> 是 <span
class="math inline">\(y_1\)</span> 与 <span
class="math inline">\(y_2\)</span> 的邻域，使得 <span
class="math inline">\(V_1\cap V_2=\varnothing\)</span>.</p>
<p>根据极限的概念，<span class="math inline">\(\exists B_1,B_2\in
\beta\)</span>，使得 <span class="math inline">\(f(B_1)\subset
V_1,f(B_2)\subset V_2\)</span>，进而 <span class="math inline">\(\exists
B_3\subset B_1\cap B_2, B_3\in \beta\)</span>，使得 <span
class="math inline">\(f(B_3)\subset V_1,f(B_3)\subset V_2\)</span> 且
<span
class="math inline">\(B_3\neq\varnothing\)</span>（由于基的性质），这样的
<span class="math inline">\(B_3\)</span> 不存在，矛盾！</p>
<p>于是极限一定唯一。</p></li>
<li><h5 id="度量空间点列极限的叙述">度量空间点列极限的叙述</h5>
<p>令 <span class="math inline">\(X=\set{1,2,3,\cdots}\)</span>，<span
class="math inline">\(Y\)</span> 是一个 Hausdorff 空间。令 <span
class="math inline">\(\beta=\set{\set{n,n+1,n+2,\cdots}\mid n \geq
1}\)</span>，则 <span class="math inline">\(\beta\)</span> 是 <span
class="math inline">\(X\)</span> 的一组基，记作 <span
class="math inline">\(n\to\infty\)</span>.</p>
<p>令 <span class="math inline">\(f:X\to Y\)</span> 是一个映射，将 <span
class="math inline">\(f(n)\)</span> 记作 <span
class="math inline">\(X_n\)</span>，则 <span
class="math inline">\(\lim_{n\to\infty} X_n:=\lim_{\beta}f(n)\)</span>.
若该极限存在，则该极限唯一。</p></li>
<li><h5 id="hausdorff-空间与紧集">Hausdorff 空间与紧集</h5>
<p>Haudorff 空间中的紧子集为闭集。</p>
<p>证明：令 <span class="math inline">\(X\)</span> 是一个 Hausdorff
空间，令 <span class="math inline">\(A\subseteq X\)</span>
是一个紧子集.</p>
<p>令 <span class="math inline">\(x\in X\setminus A\)</span>，对 <span
class="math inline">\(\forall z\in A\)</span>，<span
class="math inline">\(\exists\)</span> 邻域 <span
class="math inline">\(x\in U_z\)</span> 与 <span
class="math inline">\(z\in V_z\)</span>，使得两个邻域不相交。</p>
<p>于是 <span class="math inline">\(A\subseteq \bigcup_{z\in A}
V_z\)</span>. 由于 <span class="math inline">\(A\)</span>
是一个紧集，<span class="math inline">\(\exists z_1,\cdots,z_n\in
A\)</span>，使得 <span class="math inline">\(A\subseteq \bigcup_{i=1}^n
V_{z_i}\)</span>.</p>
<p>令 <span class="math inline">\(U_x=\bigcap_{i=1}^n
U_{z_i}\)</span>，有 <span class="math inline">\(U_x\cap
A=\varnothing\)</span>，并且 <span class="math inline">\(U_x\)</span> 是
<span class="math inline">\(x\)</span> 的一个邻域。</p>
<p>于是 <span class="math inline">\(X\setminus A=\bigcup_{x\in
X\setminus A} U_x\)</span> 是一个开集，于是 <span
class="math inline">\(A\)</span> 是一个闭集。</p></li>
</ul></li>
<li><h4 id="连续双射与同胚">连续双射与同胚</h4>
<p>回忆：若 <span class="math inline">\(f:X\to Y\)</span> 连续双射，然而
<span class="math inline">\(f\)</span>
不一定是一个同胚映射（线段打到圆）。</p>
<p>定理：考虑 <span class="math inline">\(f:X\to Y\)</span>
连续双射，若假设 <span class="math inline">\(X\)</span> 是紧空间，并且
<span class="math inline">\(Y\)</span> 是一个 Hausdorff 空间，则 <span
class="math inline">\(f\)</span> 一定是同胚。</p>
<p>证明：任取 <span class="math inline">\(A\subseteq X\)</span>
是闭集，<span class="math inline">\(X\)</span> 是紧的，有 <span
class="math inline">\(A\)</span> 也是紧的，于是 <span
class="math inline">\(f(A)\)</span> 在 <span
class="math inline">\(Y\)</span> 中是紧的，于是 <span
class="math inline">\(f(A)\)</span> 在 <span
class="math inline">\(Y\)</span> 中是闭集（<span
class="math inline">\(Y\)</span> 是 Hausdorff），于是 <span
class="math inline">\(f^{-1}\)</span> 是连续映射，于是 <span
class="math inline">\(f\)</span> 是同胚。</p></li>
<li><h4 id="紧空间中无限集必有极限点">紧空间中无限集必有极限点</h4>
<p>考虑紧空间中的无限集，这个无限集一定有一个极限点。（回忆：有界数列必有收敛子列）</p>
<p>证明：</p>
<p>令 <span class="math inline">\(X\)</span> 是紧空间，令 <span
class="math inline">\(S\subseteq X\)</span>
是一个没有极限点的子集。我们接下来证明 <span
class="math inline">\(S\)</span> 是一个有限集，即 <span
class="math inline">\(|S|&lt;\infty\)</span>。</p>
<p><span class="math inline">\(\forall x\in X\)</span>，<span
class="math inline">\(\exists\)</span> 邻域 <span
class="math inline">\(x\in U_x\)</span>，使得 <span
class="math inline">\(U_x\cap S=\begin{cases}\varnothing&amp;x\not\in
S\\\set{x}&amp;x\in S\end{cases}\)</span></p>
<p>由于 <span class="math inline">\(X\)</span> 是紧的，<span
class="math inline">\(\exists x_1,\cdots x_n\in X\)</span>，使得 <span
class="math inline">\(X=\bigcup_{i=1}^n U_{x_i}\)</span>.</p>
<p>由于每个 <span class="math inline">\(U_{x_i}\)</span> 至多包含了
<span class="math inline">\(S\)</span> 中的一个点，有 <span
class="math inline">\(S\)</span> 是一个有限集。</p></li>
<li><h4 id="主定理的证明必要条件">主定理的证明，必要条件</h4>
<p>若 <span class="math inline">\(A\subseteq \mathbb R^n\)</span>，并且
<span class="math inline">\(A\)</span> 是紧的，则 <span
class="math inline">\(A\)</span> 是有界闭集。</p>
<p>证明：</p>
<p><span class="math inline">\(\mathbb R^n\)</span> 是一个 Hausdorff
空间，于是 <span class="math inline">\(A\)</span> 是闭集；</p>
<p>考虑开球族 <span
class="math inline">\(B(0,m),m=1,2,3,\cdots\)</span>，我们知道 <span
class="math inline">\(A\subset
\bigcup_{m=1}^{\infty}B(0,m)\)</span>，由于 <span
class="math inline">\(A\)</span> 是紧集，于是<span
class="math inline">\(\exists k\)</span>，使得 <span
class="math inline">\(A\subset \bigcup_{m=1}^k B(0,m)\)</span>.</p>
<p>于是 <span class="math inline">\(A\subset B(0,k)\)</span>，于是 <span
class="math inline">\(A\)</span> 有界。</p></li>
<li><h4 id="紧集与函数极值">紧集与函数极值</h4>
<p>考虑映射 <span class="math inline">\(f:X\to\mathbb
R\)</span>，它是一个连续映射。则若 <span
class="math inline">\(X\)</span> 是一个紧空间，则 <span
class="math inline">\(f\)</span> 有最大值与最小值（<span
class="math inline">\(f\)</span> 有界且 <span
class="math inline">\(f\)</span> 可以取到边界）。</p>
<p>证明：</p>
<p><span class="math inline">\(X\)</span> 是紧空间，于是 <span
class="math inline">\(f(X)\)</span> 是 <span
class="math inline">\(\mathbb R\)</span>
中紧子集，于是根据主定理的必要性，有 <span
class="math inline">\(f(X)\)</span> 是有界闭集。因此 <span
class="math inline">\(f\)</span> 是有界函数。</p>
<p>更多地，因为 <span class="math inline">\(f(X)\)</span> 是闭集，<span
class="math inline">\(f(X)\)</span> 包含了自身的所有极限点，于是 <span
class="math inline">\(f\)</span>
的最大最小值（边界）都可以取到。</p></li>
<li><h4 id="lebesgue-引理-lebesgues-lemma">Lebesgue 引理 (Lebesgue's
Lemma)</h4>
<p>令 <span class="math inline">\(X\)</span> 是一个紧的度量空间，令
<span class="math inline">\(X=\bigcup_\alpha U_\alpha\)</span> 是 <span
class="math inline">\(X\)</span> 的开覆盖。则 <span
class="math inline">\(\exists \delta&gt;0\)</span>，将 <span
class="math inline">\(\delta\)</span> 称作关于 <span
class="math inline">\(X\)</span> 的开覆盖 <span
class="math inline">\(\set{U_\alpha}\)</span> 的 <strong>Lebesgue 数
(Lebesgue Number)</strong>，使得 <span class="math inline">\(\forall
X\)</span> 的子集，若其直径小于 <span
class="math inline">\(\delta\)</span>，则其一定被包含在某一个 <span
class="math inline">\(U_\alpha\)</span> 里。（直径 (Diameter)：<span
class="math inline">\(A\)</span> 的直径被定义为 <span
class="math inline">\(\sup_{x_1,x_2\in A} d(x_1,x_2)\)</span>）</p>
<p>证明：</p>
<p>反证法，假设 <span class="math inline">\(\exists
A_1,A_2,\cdots\)</span>，<span class="math inline">\(A_i\subseteq
X\)</span>，使得 <span class="math inline">\(A_i\)</span> 的直径 <span
class="math inline">\(\xrightarrow{i\to\infty} 0\)</span>，且 <span
class="math inline">\(A_i\)</span> 均不被包含在任意一个 <span
class="math inline">\(U_\alpha\)</span> 中。</p>
<p><span class="math inline">\(\forall i\)</span>，选取 <span
class="math inline">\(x_i\in A_i\)</span>. 考虑点列 <span
class="math inline">\(\set{x_i}\)</span>.</p>
<p>若该点列是一个有限集，则 <span class="math inline">\(\exists
k_1&lt;k_2&lt;k_3&lt;\cdots\)</span>，使得 <span
class="math inline">\(x_{k_1}=x_{k_2}=\cdots\)</span>. 令 <span
class="math inline">\(p=x_{k_1}\)</span>.</p>
<p>否则，<span class="math inline">\(\set{x_i}\)</span>
是一个无限集，其一定有一个极限点，记作 <span
class="math inline">\(p\)</span>.</p>
<p>不管是哪种情况，总有 <span class="math inline">\(\exists \alpha,p\in
U_\alpha\)</span>. 于是 <span class="math inline">\(\exists
\varepsilon&gt;0\)</span>，使得 <span
class="math inline">\(B(p,\varepsilon)\subset U_\alpha\)</span>.</p>
<p>我们选取足够大的 <span class="math inline">\(N\)</span>，使得 <span
class="math inline">\(A_N\)</span> 的直径小于 <span
class="math inline">\(\cfrac{\varepsilon}{2}\)</span> 并且 <span
class="math inline">\(x_N\in B(p,\cfrac{\varepsilon}{2})\)</span>.</p>
<p>然而在此种情况下 <span class="math inline">\(\forall x\in
A_N\)</span>，<span class="math inline">\(d(x,p)\leq
d(x,x_N)+d(x_N,p)&lt;\varepsilon\)</span>.</p>
<p>于是 <span class="math inline">\(A_N\subset B(p,\varepsilon)\subseteq
U_\alpha\)</span>，矛盾！</p></li>
<li><h4 id="乘积拓扑-product-topology">乘积拓扑 (Product Topology)</h4>
<p><span class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span> 是两个拓扑空间，问：能否在 <span
class="math inline">\(X\times Y\)</span> 上定义一个自然的拓扑结构？</p>
<p>考察 <span class="math inline">\(U\times V\)</span>，其中 <span
class="math inline">\(U\)</span> 是 <span
class="math inline">\(X\)</span> 中开集，<span
class="math inline">\(V\)</span> 是 <span
class="math inline">\(Y\)</span> 中开集，我们可以将 <span
class="math inline">\(U\times V\)</span> 定义为 <span
class="math inline">\(X\times Y\)</span> 中的开集吗？答案是不行的，因为
<span class="math inline">\(U_1\times V_1 \cup U_2\times V_2\)</span>
未必能长成乘积的形式。</p>
<p>例子：<span class="math inline">\(\mathbb R^2=\mathbb{R\times
R}\)</span>. <span class="math inline">\(U\subset \mathbb R^2\)</span>
为开圆盘，其自然不形如 <span class="math inline">\(V_1\times
V_2\)</span>，其中 <span class="math inline">\(V_1,V_2\)</span> 是 <span
class="math inline">\(\mathbb R\)</span> 中开集，但 <span
class="math inline">\(U\)</span> 是开集。（在这里，<span
class="math inline">\(U\)</span> 可以是开圆盘）</p>
<p>然而，若设 <span class="math inline">\(\beta=\set{U\times V\mid
U,V\subset \mathbb R,U,V \text{开}}\)</span>，有 <span
class="math inline">\(\beta\)</span> 可以是 <span
class="math inline">\(\mathbb R^2\)</span> 的一组拓扑基。</p>
<p>我们来引出一个一般的乘积拓扑概念：</p>
<p>令 <span class="math inline">\(X,Y\)</span> 是拓扑空间，令 <span
class="math inline">\(\beta=\set{U\times V\mid U\subset X,V\subset
Y,\text{开集}}\)</span>. 我们在 <span class="math inline">\(X\times
Y\)</span> 上装备拓扑，使得其以 <span
class="math inline">\(\beta\)</span>
作为一组基，这样装备的拓扑称作是<strong>乘积拓扑 (Product
Topology)</strong>.</p>
<p>装备了乘积拓扑的乘积空间 <span class="math inline">\(X\times
Y\)</span> 称作是<strong>乘积空间 (Product Space)</strong>.</p>
<p>注：</p>
<p>良定义的证明：<span class="math inline">\(U_1\times V_1\cap U_2\times
V_2=(U_1\cap U_2)\times (V_1\cap V_2)\in \beta\)</span>. 于是 <span
class="math inline">\(\beta\)</span> 确实可以定义一个拓扑。</p>
<p>回忆：令 <span class="math inline">\(X\)</span> 是一个集合，令 <span
class="math inline">\(\beta\)</span> 是 <span
class="math inline">\(X\)</span> 中集族且 <span
class="math inline">\(\beta\)</span> 不为空，假设 <span
class="math inline">\(\bigcup_{B\in\beta}B=X\)</span> 且 <span
class="math inline">\(\forall B_1,B_2\in \beta\)</span>，<span
class="math inline">\(\forall x\in B_1\cap B_2\)</span>，<span
class="math inline">\(\exists B_{3}^{x}\in \beta\)</span>，使得 <span
class="math inline">\(x\in B_{3}^x\)</span> 且 <span
class="math inline">\(B_{3}^x\subset B_1\cap
B_2\)</span>，则我们可以定义 <span class="math inline">\(X\)</span>
中开集为 <span class="math inline">\(\beta\)</span>
中成员的任意并，则这个定义给出了 <span class="math inline">\(X\)</span>
上的一个拓扑。</p>
<ul>
<li><h5 id="乘积空间的投影映射">乘积空间的投影映射</h5>
<p>考虑 <span class="math inline">\(X\times
Y\)</span>，其自然会诱导两个投影映射 <span
class="math inline">\(p_1:X\times Y\to X, p_2:X\times Y\to
Y\)</span>.</p>
<p>其中 <span
class="math inline">\(p_1(x,y)=x,p_2(x,y)=y\)</span>，我们将 <span
class="math inline">\(p_1,p_2\)</span> 称为投影映射。</p></li>
<li><h5 id="乘积拓扑关于投影的最小性">乘积拓扑关于投影的最小性</h5>
<p>乘积拓扑是使得 <span class="math inline">\(p_1,p_2\)</span>
是连续映射的最小拓扑。（最小：包含开集数量“最小”）</p>
<p>证明：</p>
<p>首先证明，如果我们装备了乘积拓扑，则 <span
class="math inline">\(p_1,p_2\)</span> 连续。</p>
<p>任取 <span class="math inline">\(U\subset X\)</span> 是开集，则 <span
class="math inline">\(p_1^{-1}(U)=U\times Y\subset X\times Y\)</span>
中开集，因此 <span class="math inline">\(p_1\)</span> 是连续的；</p>
<p>类似地 <span class="math inline">\(p_2\)</span> 也是连续的。</p>
<p>反过来，如果我们在 <span class="math inline">\(X\times Y\)</span>
上装备了某一拓扑使得 <span class="math inline">\(p_1,p_2\)</span>
是连续的，则 <span class="math inline">\(p_1^{-1}(U)\cap
p_2^{-1}(V)=U\times V\)</span>. 这是一个开集若 <span
class="math inline">\(U\subset X,V\subset Y\)</span> 是开集。</p>
<p>于是在这个拓扑一定包含了乘积拓扑中的所有基础开集。根据定义，它包含了乘积拓扑中的所有开集，于是乘积拓扑满足这个“最小性”。</p></li>
</ul></li>
</ul>
<h2 id="乘积拓扑与连通性入门">06. 乘积拓扑与连通性入门</h2>
<h3 id="乘积拓扑-product-topology-1">乘积拓扑 (Product Topology)</h3>
<ul>
<li><h4 id="定义">定义</h4>
<p><span class="math inline">\(X\times Y\)</span>
上定义乘积拓扑，我们找到 <span class="math inline">\(\beta=\set{U\times
V\mid U\subseteq X, V\subseteq Y, U, V\text{ open}}\)</span>，则令 <span
class="math inline">\(\beta\)</span> 作为拓扑基，这给出了乘积拓扑。</p>
<p><strong>投影映射</strong>：</p>
<p><span class="math inline">\(p_1:X\times Y\to X, p_2:X\times Y\to
Y\)</span>.</p>
<p>其中 <span
class="math inline">\(p_1(x,y)=x,p_2(x,y)=y\)</span>，我们将 <span
class="math inline">\(p_1,p_2\)</span> 称为投影映射。</p>
<p>我们已经证明了投影映射是连续的，且乘积拓扑是使得投影映射连续的最小拓扑。</p></li>
<li><h4 id="像为乘积拓扑映射的连续性">像为乘积拓扑映射的连续性</h4>
<p>映射 <span class="math inline">\(f:Z\to X\times Y\)</span>
（今后若不做特殊说明，则默认 <span class="math inline">\(X\times
Y\)</span> 装备乘积拓扑），映射是连续映射当且仅当 <span
class="math inline">\(p_1\circ f\)</span> 与 <span
class="math inline">\(p_2\circ f\)</span> 都是连续映射。</p>
<p>证明：</p>
<p><span class="math inline">\((\Rightarrow)\)</span>: 由于 <span
class="math inline">\(p_1,p_2,f\)</span>
都是连续的，自然映射的复合也是连续的。</p>
<p><span class="math inline">\((\Leftarrow)\)</span>: 由连续的定义，取
<span class="math inline">\(U\times V\subset X\times
Y\)</span>，使得这是一个基础开集。（回忆，如果所有基础开集的原像都是开集，则映射是连续的）</p>
<p>我们考察 <span class="math inline">\(f^{-1}(U\times V)=(p_1\circ
f)^{-1}(U)\cap (p_2\circ f)^{-1}(V)\)</span>，这自然是一个开集，因此
<span class="math inline">\(f\)</span> 是连续的。</p></li>
<li><h4 id="乘积拓扑保持-hausdorff">乘积拓扑保持 Hausdorff</h4>
<p>若 <span class="math inline">\(X,Y\neq\varnothing\)</span>
是两个拓扑空间，则 <span class="math inline">\(X\times Y\)</span> 是
Hausdorff 的当且仅当 <span class="math inline">\(X,Y\)</span> 都是
Hausdorff 的。</p>
<p>证明： <span class="math inline">\((\Rightarrow)\)</span>: 任取 <span
class="math inline">\(x_1\neq x_2\in X\)</span>，我们选取 <span
class="math inline">\(y\in Y\)</span>，于是存在邻域 <span
class="math inline">\((x_1,y)\in U_1\times V_1,(x_2,y)\in U_2\times
V_2\)</span> 两个邻域，使得 <span class="math inline">\((U_1\times
V_1)\cap (U_2\times
V_2)=\varnothing\)</span>（任何开集都可以写成基础开集的并形式，因此一定能取出基础开集）。</p>
<p>由于 <span class="math inline">\(y\in V_1\cap V_2\)</span>，我们有
<span class="math inline">\(U_1\cap U_2=\varnothing\)</span>，因此 <span
class="math inline">\(X\)</span> 是 Hausdorff，类似地 <span
class="math inline">\(Y\)</span> 也是 Hausdorff.</p>
<p><span class="math inline">\((\Leftarrow)\)</span>: 我们令 <span
class="math inline">\((x_1,y_1)\neq(x_2,y_2)\)</span>，不妨设 <span
class="math inline">\(x_1\neq x_2\)</span>，则 <span
class="math inline">\(\exists U_1,U_2\)</span> 是 <span
class="math inline">\(x_1,x_2\)</span> 邻域，使得 <span
class="math inline">\(U_1\cap U_2=\varnothing\)</span>.</p>
<p>于是 <span class="math inline">\(U_1\times Y\)</span> 与 <span
class="math inline">\(U_2\times Y\)</span> 是 <span
class="math inline">\((x_1,y_1)\)</span> 以及 <span
class="math inline">\((x_2,y_2)\)</span> 的邻域，且它们的交为空。于是
<span class="math inline">\(X\times Y\)</span> 是 Hausdorff.</p></li>
<li><h4 id="验证紧性可只取基础开集">验证紧性可只取基础开集</h4>
<p>令 <span class="math inline">\(\beta\)</span> 是 <span
class="math inline">\(X\)</span> 的一个拓扑基，则 <span
class="math inline">\(X\)</span> 是一个紧空间，当且仅当对于任意的开覆盖
<span class="math inline">\(X=\bigcup_{\alpha}B_\alpha\)</span>，其中
<span class="math inline">\(B_\alpha\)</span> 都是基础开集，都 <span
class="math inline">\(\exists B_1,\cdots,B_n\in
\set{B_\alpha}\)</span>，使得 <span
class="math inline">\(X=\bigcup_{i=1}^n B_i\)</span>.</p>
<p>证明：只需要验证右推左</p>
<p><span class="math inline">\((\Leftarrow)\)</span>: 令 <span
class="math inline">\(X=\bigcup_{\alpha} U_\alpha\)</span>
是一个任意开覆盖，则 <span class="math inline">\(\forall
\alpha\)</span>，<span class="math inline">\(U_\alpha=\bigcup_{\gamma\in
I_\alpha} B_\gamma\)</span>，其中 <span
class="math inline">\(B_\gamma\in \beta\)</span>，<span
class="math inline">\(I_\alpha\)</span> 为指标集。</p>
<p>于是 <span class="math inline">\(X=\bigcup_\alpha\bigcup_{\gamma\in
I_\alpha}B_\gamma\)</span>.</p>
<p>于是 <span class="math inline">\(\exists B_1,\cdots,B_n\in
\beta\)</span>，使得 <span class="math inline">\(X=\bigcup_{i=1}^n
B_i\)</span>.</p>
<p>我们选取 <span class="math inline">\(U_i\)</span> 使得 <span
class="math inline">\(B_i\subset U_i\)</span>，于是 <span
class="math inline">\(X=\bigcup_{i=1}^n U_i\)</span>.</p>
<p>于是 <span class="math inline">\(X\)</span> 是紧的。</p></li>
<li><h4 id="乘积拓扑保持紧性">乘积拓扑保持紧性</h4>
<p>令 <span class="math inline">\(X,Y\neq\varnothing\)</span>，则 <span
class="math inline">\(X\times Y\)</span> 是紧的当且仅当 <span
class="math inline">\(X,Y\)</span>
都是紧的。（注：不是空集是必要的，否则任何集合乘空集都是紧集，上面同）</p>
<p>证明：</p>
<p><span class="math inline">\((\Rightarrow)\)</span>: 令 <span
class="math inline">\(p_1:X\times Y\to X,p_2:X\times Y\to Y\)</span>
是投影映射，则 <span class="math inline">\(X=p_1(X\times
Y)\)</span>，<span class="math inline">\(Y=p_2(X\times Y)\)</span>.</p>
<p>我们知道 <span class="math inline">\(p_1,p_2\)</span>
是连续映射，<span class="math inline">\(X\times Y\)</span>
是紧的，自然有 <span class="math inline">\(X,Y\)</span> 都是紧的。</p>
<p><span class="math inline">\((\Leftarrow)\)</span>: 令 <span
class="math inline">\(X\times Y=\bigcup_{\alpha} U_\alpha\times
V_\alpha\)</span> 开覆盖。</p>
<p><span class="math inline">\(\forall x\in X\)</span>，考虑 <span
class="math inline">\(p_2|_{\set x\times Y}=\set x\times Y\to
Y\)</span>，这是一个同胚映射，因此 <span class="math inline">\(\set
x\times Y\)</span> 是一个紧空间。</p>
<figure>
<img src="\06-1.png" alt="image-20231012101527788" />
<figcaption aria-hidden="true">image-20231012101527788</figcaption>
</figure>
<p>于是 <span class="math inline">\(\exists U_1^x\times
V_1^x,\cdots,U_{n_x}^x\times V_{n_x}^x\in \set{U_\alpha\times
V_\alpha}\)</span>，使得 <span class="math inline">\(\set x\times
Y\subseteq\bigcup_{i=1}^{n_x} U_i^x\times V_i^x\)</span>.</p>
<p>令 <span class="math inline">\(U^x=\bigcap_{i=1}^n
U_i^x\)</span>，于是 <span class="math inline">\(U^x\times Y\subseteq
\bigcup_{i=1}^{n_x} U_i^x\times V_i^x\)</span>.</p>
<figure>
<img src="\06-2.png" alt="image-20231012102103157" />
<figcaption aria-hidden="true">image-20231012102103157</figcaption>
</figure>
<p>我们对所有 <span class="math inline">\(x\in X\)</span> 找 <span
class="math inline">\(U^x\)</span>，则 <span
class="math inline">\(X=\bigcup_x U^x\)</span>.</p>
<p>由于 <span class="math inline">\(X\)</span> 是紧的，于是 <span
class="math inline">\(\exists x_1,\cdots,x_n\in X\)</span>，使得 <span
class="math inline">\(X=\bigcup_{i=1}^n U^{x_i}\)</span>.</p>
<p>于是 <span class="math inline">\(X\times
Y=\bigcup_{i=1}^{n}U^{x_i}\times Y\)</span>.</p>
<p>于是 <span class="math inline">\(X\times
Y=\bigcup_{i=1}^n\bigcup_{j=1}^{n_{x_i}} U_j^{x_i}\times
V_j^{x_i}\)</span>，于是 <span class="math inline">\(X\times Y\)</span>
为紧集。</p></li>
<li><h4 id="主定理的证明充分条件">主定理的证明，充分条件</h4>
<p>回忆主定理：<span class="math inline">\(X\subset \mathbb R^n\)</span>
是一个紧集，当且仅当 <span class="math inline">\(X\)</span>
是一个有界闭集。</p>
<p>充分条件：若 <span class="math inline">\(X\subset \mathbb
R^n\)</span>，且 <span class="math inline">\(X\)</span> 是有界闭集，则
<span class="math inline">\(X\)</span> 是一个紧集。</p>
<p>证明：由于 <span class="math inline">\(X\)</span> 是有界的，因此
<span class="math inline">\(\exists M&gt;0\)</span>，使得 <span
class="math inline">\(X\subseteq [-M,M]^n\)</span>.</p>
<p>由闭区间的有限覆盖定理，<span class="math inline">\([-M,M]\)</span>
是紧集；由乘积拓扑保持紧性，有 <span
class="math inline">\([-M,M]^n\)</span> 也是紧集。</p>
<p>由于 <span class="math inline">\(X\)</span> 是闭集，于是 <span
class="math inline">\(X\subseteq [-M,M]^n\)</span>
是闭集；由于闭子集保持紧性，有 <span class="math inline">\(X\)</span> 在
<span class="math inline">\([-M,M]^n\)</span> 是紧集，其在 <span
class="math inline">\(\mathbb R^n\)</span> 中也是紧集。</p></li>
<li><h4 id="无穷乘积-infinite-product">*无穷乘积 (Infinite Product)</h4>
<p>考虑集合的乘积 <span class="math inline">\(\prod_{i\in
I}X_i\)</span>，<span class="math inline">\(|I|\)</span> 可以是 <span
class="math inline">\(\infty\)</span>.</p>
<p>问题：如何在 <span class="math inline">\(\prod_{i\in I}X_i\)</span>
上面定义乘积拓扑？</p>
<ul>
<li><h5 id="箱拓扑-box-topology">箱拓扑 (Box Topology)</h5>
<p>想法1：是否可以按照有限的情形推广构造？</p>
<p>令 <span class="math inline">\(\beta=\set{\prod_{i\in I}U_i\mid
U_i\subset X_i\text{ open}}\)</span>，<span
class="math inline">\(\beta\)</span> 确实可以定义一个拓扑，使得 <span
class="math inline">\(\beta\)</span> 是一个拓扑基。</p>
<p>这样构造出的拓扑我们称之为<strong>箱拓扑 (Box
Topology)</strong>.</p></li>
<li><h5 id="乘积拓扑-product-topology-2">乘积拓扑 (Product
Topology)</h5>
<p>想法2：我们只在有限多的分量中取开集会如何？</p>
<p>令 <span class="math inline">\(\beta=\set{U_{i_1}\times
U_{i_2}\times\cdots\times U_{i_k}\times \prod_{i\in
I\setminus\set{i_1,i_2,\cdots,i_k}}\mid k\geq 0,i_1,\cdots,i_k\in
I,U_{i_j}\subset X_{i_j}\text{ open}}\)</span>，可以验证 <span
class="math inline">\(\beta\)</span> 也定义了一个拓扑，使得 <span
class="math inline">\(\beta\)</span> 是一个拓扑基。</p>
<p>我们将这个拓扑称为无穷乘积情况下的<strong>乘积拓扑 (Product
Topology)</strong>.</p></li>
<li><h5 id="两种拓扑的差异">两种拓扑的差异</h5>
<p>当 <span
class="math inline">\(|I|&lt;\infty\)</span>，两个拓扑完全等价。</p>
<p>我们会有如下定理：</p>
<ul>
<li><p>若 <span class="math inline">\(X_i\)</span> 均为 Hausdorff
空间，则 <span class="math inline">\(\prod_{i\in I}X_i\)</span>
在箱拓扑和乘积拓扑下都是 Hausdorff 空间。</p></li>
<li><p>令 <span class="math inline">\(f:Y\to \prod_{i\in I}
X_i\)</span>，令 <span class="math inline">\(\prod_{i\in I} X_i\)</span>
装备上乘积拓扑，则 <span class="math inline">\(f\)</span>
是连续的当且仅当 <span class="math inline">\(f\)</span>
的每一个分量都是连续的（<span class="math inline">\(\pi_i \circ
f\)</span> 均为连续，<span class="math inline">\(\pi_i:\prod_{i\in I}
X_i\to X_i\)</span>）。</p>
<p>注：如果我们此时装备了箱拓扑，并且假设每一个分量 <span
class="math inline">\(\pi_i\circ f\)</span> 都是连续映射，则一般情况下
<span class="math inline">\(f\)</span> 可以不是连续映射。</p>
<p>例如：令 <span class="math inline">\(I=\mathbb N\)</span>，令 <span
class="math inline">\(X_i=\mathbb R\)</span>，<span
class="math inline">\(Y=\mathbb R\)</span>. 定义映射 <span
class="math inline">\(f:\mathbb R\to \prod_{i\in \mathbb N}\mathbb
R\)</span>，<span class="math inline">\(f(x)=(x,x,x,\cdots)\)</span>.
此时有 <span class="math inline">\(\pi_i\circ
f=id\)</span>，因此每个分量都是连续映射.</p>
<p>然而，找开集 <span class="math inline">\(U=(-1,1)\times
(-\cfrac{1}{2},\cfrac{1}{2})\times (-\cfrac{1}{3},\cfrac{1}{3})\times
\cdots\)</span>，这在箱拓扑中是开集（在乘积拓扑中不是）。而 <span
class="math inline">\(f^{-1}(U)=\set{0}\)</span>，这不是开集，因此 <span
class="math inline">\(f\)</span> 不是连续映射。</p></li>
<li><h6 id="吉洪诺夫定理-tychonoff-theorem">吉洪诺夫定理 (Tychonoff
Theorem)</h6>
<p>若 <span class="math inline">\(X_i\)</span> 是紧集，则 <span
class="math inline">\(\prod_{i\in I}X_i\)</span>
在乘积拓扑下也是紧的。</p>
<p>注：在箱拓扑下这个结论是错误的。</p></li>
</ul></li>
</ul></li>
</ul>
<h3 id="连通性-connectedness">连通性 (Connectedness)</h3>
<ul>
<li><h4 id="两种关于连通性的观点">两种关于连通性的观点</h4>
<ul>
<li><h5 id="集合划分观点">集合划分观点</h5>
<p><span class="math inline">\(X\)</span> 被称为是连通的，当且仅当若
<span class="math inline">\(X=A\cup B\)</span> 且 <span
class="math inline">\(A,B\neq \varnothing\)</span>，则 <span
class="math inline">\(\bar A\cap B\neq\varnothing\)</span> 或 <span
class="math inline">\(A\cap \bar B\neq\varnothing\)</span>.</p>
<figure>
<img src="\06-3.png" alt="image-20231012105513408" />
<figcaption aria-hidden="true">image-20231012105513408</figcaption>
</figure>
<p>如图，在这种情况下，中间的“线”会在某个集合取闭包后被两个集合同时包含。</p></li>
<li><h5 id="道路连通观点">道路连通观点</h5>
<p>令 <span class="math inline">\(I=[0,1]\)</span> 区间，<span
class="math inline">\(X\)</span> 是连通的当且仅当 <span
class="math inline">\(\forall p,q\in X\)</span>，<span
class="math inline">\(\exists\)</span> 连续映射 <span
class="math inline">\(f:[0,1]\to X\)</span>，使得 <span
class="math inline">\(f(0)=p,f(1)=q\)</span>.</p>
<figure>
<img src="\06-4.png" alt="image-20231012110345214" />
<figcaption aria-hidden="true">image-20231012110345214</figcaption>
</figure></li>
<li><h5 id="两种观点的整理">两种观点的整理</h5>
<p>最终，我们会将第一种观点称作<strong>连通性
(Connectedness)</strong>，将第二种观点称作 <strong>道路连通性
(Path-Connectedness)</strong>。</p>
<p>我们将会证明道路连通性<span
class="math inline">\(\Rightarrow\)</span>连通性，但一般情况下，连通性<span
class="math inline">\(\not\Rightarrow\)</span>道路连通性。</p></li>
</ul></li>
<li><h4 id="连通性的定义-connectedness">连通性的定义
(Connectedness)</h4>
<p>拓扑空间 <span class="math inline">\(X\)</span> 被称为是连通的，如果
<span class="math inline">\(\forall A,B\neq \varnothing\)</span>，使得
<span class="math inline">\(X=A\cup B\)</span>，总有 <span
class="math inline">\(A\cap \bar B\neq \varnothing\)</span> 或 <span
class="math inline">\(\bar B\cap A\neq\varnothing\)</span>.</p></li>
<li><h4 id="连通性的等价条件">连通性的等价条件</h4>
<p>下面几个关于连通性的条件是等价的：</p>
<ul>
<li><span class="math inline">\((1)\)</span> <span
class="math inline">\(X\)</span> 是连通的（定义）；</li>
<li><span class="math inline">\((2)\)</span> <span
class="math inline">\(X\)</span> 中既开又闭的集合只有 <span
class="math inline">\(X\)</span> 与 <span
class="math inline">\(\varnothing\)</span>；</li>
<li><span class="math inline">\((3)\)</span> <span
class="math inline">\(X\)</span> 不能被表示为两个非空开集的不交并。</li>
</ul>
<p>证明：</p>
<p><span class="math inline">\((1)\Rightarrow(2)\)</span>: 任取 <span
class="math inline">\(A\in X\)</span> 是既开又闭的，取 <span
class="math inline">\(B=X\setminus A\)</span>，自然 <span
class="math inline">\(B\)</span> 也是既开又闭的。有 <span
class="math inline">\(A=\bar A,B=\bar B\)</span>，且 <span
class="math inline">\(\bar A\cap B=A\cap \bar
B=\varnothing\)</span>，<span class="math inline">\(X=A\cup
B\)</span>.</p>
<p>此时由 <span class="math inline">\((1)\)</span>，总有 <span
class="math inline">\(A=\varnothing\)</span> 或者 <span
class="math inline">\(B=\varnothing\)</span>，因此 <span
class="math inline">\(A=X\)</span> 或 <span
class="math inline">\(A=\varnothing\)</span>.</p>
<p><span class="math inline">\((2)\Rightarrow(3)\)</span>: 令 <span
class="math inline">\(X=A\cup B\)</span>，其中 <span
class="math inline">\(A,B\)</span> 为开集且 <span
class="math inline">\(A=X\setminus B\)</span>.</p>
<p>此时 <span class="math inline">\(A,B\)</span> 也都是闭集，由于 <span
class="math inline">\((2)\)</span>，有 <span
class="math inline">\(\set{A,B}=\set{X,\varnothing}\)</span>，因此得出结论。</p>
<p><span class="math inline">\((3)\Rightarrow(1)\)</span>: 令 <span
class="math inline">\(X=A\cup B\)</span>，其中 <span
class="math inline">\(A,B\neq\varnothing\)</span>.</p>
<p>假设 <span class="math inline">\(\bar A\cap B=\varnothing=A\cap \bar
B\)</span>，因此 <span class="math inline">\(A\cap
B=\varnothing\)</span> 且 <span class="math inline">\(X=A\sqcup B=\bar
A\sqcup B=A\sqcup \bar B\)</span>，于是 <span
class="math inline">\(A=\bar A,B=\bar B\)</span>. （注：<span
class="math inline">\(A\sqcup B\)</span> 表示 <span
class="math inline">\(A\)</span> 与 <span
class="math inline">\(B\)</span> 的不交并）</p>
<p>于是 <span class="math inline">\(A,B\)</span> 又分别是开集，由于
<span class="math inline">\((3)\)</span>，矛盾！</p></li>
<li><h4 id="实数轴是连通的">实数轴是连通的</h4>
<p><span class="math inline">\(\mathbb R\)</span> 是连通的。</p>
<p>证明：假设 <span class="math inline">\(\mathbb R=A\cup B\)</span> 且
<span class="math inline">\(\bar A\cap B=A\cap\bar
B=\varnothing\)</span>，则有 <span class="math inline">\(A\cap
B=\varnothing\)</span>.</p>
<p>假设 <span class="math inline">\(A,B\neq \varnothing\)</span>，选取
<span class="math inline">\(a\in A,b\in B\)</span>，不妨设 <span
class="math inline">\(a&lt;b\)</span>.</p>
<p>考虑集合 <span class="math inline">\(X=\set{x\in A\mid
x&lt;b}\)</span>，令 <span class="math inline">\(s\)</span> 是 <span
class="math inline">\(X\)</span> 的上确界。</p>
<p>如果 <span class="math inline">\(s\in A\)</span>，有 <span
class="math inline">\(s=\max X\)</span>，且 <span
class="math inline">\(s&lt;b\)</span>，此时 <span
class="math inline">\((s,b]\subseteq B\)</span>，于是 <span
class="math inline">\(s\in \bar B\cap A\)</span>，与假设矛盾；</p>
<p>如果 <span class="math inline">\(s\in B\)</span>，有 <span
class="math inline">\(s\not\in A\)</span>，但 <span
class="math inline">\(s=\sup X\)</span>，于是 <span
class="math inline">\(s\in \bar A\cap B\)</span>，与假设矛盾。</p>
<p>综上，假设不成立，有 <span class="math inline">\(\mathbb R\)</span>
是连通的。</p></li>
<li><h4 id="连续映射保持连通性">连续映射保持连通性</h4>
<p>考虑 <span class="math inline">\(f:X\to Y\)</span> 连续映射，且 <span
class="math inline">\(X\)</span> 是连通的，则像 <span
class="math inline">\(f(X)\)</span> 也是连通的。</p>
<p>证明：令 <span class="math inline">\(f(X)=A\cup B\)</span>，其中
<span class="math inline">\(A,B\)</span> 是 <span
class="math inline">\(f(X)\)</span> 中开集且 <span
class="math inline">\(A\cap B=\varnothing\)</span>.</p>
<p>此时有 <span class="math inline">\(X=f^{-1}(A)\cup
f^{-1}(B)\)</span>，自然有 <span
class="math inline">\(f^{-1}(A),f^{-1}(B)\)</span> 是 <span
class="math inline">\(X\)</span> 中开集且 <span
class="math inline">\(f^{-1}(A)\cap f^{-1}(B)=\varnothing\)</span>.</p>
<p>于是有 <span class="math inline">\(f^{-1}(A)=\varnothing\)</span> 或
<span class="math inline">\(f^{-1}(B)=\varnothing\)</span>，于是 <span
class="math inline">\(A=\varnothing\)</span> 或 <span
class="math inline">\(B=\varnothing\)</span>，因此 <span
class="math inline">\(f(X)\)</span> 是连通的。</p>
<p>我们有如下的自然推论：令 <span class="math inline">\(h:X\to
Y\)</span> 为同胚，则 <span class="math inline">\(X\)</span>
是连通的当且仅当 <span class="math inline">\(Y\)</span>
是连通的。</p></li>
<li><h4 id="取闭包保持连通性">取闭包保持连通性</h4>
<p>令 <span class="math inline">\(X\)</span> 是一个拓扑空间，<span
class="math inline">\(Z\subseteq X\)</span> 且稠密。则若 <span
class="math inline">\(Z\)</span> 是连通的，则 <span
class="math inline">\(X\)</span> 是连通的。</p>
<p>证明：令 <span class="math inline">\(\varnothing \neq A\subseteq
X\)</span> 且既开又闭，由于 <span class="math inline">\(\bar
Z=X\)</span> 且 <span class="math inline">\(A\)</span> 是开集，我们有
<span class="math inline">\(Z\cap A\neq \varnothing\)</span>.</p>
<p>于是有 <span class="math inline">\(Z\cap A\)</span> 是 <span
class="math inline">\(Z\)</span>
中既开又闭的集合且是非空的，由连通性，有 <span
class="math inline">\(Z\cap A=Z\)</span>，于是 <span
class="math inline">\(Z\subset A\)</span>.</p>
<p>于是 <span class="math inline">\(X=\bar X\subset \bar
A=A\)</span>，于是 <span class="math inline">\(X=A\)</span>，于是 <span
class="math inline">\(X\)</span> 连通。</p></li>
</ul>
<h2 id="连通性与道路连通性">07. 连通性与道路连通性</h2>
<h3 id="连通性-connectedness-1">连通性 (Connectedness)</h3>
<ul>
<li><h4 id="回顾闭包维持连通性">回顾：闭包维持连通性</h4>
<p>若 <span class="math inline">\(Z\subseteq X\)</span> 是稠密的且 <span
class="math inline">\(Z\)</span> 是连通的，则 <span
class="math inline">\(X\)</span> 是连通的</p></li>
<li><h4
id="介于连通集合与其闭包间的集合也连通">介于连通集合与其闭包间的集合也连通</h4>
<p>若 <span class="math inline">\(Z\subseteq X\)</span>，<span
class="math inline">\(Z\)</span> 是连通的且 <span
class="math inline">\(Z\subseteq Y\subseteq \overline Z\)</span>，则
<span class="math inline">\(Y\)</span> 是连通的。特别地，若取 <span
class="math inline">\(Y=\overline Z\)</span>，即有 <span
class="math inline">\(\overline{Z}\)</span> 连通。</p>
<p>证明：在 <span class="math inline">\(Y\)</span> 中取 <span
class="math inline">\(Z\)</span> 的闭包即为 <span
class="math inline">\(Y\)</span>，由闭包维持连通性立得。</p></li>
<li><h4 id="mathbbr-中的连通集合为区间"><span
class="math inline">\(\mathbb{R}\)</span> 中的连通集合为区间</h4>
<p><span class="math inline">\(\varnothing\neq
X\subseteq\mathbb{R}\)</span>，则 <span class="math inline">\(X\)</span>
是连通的当且仅当 <span class="math inline">\(X\)</span> 是区间。</p>
<p>证明：<span class="math inline">\((\Rightarrow):\)</span> 假设 <span
class="math inline">\(X\)</span> 不是一个区间，则 <span
class="math inline">\(\exists p\in \mathbb{R}\setminus X\)</span>，使得
<span class="math inline">\(\exists a,b\in X\)</span>，有 <span
class="math inline">\(a&lt;p&lt;b\)</span>.</p>
<p>令 <span class="math inline">\(A=\set{x\in X\mid x &lt;
p}\)</span>，令 <span class="math inline">\(B=\set{x\in X\mid
x&gt;p}\)</span>，由刚刚的性质，我们知道这两个集合非空，并且 <span
class="math inline">\(X=A\sqcup B\)</span> （<span
class="math inline">\(X=A\cup B, A\cap B=\varnothing\)</span>）。</p>
<p>我们接下来证明 <span class="math inline">\(A,B\)</span>
均为开集。<span class="math inline">\(\forall x\in A\)</span>，<span
class="math inline">\(\exists \varepsilon&gt;0\)</span>，使得 <span
class="math inline">\(x+\varepsilon&lt;p\)</span>，于是 <span
class="math inline">\((-\infty, x+\varepsilon)\cap X\)</span> 就是 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(X\)</span> 中邻域，且这个邻域位于 <span
class="math inline">\(A\)</span> 中，于是 <span
class="math inline">\(A\)</span> 在 <span
class="math inline">\(X\)</span> 中为开集。</p>
<p>类似地，我们可以说明 <span class="math inline">\(B\)</span> 在 <span
class="math inline">\(X\)</span> 中也为开集，如此我们得到矛盾，<span
class="math inline">\(X\)</span> 不是连通。</p>
<p><span class="math inline">\((\Leftarrow):\)</span> 考虑开区间 <span
class="math inline">\((a,b)\)</span>，其中 <span
class="math inline">\(a&lt;b\)</span>. 开区间同胚于 <span
class="math inline">\(\mathbb{R}\)</span>，由于 <span
class="math inline">\(\mathbb{R}\)</span> 连通，因此 <span
class="math inline">\((a,b)\)</span> 自然为连通集。</p>
<p>考虑闭区间 <span class="math inline">\([a,b]\)</span>，有 <span
class="math inline">\([a,b]=\overline{(a,b)}\)</span>，由上面定理有
<span class="math inline">\([a,b]\)</span> 连通。</p>
<p>考虑半开半闭区间 <span class="math inline">\((a,b]\)</span>，有 <span
class="math inline">\((a,b)\subseteq (a,b]\subseteq
\overline{(a,b)}\)</span>，因此 <span
class="math inline">\((a,b]\)</span> 连通。</p>
<p>同理 <span class="math inline">\([a,b)\)</span> 也连通。</p>
<p>因此区间为连通的。</p></li>
<li><h4 id="并集与连通性">并集与连通性</h4>
<p>Q：考虑两个连通集合 <span class="math inline">\(A,B\)</span> 的并集
<span class="math inline">\(A\cup B\)</span>，问 <span
class="math inline">\(A\cup B\)</span> 是否连通？</p>
<p>如果不加限制，显然答案是否定的。例如两个不交的圆盘。如何加以限制使得并集也是连通的？</p>
<ul>
<li><h5 id="相互分离的定义-separated">相互分离的定义 (Separated)</h5>
<p>考虑 <span class="math inline">\(A,B\subseteq X\)</span>，我们称
<span class="math inline">\(A,B\)</span> 是<strong>相互分离
(separated)</strong>的，若 <span
class="math inline">\(\overline{A}\cap\overline{B}=\varnothing\)</span>.</p></li>
<li><h5 id="不相互分离集合的并连通">不相互分离集合的并连通</h5>
<p>考虑空间 <span class="math inline">\(X=\bigcup_{\alpha}
A_\alpha\)</span>，其中 <span class="math inline">\(\forall
\alpha,A_\alpha\)</span> 是连通的。假设 <span
class="math inline">\(\not\exists \alpha_1,\alpha_2\)</span>，使得 <span
class="math inline">\(A_{\alpha_1}\)</span> 与 <span
class="math inline">\(A_{\alpha_2}\)</span>
是分离的（即任意两个成员都不是相互分离的），则 <span
class="math inline">\(X\)</span> 是连通的。</p>
<p>证明：</p>
<p>令 <span class="math inline">\(B\subseteq X\)</span>
是既开又闭的集合。由于 <span class="math inline">\(A_\alpha\)</span>
是连通的，<span class="math inline">\(B\cap
A_\alpha=\varnothing\)</span> 或 <span
class="math inline">\(A_\alpha\)</span>. （这是因为 <span
class="math inline">\(B\cap A_\alpha\)</span> 是 <span
class="math inline">\(A_\alpha\)</span> 中既开又闭的集合）</p>
<p>若 <span class="math inline">\(B\cap A_\alpha=\varnothing,\forall
\alpha\)</span>，则 <span
class="math inline">\(B=\varnothing\)</span>.</p>
<p>若 <span class="math inline">\(\exists
A_{\alpha_0}\in\set{A_\alpha}\)</span>，使得 <span
class="math inline">\(B\cap A_{\alpha_0}=A_{\alpha_0}\)</span>，于是
<span class="math inline">\(A_{\alpha_0}\subseteq B\)</span>.</p>
<p>如果 <span class="math inline">\(\exists
A_{\alpha_1}\in\set{A_\alpha}\)</span>，使得 <span
class="math inline">\(B\cap A_{\alpha_1}=\varnothing\)</span>：则由于
<span class="math inline">\(B\)</span> 是一个闭集，有 <span
class="math inline">\(\overline{A_{\alpha_0}}\subseteq
B\)</span>；另一方面，<span class="math inline">\(X\setminus B\)</span>
也是闭集，有 <span
class="math inline">\(\overline{A_{\alpha_1}}\subseteq X\setminus
B\)</span>。于是 <span class="math inline">\(\overline{A_{\alpha_0}}\cap
\overline{A_{\alpha_1}}=\varnothing\)</span>，矛盾！</p>
<p>因此，<span class="math inline">\(\forall \alpha\)</span>，有 <span
class="math inline">\(B\cap A_\alpha=A_\alpha\)</span>，于是 <span
class="math inline">\(B=X\)</span>.</p>
<p>进而，<span class="math inline">\(X\)</span> 中既开又闭的集合只有
<span class="math inline">\(X\)</span> 与 <span
class="math inline">\(\varnothing\)</span>，<span
class="math inline">\(X\)</span> 为连通。</p></li>
<li><h5
id="交集不为空的连通集合族的并连通">交集不为空的连通集合族的并连通</h5>
<p>如果 <span
class="math inline">\(X=\bigcup_{\alpha}A_\alpha\)</span>，其中 <span
class="math inline">\(\forall \alpha, A_\alpha\)</span> 连通。如果 <span
class="math inline">\(\bigcap_{\alpha}
A_\alpha\neq\varnothing\)</span>，则 <span
class="math inline">\(X\)</span> 是连通的。</p>
<p>证明：由上面定理立得。</p></li>
<li><h5 id="注取交操作的连通性">注：取交操作的连通性</h5>
<p>若 <span class="math inline">\(A,B\subseteq X\)</span>，其中 <span
class="math inline">\(A,B\)</span> 都是连通集。问：<span
class="math inline">\(A\cap B\)</span> 是否是连通集？</p>
<p>事实上，<span class="math inline">\(A\cap B\)</span>
一般也不是连通集。</p>
<p>如下图：</p>
<figure>
<img src="\07-1.png" alt="image-20231017154543684" />
<figcaption aria-hidden="true">image-20231017154543684</figcaption>
</figure></li>
</ul></li>
<li><h4 id="乘积集合保持连通性">乘积集合保持连通性</h4>
<p>令 <span class="math inline">\(X,Y\)</span> 是非空空间，则 <span
class="math inline">\(X\times Y\)</span> 是连通的当且仅当 <span
class="math inline">\(X,Y\)</span> 都是连通的。</p>
<p>证明：</p>
<p><span class="math inline">\((\Rightarrow):\)</span> 令 <span
class="math inline">\(p_1,p_2\)</span> 是两个投影映射，则 <span
class="math inline">\(X=p_1(X\times
Y)\)</span>，根据连续映射保持连通性，有 <span
class="math inline">\(X\)</span> 连通；类似有 <span
class="math inline">\(Y\)</span> 连通。</p>
<p><span class="math inline">\((\Leftarrow):\)</span> <span
class="math inline">\(\forall x\in X\)</span>，根据 <span
class="math inline">\(\set{x}\times Y\)</span> 与 <span
class="math inline">\(Y\)</span> 同胚，<span
class="math inline">\(Y\)</span> 是连通的，故有 <span
class="math inline">\(\set{x}\times Y\)</span> 是连通的。</p>
<p>类似地，<span class="math inline">\(\forall y\in Y\)</span>，<span
class="math inline">\(X\times \set{y}\)</span> 是连通的。</p>
<p><span class="math inline">\((x,y)\in (\set{x}\times Y)\cap (X\times
\set{y})\)</span>，如果我们定义 <span
class="math inline">\(A(x,y):=(\set{x}\times Y)\cup(X\times
\set{y})\)</span>，有 <span class="math inline">\(A(x,y)\)</span>
是连通的。</p>
<figure>
<img src="07-2.png" alt="image-20231017155232888" />
<figcaption aria-hidden="true">image-20231017155232888</figcaption>
</figure>
<p>我们考虑 <span class="math inline">\((x&#39;,y&#39;)\in X\times
Y\)</span>，考虑 <span
class="math inline">\(A(x&#39;,y&#39;)\)</span>，有 <span
class="math inline">\(A(x&#39;,y&#39;)\cap
A(x,y)\neq\varnothing\)</span>.</p>
<figure>
<img src="\07-3.png" alt="image-20231017155341235" />
<figcaption aria-hidden="true">image-20231017155341235</figcaption>
</figure>
<p>因为 <span class="math inline">\(X\times Y=\bigcup_{x\in X,y\in
Y}A(x,y)\)</span>，这些集合两两不分离。由于先前的定理，有 <span
class="math inline">\(X\times Y\)</span> 也是连通的。</p></li>
<li><h4 id="mathbbrnmathbbrtimes-rtimescdotstimes-r-是连通的"><span
class="math inline">\(\mathbb{R}^n=\mathbb{R\times R\times\cdots\times
R}\)</span> 是连通的</h4>
<p>由上面立得。</p></li>
<li><h4 id="连通分支的定义-connected-components">连通分支的定义
(Connected Components)</h4>
<p>对于 <span class="math inline">\(\forall x,y\in
X\)</span>，定义等价关系 <span class="math inline">\(x\sim
y\)</span>：<span class="math inline">\(x\sim y\)</span> 如果 <span
class="math inline">\(\exists A\subseteq X\)</span>，<span
class="math inline">\(A\)</span> 是连通的且 <span
class="math inline">\(x,y\in A\)</span>.</p>
<p>这样定义的等价关系将诱导 <span class="math inline">\(X\)</span>
上的一个等价类，等价类就被称作是 <span class="math inline">\(X\)</span>
的<strong>连通分支 (Connected Components)</strong>。</p>
<ul>
<li><h5 id="注连通分支具有极大性">注：连通分支具有极大性</h5>
<p>一个连通分支一定是一个极大的连通子集。</p>
<p>”极大性“是易于理解的，我们来简单看看连通分支为什么是连通集：令 <span
class="math inline">\(A\)</span> 是一个连通分支，我们选择任意的 <span
class="math inline">\(x_0\in A\)</span>，则 <span
class="math inline">\(\forall x\in X\)</span>，<span
class="math inline">\(\exists B_x\)</span> 连通集合，使得 <span
class="math inline">\(x,x_0\in B_x\)</span>.</p>
<p>于是 <span class="math inline">\(A=\bigcup_{x\in A}
B_x\)</span>，因此它是连通的。</p></li>
<li><h5 id="注上述关系确实是等价关系">注：上述关系确实是等价关系</h5>
<p>自反性、对称性：这是自然的；</p>
<p>传递性：若 <span class="math inline">\(x\sim y,y\sim z\)</span>，则
<span class="math inline">\(\exists A,B\)</span> 连通集，使得 <span
class="math inline">\(x,y\in A,y,z\in B\)</span>，从而由于 <span
class="math inline">\(A\cap B\supset\set{y}\neq \varnothing\)</span>，故
<span class="math inline">\(A\cup B\)</span> 连通，故 <span
class="math inline">\(x\sim z\)</span>.</p></li>
</ul></li>
<li><h4 id="连通分支是分离的闭集">连通分支是分离的闭集</h4>
<p>连通分支是闭集且任意两个不同的连通分支一定是相互分离的。</p>
<p>证明：</p>
<p>闭集：如果 <span class="math inline">\(A\subset X\)</span>
是一个连通分支，有 <span class="math inline">\(A\)</span> 是连通的。于是
<span class="math inline">\(\overline{A}\)</span> 也是连通的。又因为
<span class="math inline">\(A\)</span> 是极大的连通集合，有 <span
class="math inline">\(A=\overline{A}\)</span>，换言之 <span
class="math inline">\(A\)</span> 是闭集。</p>
<p>相互分离：假设 <span class="math inline">\(\exists B\)</span>，<span
class="math inline">\(B\)</span> 是另一个连通分支，假设 <span
class="math inline">\(A,B\)</span> 不是相互分离的。由于 <span
class="math inline">\(\overline{A}\cap\overline{B}\neq\varnothing\)</span>，有
<span class="math inline">\(A\cup B\)</span>
也是连通集合，这与极大性矛盾。</p></li>
<li><h4 id="举例连通分支">举例：连通分支</h4>
<p><span class="math inline">\(\mathbb{R}\setminus \set{0}\)</span>
有两个连通分支 <span class="math inline">\((-\infty,0)\)</span> 与 <span
class="math inline">\((0,+\infty)\)</span>。这两个连通分支在 <span
class="math inline">\(\mathbb{R}\setminus \set{0}\)</span>
都是既开又闭的。</p>
<p>若 <span class="math inline">\(X\)</span>
只有有限多个连通分支，则这些连通分支均是既开又闭的集合。</p>
<p>考虑有理数集 <span class="math inline">\(\mathbb{Q}\)</span>，<span
class="math inline">\(\forall x\in \mathbb{Q}\)</span>，有 <span
class="math inline">\(\set{x}\)</span> 是 <span
class="math inline">\(\mathbb{Q}\)</span> 的连通分支。与此同时，<span
class="math inline">\(\set{x}\)</span> 在 <span
class="math inline">\(\mathbb{Q}\)</span> 中是闭集而不是开集。</p>
<p>令 <span class="math inline">\(X=\set{\cfrac{1}{n}\mid n\geq 1}\cup
\set{0}\)</span>，则 <span class="math inline">\(\forall x\in
X\)</span>，有 <span class="math inline">\(\set{x}\)</span>
是连通分支，则 <span class="math inline">\(\set{\cfrac{1}{n}}\)</span>
是既开又闭的，但 <span class="math inline">\(\set{0}\)</span>
只是闭集不是开集。</p></li>
</ul>
<h3 id="道路连通-path-connectedness">道路连通 (Path-Connectedness)</h3>
<ul>
<li><h4 id="道路的定义-path">道路的定义 (Path)</h4>
<p>拓扑空间 <span class="math inline">\(X\)</span> 中的<strong>道路
(Path)</strong>为一个连续映射 <span
class="math inline">\(\gamma:[0,1]\to X\)</span>. 将 <span
class="math inline">\(\gamma(0)\)</span> 与 <span
class="math inline">\(\gamma(1)\)</span> 分别叫做道路的<strong>起点
(Beginning Point)</strong>以及<strong>终点(End Point)</strong>。</p>
<p>我们也称 <span class="math inline">\(\gamma\)</span> 是一个连接(join)
<span class="math inline">\(\gamma(0)\)</span> 和 <span
class="math inline">\(\gamma(1)\)</span> 的道路。</p></li>
<li><h4 id="道路连通空间-path-connected-space">道路连通空间
(Path-Connected Space)</h4>
<p>我们称一个空间 <span class="math inline">\(X\)</span>
是<strong>道路连通
(Path-Connected)</strong>的，如果任意两个点都可以被一个道路连接。</p></li>
<li><h4 id="道路连通蕴含连通性">道路连通蕴含连通性</h4>
<p>一个道路连通空间 <span class="math inline">\(X\)</span>
一定是连通的。</p>
<p>证明：假设 <span class="math inline">\(X\)</span> 是道路连通的，令
<span class="math inline">\(\varnothing\neq A\subset X\)</span> 使得
<span class="math inline">\(A\)</span> 既开又闭；假设 <span
class="math inline">\(A\neq X\)</span>.</p>
<p>选取 <span class="math inline">\(x\in A,y\in X\setminus
A\)</span>，我们可以找到道路 <span class="math inline">\(\gamma\)</span>
连接 <span class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span>.</p>
<p>考虑 <span class="math inline">\(\gamma^{-1}(A)\)</span>，它一定是
<span class="math inline">\([0,1]\)</span> 中既开又闭的集合，且 <span
class="math inline">\(\gamma^{-1}(A)\neq\varnothing,\gamma^{-1}(A)\neq
[0,1]\)</span>，这与 <span class="math inline">\([0,1]\)</span>
区间连通矛盾。</p>
<p>因此 <span class="math inline">\(X\)</span> 中既开又闭的集合只有
<span class="math inline">\(X\)</span> 与 <span
class="math inline">\(\varnothing\)</span>，于是 <span
class="math inline">\(X\)</span> 是连通的。</p></li>
<li><h4 id="道路连通分支-path-connected-components">道路连通分支
(Path-Connected Components)</h4>
<p>我们可以定义等价关系 <span class="math inline">\(\forall x,y\in
X\)</span>，定义 <span class="math inline">\(x\sim y\)</span> 若 <span
class="math inline">\(\exists\)</span> 道路 <span
class="math inline">\(\gamma\)</span> 使得 <span
class="math inline">\(\gamma\)</span> 连接了 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span>.</p>
<p>我们把对应的等价类称作是 <span class="math inline">\(X\)</span>
的<strong>道路连通分支 (Path-Connected Components)</strong>.</p>
<ul>
<li><h5 id="注该关系确实是等价关系">注：该关系确实是等价关系</h5>
<p>自反性：令 <span class="math inline">\(\gamma:[0,1]\to
X\)</span>，使得 <span class="math inline">\(\gamma(t)=x,\forall t\in
[0,1]\)</span>，故 <span class="math inline">\(x\sim x\)</span>.</p>
<p>对称性：若 <span class="math inline">\(x\sim y\)</span>，有 <span
class="math inline">\(\exists \gamma\)</span> 道路，使得 <span
class="math inline">\(\gamma(0)=x,\gamma(1)=y\)</span>，则令 <span
class="math inline">\(\alpha:[0,1]\to
X,\alpha(t)=\gamma(1-t)\)</span>，有 <span
class="math inline">\(\alpha\)</span> 连接了 <span
class="math inline">\(y,x\)</span>，故 <span class="math inline">\(y\sim
x\)</span>.</p>
<p>传递性：若 <span class="math inline">\(x\sim y,y\sim
z\)</span>，<span class="math inline">\(\exists
\gamma_1,\gamma_2\)</span> 道路，使得 <span
class="math inline">\(\gamma_1(0)=x,\gamma_1(1)=y,\gamma_2(0)=y,\gamma_2(1)=z\)</span>.</p>
<p>令 <span class="math inline">\(\gamma_3:[0,1]\to X\)</span>，<span
class="math inline">\(\gamma_3(t)=\begin{cases}\gamma_1(2t)&amp;0\leq
t\leq \cfrac{1}{2}\\\gamma_2(2t-1)&amp;\cfrac{1}{2}\leq t\leq
1\end{cases}\)</span>.</p>
<p>容易验证 <span class="math inline">\(\gamma_3\)</span>
是连续的（<span
class="math inline">\([0,\cfrac{1}{2}],[\cfrac{1}{2},1]\)</span> 组成了
<span class="math inline">\([0,1]\)</span>
的闭覆盖，由连续映射的局部性，整体也是连续的）且连接了 <span
class="math inline">\(x,z\)</span>，故 <span class="math inline">\(x\sim
z\)</span>.</p>
<p>注：连续映射的局部性：<span class="math inline">\(f:X\to Y\)</span>
是一个连续映射，如果 <span class="math inline">\(X\)</span>
可以表示成一些闭集 <span class="math inline">\(F_i\)</span> 的并，即
<span class="math inline">\(X=\bigcup_{i=1}^n F_i\)</span>，且 <span
class="math inline">\(f|_{F_i}\)</span> 是连续的。</p></li>
</ul></li>
<li><h4 id="欧氏空间-mathbbrn-中连通开集为道路连通">欧氏空间 <span
class="math inline">\(\mathbb{R}^n\)</span> 中连通开集为道路连通</h4>
<p>考虑欧氏空间 <span class="math inline">\(\mathbb{R}^n\)</span>
中的一个连通开集，该开集一定是道路连通的。</p>
<p>证明：</p>
<p>令 <span class="math inline">\(X\subset \mathbb{R}^n\)</span>
是一个连通开集。我们固定 <span class="math inline">\(x\in X\)</span>，令
<span class="math inline">\(A=\set{y\in X\mid y\text{ 与 }x\text{
间可以被连接道路}}\)</span>；<span class="math inline">\(B=\set{y\in
X\mid y\text{ 与 }x\text{ 间不能被连接道路}}\)</span>。</p>
<p>因此 <span class="math inline">\(A\cap B=\varnothing\)</span>，且
<span class="math inline">\(X=A\cup B\)</span>，且 <span
class="math inline">\(A\neq\varnothing\)</span>。</p>
<p>我们接下来证明 <span class="math inline">\(A,B\)</span> 是开集。<span
class="math inline">\(\forall y\in A\)</span>，我们总可以选取小球 <span
class="math inline">\(B(y,\varepsilon)\)</span>，使得 <span
class="math inline">\(B(y,\varepsilon)\subseteq X\)</span>.</p>
<p>因此 <span class="math inline">\(\forall z\in
B(y,\varepsilon)\)</span>，总可以将 <span
class="math inline">\(z,y\)</span> 间连接一条直线，从而 <span
class="math inline">\(z\)</span> 与 <span
class="math inline">\(y\)</span> 道路连通。</p>
<p>从而 <span class="math inline">\(z\)</span> 可以与 <span
class="math inline">\(x\)</span> 连接道路，于是 <span
class="math inline">\(z\in A\)</span>.</p>
<p>于是 <span class="math inline">\(A\)</span> 是开集。</p>
<p>类似地，<span class="math inline">\(\forall y\in
B\)</span>，我们选取小球 <span
class="math inline">\(B(y,\varepsilon)\subseteq X\)</span>. <span
class="math inline">\(\forall z\in B(y,\varepsilon)\)</span>，则 <span
class="math inline">\(z\)</span> 可以与 <span
class="math inline">\(y\)</span> 之间连接一条线段。</p>
<p>于是 <span class="math inline">\(z\)</span> 与 <span
class="math inline">\(x\)</span> 之间一定不存在道路，否则 <span
class="math inline">\(y\)</span> 与 <span
class="math inline">\(x\)</span> 道路连通。于是 <span
class="math inline">\(z\in B\)</span>.</p>
<p>于是 <span class="math inline">\(B\)</span> 是开集。</p>
<p>于是 <span class="math inline">\(X\)</span> 可以被写成开集 <span
class="math inline">\(A,B\)</span> 的不交并，由于 <span
class="math inline">\(A\)</span> 不为空，<span
class="math inline">\(X\)</span> 连通，有 <span
class="math inline">\(B\)</span> 为空。于是 <span
class="math inline">\(X\)</span> 道路连通。</p></li>
<li><h4
id="反例连通但不道路连通的集合拓扑学家的正弦曲线topologists-sine-curve">反例：连通但不道路连通的集合（拓扑学家的正弦曲线，Topologist's
Sine Curve）</h4>
<p>令 <span class="math inline">\(Y=\set{(0,y)\in \mathbb{R}^2\mid
-1\leq y\leq 1}\)</span>，<span
class="math inline">\(Z=\set{(x,\sin\cfrac{\pi}{x})\in \mathbb{R}^2\mid
0&lt;x\leq 1}\)</span></p>
<p>我们考察 <span class="math inline">\(X=Y\cup Z\)</span>.</p>
<figure>
<img src="\07-4.png" alt="image-20231017165027589" />
<figcaption aria-hidden="true">image-20231017165027589</figcaption>
</figure>
<p>注意到 <span class="math inline">\(Z\)</span> 是连通的，由于 <span
class="math inline">\(Z=f((0,1])\)</span>. <span
class="math inline">\(f(x)=(x,\sin \cfrac{\pi}{x})\)</span>
是一个连续函数，因此 <span class="math inline">\(Z\)</span>
也是连通的，并且 <span class="math inline">\(Z\)</span>
是道路连通的；</p>
<p>与此同时，不难注意到 <span class="math inline">\(Y\)</span>
也是道路连通的，然而 <span class="math inline">\(X=Y\cup Z\)</span>
并非道路连通。</p>
<p>进一步地，考察集合 <span class="math inline">\(Z\)</span>，有 <span
class="math inline">\(X=\overline{Z}\)</span>，有 <span
class="math inline">\(X\)</span> 也是连通，如此我们给出了一个反例。</p>
<p>注意到 <span class="math inline">\(Z\)</span> 和 <span
class="math inline">\(Y\)</span> 即为 <span
class="math inline">\(X\)</span>
的道路连通分支，这也告诉我们道路连通分支未必是闭集。</p></li>
</ul>
<h2 id="粘合空间">08. 粘合空间</h2>
<h3 id="粘合空间-identification-spaces">粘合空间 (Identification
Spaces)</h3>
<ul>
<li><h4 id="一些简单的例子">一些简单的例子</h4>
<p>考虑一个圆柱面。<span class="math inline">\(x^2+y^2=1,0\leq z\leq
1,(x,y,z)\in\mathbb{R}^3\)</span></p>
<figure>
<img src="\08-1.png" alt="image-20231019095324060" />
<figcaption aria-hidden="true">image-20231019095324060</figcaption>
</figure>
<p>这是圆柱面嵌入到欧氏空间的定义。</p>
<figure>
<img src="\08-2.png" alt="image-20231019095424999" />
<figcaption aria-hidden="true">image-20231019095424999</figcaption>
</figure>
<p>考虑将矩形粘合到一起，这也形成了一个圆柱面。</p>
<p>两个圆柱面呈现出什么样的关系呢？我们来研究它们的拓扑结构。不妨来考察圆柱面里的开集，在拉回矩形后就是矩形中的一个小圆形。这意味着圆柱面里的开集在拉回到矩形后仍然是一个开集。</p>
<figure>
<img src="\08-3.png" alt="image-20231019095619549" />
<figcaption aria-hidden="true">image-20231019095619549</figcaption>
</figure>
<p>接下来我们考察另一个例子：<strong>环面 (Torus)</strong>。<span
class="math inline">\(X\subseteq \mathbb{R}^3\)</span></p>
<figure>
<img src="\08-4.png" alt="image-20231019095744764" />
<figcaption aria-hidden="true">image-20231019095744764</figcaption>
</figure>
<p>能从矩形中构造出环面吗？当然可以。</p>
<figure>
<img src="\08-5.png" alt="image-20231019095852987" />
<figcaption aria-hidden="true">image-20231019095852987</figcaption>
</figure>
<p>像是把圆柱面的两头粘在了一起，确实得出了环面。</p>
<p>我们还是来考虑拓扑结构，如下图所示。</p>
<figure>
<img src="\08-6.png" alt="image-20231019100024280" />
<figcaption aria-hidden="true">image-20231019100024280</figcaption>
</figure>
<p>此图给出了特殊点的对应关系。（对不起！红绿色盲）</p>
<figure>
<img src="\08-7.png" alt="image-20231019100139410" />
<figcaption aria-hidden="true">image-20231019100139410</figcaption>
</figure>
<p>跟圆柱的情形类似，环面的开集拉回矩形后也是开集。</p>
<p>我们将会看到越来越复杂的例子，这会逐渐体现粘合观点的优越性。</p>
<p>我们来看下一个例子：</p>
<figure>
<img src="\08-8.png" alt="image-20231019100338726" />
<figcaption aria-hidden="true">image-20231019100338726</figcaption>
</figure>
<p>图中是一根<strong>莫比乌斯带 (Mobius Strip)</strong>。<span
class="math inline">\(X\subseteq \mathbb{R}^3\)</span>.</p>
<p>这个图形也可以从矩形粘合得来：</p>
<figure>
<img src="\08-9.png" alt="image-20231019100510774" />
<figcaption aria-hidden="true">image-20231019100510774</figcaption>
</figure>
<figure>
<img src="\08-10.png" alt="image-20231019100533762" />
<figcaption aria-hidden="true">image-20231019100533762</figcaption>
</figure>
<p>下图给出了它们拓扑结构的关系：</p>
<figure>
<img src="\08-11.png" alt="image-20231019100649318" />
<figcaption aria-hidden="true">image-20231019100649318</figcaption>
</figure>
<p>需要注意粘合方法导致两侧半圆不“水平”。</p>
<p>接着来看一个更复杂的例子：</p>
<figure>
<img src="\08-12.png" alt="image-20231019100755532" />
<figcaption aria-hidden="true">image-20231019100755532</figcaption>
</figure>
<p>可以考虑先粘上下两边，这得到了一个圆柱面。</p>
<p>粘合左右两边变得没有那么好想象了，下面有一个示意图：</p>
<figure>
<img src="\08-13.png" alt="image-20231019101107322" />
<figcaption aria-hidden="true">image-20231019101107322</figcaption>
</figure>
<p>这被称作<strong>克莱因瓶 (Klein
Bottle)</strong>，这个物体不能嵌入欧氏空间。（这个物体事实上可以嵌入四维空间）</p>
<p>最后我们再来看一个例子：</p>
<figure>
<img src="\08-14.png" alt="image-20231019101249560" />
<figcaption aria-hidden="true">image-20231019101249560</figcaption>
</figure>
<p>这个物体的示意图变得不那么好画了，但该空间非常重要，我们将它称为
<span class="math inline">\(\mathbb{R}P^2\)</span>
拓扑，<strong>实射影平面 (Real Projective Plane)</strong>.</p>
<p>应该怎么更好地理解它呢？不妨把矩形看作圆盘。</p>
<figure>
<img src="\08-15.png" alt="image-20231019101513763" />
<figcaption aria-hidden="true">image-20231019101513763</figcaption>
</figure>
<p>考察圆盘 <span class="math inline">\(B=\set{(x,y)\mid x^2+y^2\leq
1}\)</span></p>
<p>圆周 <span class="math inline">\(S^1=\partial B=\set{(x,y)\mid
x^2+y^2=1}\)</span></p>
<p>如何理解上述定义呢？上面的粘合操作等价于，我们将所有的对径点 <span
class="math inline">\(P\)</span> 与 <span
class="math inline">\(-P\)</span> 粘合起来 <span
class="math inline">\(\forall P\in S^1\)</span>.</p>
<figure>
<img src="\08-16.png" alt="image-20231019101648081" />
<figcaption aria-hidden="true">image-20231019101648081</figcaption>
</figure>
<p>从代数几何视角上看，前两个空间（圆柱、圆环）是可定向曲面，而最后三个空间（莫比乌斯带、克莱因瓶、实射影平面）都是不可定向的。</p>
<p>直观上看，一个可定向的空间可以分出“里面”与“外面”的概念。</p></li>
<li><h4
id="粘合拓扑与粘合空间的定义-identification-topology-space">粘合拓扑与粘合空间的定义
(Identification Topology / Space)</h4>
<p>令 <span class="math inline">\(X\)</span> 是一个拓扑空间，且 <span
class="math inline">\(X=\bigsqcup_{i\in I}P_i\)</span> 给出了 <span
class="math inline">\(X\)</span> 的一个分划（集合的不交并）。令 <span
class="math inline">\(Y=\set{P_i\mid i\in I}\)</span>，令 <span
class="math inline">\(\pi:X\to Y\)</span>，其中 <span
class="math inline">\(\pi(x)=P_i\text{ if } x\in P_i\)</span> .</p>
<p>我们在 <span class="math inline">\(Y\)</span> 上装备拓扑，使得 <span
class="math inline">\(U\subseteq Y\)</span> 是开集当且仅当 <span
class="math inline">\(\pi^{-1}(U)\)</span> 在 <span
class="math inline">\(X\)</span> 中是开集。我们将 <span
class="math inline">\(Y\)</span> 上的拓扑称为是<strong>粘合拓扑
(Identification Topology)</strong>，将 <span
class="math inline">\(Y\)</span> 称为对应于分划 <span
class="math inline">\(\bigsqcup_{i\in I}P_i\)</span> 的<strong>粘合空间
(Identification Space)</strong>。</p></li>
<li><h4 id="以粘合空间重述上面例子">以粘合空间重述上面例子</h4>
<p>例：考察将矩形粘合成为圆柱面。</p>
<p>将矩形参数化：<span class="math inline">\(X=\set{(x,y)\mid 0\leq
x\leq 1,0\leq y\leq 1}\)</span>, <span
class="math inline">\(Y=\text{圆柱}\)</span>.</p>
<p>则 <span class="math inline">\(Y\)</span> 中的点对应 <span
class="math inline">\(\set{(x,y)}\)</span> 单点 <span
class="math inline">\((0&lt;x&lt;1)\)</span> 或 <span
class="math inline">\(\set{(0,y),(1,y)}\)</span> 这一子集 <span
class="math inline">\((0\leq y\leq
1)\)</span>（直观上看，此时点落在“粘合线”上。</p></li>
<li><h4
id="粘合空间的泛型-universal-property-of-identification-space">粘合空间的泛型
(Universal Property of Identification Space)</h4>
<p>令 <span class="math inline">\(Y\)</span> 是一个粘合空间，<span
class="math inline">\(\pi:X\to Y\)</span> 是一个粘合映射。令 <span
class="math inline">\(Z\)</span> 是另一个拓扑空间。则映射 <span
class="math inline">\(f:Y\to Z\)</span> 是连续的，当且仅当 <span
class="math inline">\(f\circ \pi:X\to Z\)</span> 是连续的。</p>
<figure>
<img src="\08-17.png" alt="image-20231019103216401" />
<figcaption aria-hidden="true">image-20231019103216401</figcaption>
</figure>
<p>如图所示，中间的圆圈形箭头意味着这是一张“交换图表”。</p>
<p>证明：</p>
<p>根据粘合空间的定义，<span class="math inline">\(U\subseteq Z\)</span>
是开集，考虑 <span class="math inline">\(f^{-1}(U)\subseteq
Y\)</span>，这个集合是开集当且仅当 <span
class="math inline">\(\pi^{-1}\circ f^{-1}(U)=(f\circ
\pi)^{-1}(U)\)</span> 在 <span class="math inline">\(X\)</span>
中是开集，故定理成立。</p>
<p>这个定理意味着，尽管 <span class="math inline">\(Y\)</span>
经过粘合后往往是个相当复杂的空间，为了判断连续性，我们可以将点“拉回”
<span class="math inline">\(X\)</span> 中再去判断。</p></li>
<li><h4 id="粘合映射-identification-map">粘合映射 (Identification
Map)</h4>
<p>令 <span class="math inline">\(f:X\to Y\)</span> 是一个连续满射。假设
<span class="math inline">\(U\subseteq Y\)</span> 是开的当且仅当 <span
class="math inline">\(f^{-1}(U)\subset X\)</span> 是开的，则我们称 <span
class="math inline">\(f\)</span> 是一个<strong>粘合映射 (Identification
Map)</strong>。</p>
<ul>
<li><h5 id="注由粘合映射导出粘合空间">注：由粘合映射导出粘合空间</h5>
<p>考虑 <span class="math inline">\(X=\bigsqcup_{y\in
Y}f^{-1}(y)\)</span>，令 <span class="math inline">\(Y_\star\)</span>
是一个对应于这个分划的粘合空间。于是考虑映射 <span
class="math inline">\(h:Y_\star\to Y\)</span>，<span
class="math inline">\(h(\set{f^{-1}(y)})=y\)</span>.</p>
<p>有 <span class="math inline">\(h\)</span>
是一个双射，根据先前粘合映射的定义，我们有 <span
class="math inline">\(h\)</span>
是一个同胚。并且我们有一个交换图表：</p>
<figure>
<img src="\08-18.png" alt="image-20231019104700052" />
<figcaption aria-hidden="true">image-20231019104700052</figcaption>
</figure></li>
</ul></li>
<li><h4 id="粘合映射的刻画">粘合映射的刻画</h4>
<p>令 <span class="math inline">\(f:X\to Y\)</span> 是连续满射，若 <span
class="math inline">\(f\)</span> 把 <span
class="math inline">\(X\)</span> 中开集映射为 <span
class="math inline">\(Y\)</span> 中开集 (开映射，Open Map)，或者 <span
class="math inline">\(f\)</span> 把 <span
class="math inline">\(X\)</span> 中闭集映射为 <span
class="math inline">\(Y\)</span> 中闭集 (闭映射，Close Map)，则 <span
class="math inline">\(f\)</span> 是一个粘合映射。</p>
<p>证明：</p>
<p>若 <span class="math inline">\(f\)</span> 是开映射，令 <span
class="math inline">\(U\)</span> 是 <span
class="math inline">\(Y\)</span> 中集合使得 <span
class="math inline">\(f^{-1}(U)\subseteq X\)</span> 是开集。由于 <span
class="math inline">\(f\)</span> 是一个满射，于是 <span
class="math inline">\(f(f^{-1}(U))=U\)</span>，于是 <span
class="math inline">\(U\)</span> 是 <span
class="math inline">\(Y\)</span> 中开集。于是 <span
class="math inline">\(U\)</span> 在 <span
class="math inline">\(Y\)</span> 中是开集当且仅当 <span
class="math inline">\(f^{-1}(U)\)</span> 在 <span
class="math inline">\(X\)</span> 中是开集。故 <span
class="math inline">\(f\)</span> 确实是粘合映射。</p>
<p>若 <span class="math inline">\(f\)</span>
是闭映射，证明是类似的。</p>
<ul>
<li><h5 id="定理的推论">定理的推论</h5>
<p>考虑映射 <span class="math inline">\(f:X\to Y\)</span>
是连续满射，假设 <span class="math inline">\(X\)</span> 是紧空间，假设
<span class="math inline">\(Y\)</span> 是 Hausdorff 空间，则 <span
class="math inline">\(f\)</span> 是一个粘合映射。</p>
<p>证明：</p>
<p>令 <span class="math inline">\(A \subseteq X\)</span> 是闭集，有
<span class="math inline">\(A\)</span> 是一个紧集。于是 <span
class="math inline">\(f(A)\)</span> 在 <span
class="math inline">\(Y\)</span> 中也是紧集，由于 <span
class="math inline">\(Y\)</span> 是 Hausdorff 空间，因此 <span
class="math inline">\(f(A)\)</span> 在 <span
class="math inline">\(Y\)</span> 中是闭集，因此 <span
class="math inline">\(f\)</span> 是一个闭映射。</p>
<p>于是 <span class="math inline">\(f\)</span> 是粘合映射。</p></li>
</ul></li>
<li><h4
id="连续映射局部性质的推广-generalizatio-of-local-formulation-of-continuity">连续映射局部性质的推广
(Generalizatio of local formulation of continuity)</h4>
<p>回忆：连续映射的局部刻画：</p>
<ol type="1">
<li><p><span class="math inline">\(f:X\to Y\)</span>
是一个连续映射，如果 <span class="math inline">\(X\)</span>
可以被一些开集 <span class="math inline">\(U_\alpha\)</span> 覆盖，即
<span class="math inline">\(X=\bigcup_\alpha U_\alpha\)</span>，使得
<span class="math inline">\(f|_{U_\alpha}\)</span> 是连续的。</p></li>
<li><p><span class="math inline">\(f:X\to Y\)</span>
是一个连续映射，如果 <span class="math inline">\(X\)</span>
可以表示成一些闭集 <span class="math inline">\(F_i\)</span> 的并，即
<span class="math inline">\(X=\bigcup_{i=1}^n F_i\)</span>，且 <span
class="math inline">\(f|_{F_i}\)</span> 是连续的。</p></li>
</ol>
<p>有了粘合映射的概念后，我们可以如下推广此定理：</p>
<p>令 <span class="math inline">\(X=\bigcup_{\alpha\in I}
X_\alpha\)</span>，令 <span class="math inline">\(\tilde
X=\bigsqcup_{\alpha\in I}X_\alpha\)</span></p>
<figure>
<img src="\08-19.png" alt="image-20231019110123256" />
<figcaption aria-hidden="true">image-20231019110123256</figcaption>
</figure>
<figure>
<img src="\08-20.png" alt="image-20231019111152490" />
<figcaption aria-hidden="true">image-20231019111152490</figcaption>
</figure>
<p>这事实上是将重复元素”复制”了一份，或者可以记作 <span
class="math inline">\(\tilde X=\set{(x,\alpha)\mid \alpha\in I,x\in
X_\alpha}\)</span>.</p>
<p>在 <span class="math inline">\(\tilde X\)</span> 中装备拓扑：<span
class="math inline">\(U\subseteq \tilde X\)</span> 是开集，当且仅当
<span class="math inline">\(U\cap X_{\alpha}\)</span> 是开的，<span
class="math inline">\(\forall \alpha\)</span>。在这里定义的后半段，<span
class="math inline">\(U\)</span>
中的“被复制出的”点又被视为相同点了，或者可以把 <span
class="math inline">\(X_\alpha\)</span> 视为 <span
class="math inline">\(\set{(x,\alpha)\mid x\in X_\alpha}\)</span>。</p>
<p>从而我们定义出了一个新的拓扑空间。</p>
<p>我们令 <span class="math inline">\(j:\tilde X\to X\)</span> 是一个
Canonical Map（<span
class="math inline">\(j|_{X_\alpha}:X_{\alpha}\text{ 嵌入映射
}X\)</span>），则有如下定理：</p>
<p>考虑映射 <span class="math inline">\(f:X\to Y\)</span> 使得 <span
class="math inline">\(f|_{X_\alpha}\)</span> 是连续的，假设 <span
class="math inline">\(j:\tilde X\to X\)</span> 是一个粘合映射，则 <span
class="math inline">\(f\)</span> 是一个连续映射。</p>
<p>证明：</p>
<p>由于 <span class="math inline">\(j\)</span> 是粘合映射，<span
class="math inline">\(f\)</span> 是连续的当且仅当 <span
class="math inline">\(f\circ j\)</span> 是连续的。这当且仅当 <span
class="math inline">\(f\circ j|_{X_\alpha}\)</span>
是连续的，由上述拓扑空间开集的定义易知其成立。</p>
<ul>
<li><h5 id="注定理推广的方式">注：定理推广的方式</h5>
考虑 <span class="math inline">\(X=\bigcup_{\alpha} U_\alpha\)</span>
开或 <span class="math inline">\(X=\bigcup_{i=1}^n F_i\)</span> 闭，则
<span class="math inline">\(j:\tilde X\to X\)</span> 都是粘合映射（<span
class="math inline">\(j\)</span> 是开映射或闭映射）</li>
</ul></li>
<li><h4 id="粘合映射的例子">粘合映射的例子</h4>
<ul>
<li><p><strong>闭圆盘的粘合</strong></p>
<p>考虑<strong>圆盘 Disk</strong> <span
class="math inline">\(B^2=\set{(x,y)\mid x^2+y^2\leq 1}\)</span>，<span
class="math inline">\(S^1=\set{(x,y)\mid x^2+y^2=1}\)</span>.</p>
<p>考虑粘合映射 <span class="math inline">\(B^2\to X\)</span>
使得该映射把边界圆周 <span class="math inline">\(S^1\)</span>
粘合成了一个点。<span class="math inline">\(X=\set{(x,y)\mid
x^2+y^2&lt;1}\cup\set{S^1}\)</span>.</p>
<p>我们将 <span class="math inline">\(X\)</span> 记作 <span
class="math inline">\(B^2/S^1\)</span>（商空间），则 <span
class="math inline">\(X\)</span> 同胚于球面 <span
class="math inline">\(S^2=\set{(x,y,z)\mid x^2+y^2+z^2=1}\)</span>.</p>
<p>更一般地，考虑 <span
class="math inline">\(B^n/S^{n-1}\)</span>，这是一个粘合空间使得它将边界球面粘合成了一个点（<span
class="math inline">\(B^n=\set{x\in \mathbb{R}^n\mid |x|\leq
1},B^n\supseteq S^{n-1}=\set{x\in \mathbb{R}^{n}\mid
|x|=1}\)</span>），则该空间同胚于 <span
class="math inline">\(S^n\)</span>.</p>
<p>提示：考虑集合 <span class="math inline">\(B^n\setminus
S^{n-1}\)</span>，该集合同胚于 <span
class="math inline">\(\mathbb{R}^n\)</span>. 又考虑 <span
class="math inline">\(S^n\setminus \set{p_t}\)</span>，其中 <span
class="math inline">\(p_t\)</span> 是 <span
class="math inline">\(S^n\)</span> 中任意一点，那么这个集合也同胚于
<span class="math inline">\(\mathbb{R}^n\)</span>. （球极投影）也就是
<span class="math inline">\(B^n\setminus S^{n-1}\cong \mathbb{R}^n\cong
S^n\setminus \set{p_t}\)</span>.</p></li>
<li><h5 id="射影空间-projective-space">射影空间 (Projective Space)</h5>
<p>我们给出三种构造来构造 <span class="math inline">\(n\)</span>
维的实射影空间 <span class="math inline">\(\mathbb R
P^n\)</span>，今天我们现在只介绍其中两种：</p>
<p>令 <span class="math inline">\(S^n=\set{x\in \mathbb R^{n+1}\mid
|x|=1}\subseteq \mathbb{R}^{n+1}\)</span> 是单位球面，将 <span
class="math inline">\(\mathbb{R}P^n\)</span>
定义为粘合空间，它粘合了球面上所有的对径点（也就是把所有 <span
class="math inline">\(x,-x,\forall x\in S^n\)</span> 进行粘合）。</p>
<p>以这种方法构造的粘合空间称作 <span
class="math inline">\(\mathbb{R}P^n\)</span>（<span
class="math inline">\(\mathbb{R}P^n=\set{S^n \text{
中对径点点对构成的集合}}\)</span>）。</p>
<p>将 <span class="math inline">\(\mathbb RP^n\)</span>
定义为粘合空间，定义 <span
class="math inline">\(\mathbb{R}^{n+1}\setminus\set{0}\)</span>
的一个粘合，我们将所有在同一条通过原点直线上的点粘合在一起，将这个空间称作实射影空间。</p>
<p>如图所示：</p>
<figure>
<img src="\08-21.png" alt="image-20231019112622930" />
<figcaption aria-hidden="true">image-20231019112622930</figcaption>
</figure></li>
</ul></li>
</ul>
<h2 id="拓扑群与矩阵拓扑群">09. 拓扑群与矩阵拓扑群</h2>
<h3 id="实射影空间-real-project-space">实射影空间 (Real Project
Space)</h3>
<ul>
<li><h4 id="三种构造方法">三种构造方法</h4>
<ol type="1">
<li>通过将 <span class="math inline">\(x\)</span> 与 <span
class="math inline">\(-x\)</span> 粘在一起构造一个粘合空间，<span
class="math inline">\(\forall x\in S^n\)</span>；</li>
<li><span
class="math inline">\(\mathbb{R}^{n+1}\setminus\set{0}\)</span>
中所有在过原点的同一直线上的点粘合在一起构造一个粘合空间；</li>
<li>令 <span class="math inline">\(B^n\)</span> 是 <span
class="math inline">\(n\)</span>
维的单位球，考虑其边界球面，将其对径点粘合在一起，也能构造出实射影空间。（上节课一开始介绍的构造方法）</li>
</ol>
<figure>
<img src="\09-1.png" alt="image-20231024152635956" />
<figcaption aria-hidden="true">image-20231024152635956</figcaption>
</figure>
<p>方法 3 的解释：图中图形同胚于一个 <span
class="math inline">\(n+1\)</span>
维半球面，黄色区域可以看成是半球的赤道。</p>
<figure>
<img src="\09-2.png" alt="image-20231024152831378" />
<figcaption aria-hidden="true">image-20231024152831378</figcaption>
</figure>
<p>可以看成是上下半球面先粘合，再粘合赤道的对径点。因此方法 3
从直观上看是与方法 1 等价的。</p></li>
<li><h4
id="第二种构造方法的推广复射影平面">第二种构造方法的推广：复射影平面</h4>
<p>注意到第二种构造方法事实上在 <span
class="math inline">\(\mathbb{C}^n\)</span> 中也适用，我们将其称之为
<span class="math inline">\(\mathbb{C}P^n\)</span>.</p>
<p>考虑粘合空间：<span
class="math inline">\(\mathbb{C}^{n+1}\setminus\set{0}\)</span>
中将所有落在同一一维包含原点的线性子空间中的点粘合在一起，则这构成了一个粘合空间，这就构造出了
<span class="math inline">\(\mathbb{C}P^n\)</span>.</p></li>
</ul>
<h3 id="粘合空间的构造">粘合空间的构造</h3>
<ul>
<li><h4 id="锥的构造-cone">锥的构造 (Cone)</h4>
<p>令 <span class="math inline">\(X\)</span> 是一个拓扑空间，令 <span
class="math inline">\(I=[0,1]\)</span>. 令 <span
class="math inline">\(CX=(X\times I) / (X\times \set{1})\)</span>
是粘合空间，在这个空间中将子空间 <span class="math inline">\(X\times
\set{1}\)</span> 粘合成一点，我们将 <span
class="math inline">\(CX\)</span> 称作一个<strong>锥
(Cone)</strong>.</p>
<figure>
<img src="\09-3.png" alt="image-20231024153604990" />
<figcaption aria-hidden="true">image-20231024153604990</figcaption>
</figure></li>
<li><h4 id="suspension">Suspension</h4>
<p>令 <span class="math inline">\(X\)</span> 是一个拓扑空间，<span
class="math inline">\(I=[0,1]\)</span>. <span
class="math inline">\(SX\)</span> 是将 <span
class="math inline">\(X\times I\)</span> 中 <span
class="math inline">\(X\times \set{0}\)</span> 与 <span
class="math inline">\(X\times \set{1}\)</span>
分别粘合后形成的粘合空间。这被称之为 <strong>Suspension</strong>.</p>
<figure>
<img src="\09-4.png" alt="image-20231024153816133" />
<figcaption aria-hidden="true">image-20231024153816133</figcaption>
</figure></li>
<li><h4 id="wedge-sum">Wedge Sum</h4>
<p>令 <span class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span> 是两个拓扑空间。令 <span
class="math inline">\(x_0\in X,y_0\in Y\)</span>，在 <span
class="math inline">\(X\sqcup Y\)</span> 中进行粘合，将 <span
class="math inline">\(x_0\)</span> 与 <span
class="math inline">\(y_0\)</span> 粘合成一个单点，所得到的空间称之为
<span class="math inline">\(X\)</span> 与 <span
class="math inline">\(Y\)</span> 的 <strong>Wedge Sum</strong>，记作
<span class="math inline">\(X\vee Y\)</span>.</p>
<figure>
<img src="\09-5.png" alt="image-20231024154148153" />
<figcaption aria-hidden="true">image-20231024154148153</figcaption>
</figure></li>
<li><h4 id="attaching-maps">Attaching Maps</h4>
<p>令 <span class="math inline">\(A\subset Y\)</span>
是一个子空间，<span class="math inline">\(f:A\to X\)</span>
是一个连续映射。我们如此构造一个粘合空间：考虑粘合空间，在 <span
class="math inline">\(X\sqcup Y\)</span> 中进行粘合，粘合的方式为将
<span class="math inline">\(a\)</span> 与 <span
class="math inline">\(f(a)\)</span> 粘合起来，<span
class="math inline">\(\forall a\in A\)</span>.</p>
<p>这样得出的空间记作 <span class="math inline">\(X\cup_{f}
Y\)</span>，将 <span class="math inline">\(f\)</span> 称作
<strong>Attaching Map</strong>.</p>
<figure>
<img src="\09-6.png" alt="image-20231024154634245" />
<figcaption aria-hidden="true">image-20231024154634245</figcaption>
</figure></li>
<li><h4 id="映射锥-mapping-cones">映射锥 (Mapping Cones)</h4>
<p>令 <span class="math inline">\(f:X\to Y\)</span>
是一个映射，<strong>映射锥 (Mapping Cone)</strong> 即为 <span
class="math inline">\(C_f=Y\cup_f CX\)</span>. 具体来说，我们将 <span
class="math inline">\(X\times \set{0}\subseteq (X\times I) / (X\times
\set{1})=CX\)</span> 看作一个子空间并用 <span
class="math inline">\(f\)</span> 将其映射至 <span
class="math inline">\(Y\)</span>. 接着应用 Attaching Map
将两个空间粘合在一起。</p>
<figure>
<img src="\09-7.png" alt="image-20231024155021747" />
<figcaption aria-hidden="true">image-20231024155021747</figcaption>
</figure></li>
</ul>
<h3 id="拓扑群-topological-group">拓扑群 (Topological Group)</h3>
<ul>
<li><h4 id="回忆群">回忆：群</h4>
<p>令 <span class="math inline">\(G\)</span>
是一个群，则我们可以给出两个结构映射：乘法：<span
class="math inline">\(m:G\times G\to G\)</span>（有时记为 <span
class="math inline">\((g_1,g_2)\to g_1\cdot g_2\)</span>）；取逆：<span
class="math inline">\(i:G\to G\)</span>（记作 <span
class="math inline">\(g^{-1}\)</span>）.</p>
<p>该两种运算满足一些性质。</p></li>
<li><h4 id="定义拓扑群-topological-group">定义：拓扑群 (Topological
Group)</h4>
<p>定义：一个拓扑群 <span class="math inline">\(G\)</span> 既是一个
Hausdorff 的拓扑空间，也是一个群结构，使得两个结构映射 <span
class="math inline">\(m\)</span> 与 <span
class="math inline">\(i\)</span>
均为连续映射，则我们称其为一个<strong>拓扑群 (Topological
Group)</strong></p></li>
<li><h4 id="拓扑群的基本概念">拓扑群的基本概念</h4>
<ul>
<li><h5 id="拓扑群的同构-isomorphism">拓扑群的同构 (Isomorphism)</h5>
<p>令 <span class="math inline">\(G_1,G_2\)</span>
是两个拓扑群，一个映射 <span class="math inline">\(f:G_1\to G_2\)</span>
被称为是一个<strong>同构 (Isomorphism)</strong>若 <span
class="math inline">\(f\)</span> 是一个同胚且 <span
class="math inline">\(f\)</span> 是群之间的同构。</p></li>
<li><h5 id="子群-subgroup">子群 (Subgroup)</h5>
<p>令 <span class="math inline">\(G\)</span> 是一个拓扑群，考虑 <span
class="math inline">\(H\subseteq G\)</span> 是一个子群，我们将 <span
class="math inline">\(H\)</span> 装备上 <span
class="math inline">\(G\)</span> 的子空间拓扑后，<span
class="math inline">\(H\)</span> 也是一个拓扑群，称为 <span
class="math inline">\(G\)</span> 的一个<strong>子群
(Subgroup)</strong>.</p></li>
</ul></li>
<li><h4 id="常见的拓扑群">常见的拓扑群</h4>
<p>向量空间 <span class="math inline">\((\mathbb{R}^n,+)\)</span>
在欧氏拓扑下构成一个拓扑群。</p>
<p>考虑 <span class="math inline">\(S^1=\set{e^{2\pi i\theta}\mid 0\leq
\theta&lt;1}\)</span>，则 <span class="math inline">\(S^1\)</span>
在乘法下形成一个拓扑群。</p>
<p>令 <span class="math inline">\(T\)</span> 是环面，则若将环面理解为
<span class="math inline">\(T=S^1\times S^1\)</span>，则 <span
class="math inline">\(T\)</span> 也是拓扑群。</p>
<figure>
<img src="\09-8.png" alt="image-20231024160310152" />
<figcaption aria-hidden="true">image-20231024160310152</figcaption>
</figure>
<p><span class="math inline">\(GL(n,\mathbb{R})\)</span>
(可逆矩阵群)、<span class="math inline">\(SL(n,\mathbb{R})\)</span>
(行列式为 <span class="math inline">\(1\)</span> 矩阵群)、<span
class="math inline">\(O(n)\)</span> (正交矩阵群)、 <span
class="math inline">\(SO(n)\)</span> (行列式为 1 的正交矩阵群)
都构成拓扑群（这将在之后展开研究）。</p></li>
<li><h4
id="拓扑群的对称性左平移映射与右平移映射">拓扑群的对称性：左平移映射与右平移映射</h4>
<p>令 <span class="math inline">\(G\)</span> 是一个拓扑群，选取任意
<span class="math inline">\(x\in G\)</span>，定义映射 <span
class="math inline">\(L_x:G\to G\)</span> 为 <span
class="math inline">\(L_x(g)=x\cdot g\)</span>.
我们将这个映射称为左平移映射。</p>
<p>我们容易发现 <span class="math inline">\(L_x\)</span> 是一个双射，且
<span class="math inline">\(L_x\)</span>
需要是一个连续映射（这是连续映射的复合：<span class="math inline">\(G\to
G\times G\xrightarrow{m} G:g\to (x,g)\to x\cdot g\)</span>）。</p>
<p>并且我们会发现 <span class="math inline">\(L_{x^{-1}}\)</span>
也是连续的并且 <span
class="math inline">\(L_x^{-1}=L_{x^{-1}}\)</span>，因此 <span
class="math inline">\(L_x\)</span> 是一个同胚。（事实上，<span
class="math inline">\(L_{x_1x_2}=L_{x_1}\circ L_{x_2}\)</span>，<span
class="math inline">\(L_e=id_G\)</span>）</p>
<p>这告诉我们拓扑群具有高度对称性，我们可以通过同胚映射将任意一个点映射到任意另一个点。</p>
<p>我们也可以定义出右平移映射：<span class="math inline">\(R_x:G\to
G,\)</span> <span class="math inline">\(R_x(g)=g\cdot x\)</span>.
类似地也有右平移也是一个同胚映射，且有 <span
class="math inline">\(R_{x_1x_2}=R_{x_2}\circ R_{x_1}\)</span>，<span
class="math inline">\(R_e=id_G\)</span>.</p></li>
<li><h4
id="拓扑群中包含单位元的连通分支是正规子群">拓扑群中包含单位元的连通分支是正规子群</h4>
<p>令 <span class="math inline">\(G\)</span> 是一个拓扑群，令 <span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(G\)</span> 中一个连通分支，使得恒等元 <span
class="math inline">\(e\in K\)</span>。则 <span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(G\)</span> 中一个闭的正规子群。</p>
<p>回忆：正规子群的定义：若 <span class="math inline">\(H\leq
G\)</span>，有 <span class="math inline">\(\forall g\in G\)</span>,
<span class="math inline">\(gH=Hg\)</span>，则称 <span
class="math inline">\(H\)</span> 是 <span
class="math inline">\(G\)</span> 的一个<strong>正规子群</strong>，记作
<span class="math inline">\(H\vartriangleleft G\)</span>.</p>
<p>正规子群的判别：<span class="math inline">\(\forall g\in
G,g^{-1}Hg\subset H\Rightarrow H\vartriangleleft G\)</span>.</p>
<p>证明：</p>
<p>因为 <span class="math inline">\(K\)</span> 是连通分支，因此 <span
class="math inline">\(K\)</span> 是闭集。</p>
<p><span class="math inline">\(\forall x\in K\)</span>，考察 <span
class="math inline">\(Kx^{-1}=R_{x^{-1}}(K)\)</span>，这是一个连通集合，并且该集合一定会包含恒等元
<span class="math inline">\(e\)</span>（这是因为 <span
class="math inline">\(x\in K\)</span>）. 因此 <span
class="math inline">\(Kx^{-1}\subseteq K\)</span> （由于 <span
class="math inline">\(K\)</span> 的极大性）.因此 <span
class="math inline">\(K\)</span> 确实是 <span
class="math inline">\(G\)</span> 的子群。</p>
<p>来验证正规性：<span class="math inline">\(\forall g\in
G\)</span>，考察 <span class="math inline">\(gKg^{-1}\)</span>，这即是
<span class="math inline">\(R_{g^{-1}}\circ L_{g}(K)\)</span>.
不难发现这个集合连通且包含了单元元 <span
class="math inline">\(e\)</span>，因此 <span
class="math inline">\(gKg^{-1}\subseteq K\)</span>，因此 <span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(G\)</span> 的正规子群。</p></li>
<li><h4
id="连通拓扑群中包含单位元的邻域形成生成元">连通拓扑群中包含单位元的邻域形成生成元</h4>
<p>考虑一个连通的拓扑群 <span class="math inline">\(G\)</span>
与任意一个恒等元 <span class="math inline">\(e\)</span>
的邻域，则该邻域包含的元素形成了一组 <span
class="math inline">\(G\)</span> 的生成元。</p>
<p>证明：</p>
<p>令 <span class="math inline">\(e\in U\subseteq G\)</span>，其中 <span
class="math inline">\(U\)</span> 为开。令 <span
class="math inline">\(K=&lt;U&gt;\)</span>.</p>
<p><span class="math inline">\(\forall g\in K\)</span>，<span
class="math inline">\(gU=L_g(U)\subseteq K\)</span>. 由于 <span
class="math inline">\(L_g\)</span> 是一个同胚，有 <span
class="math inline">\(L_g(U)\)</span> 是一个 <span
class="math inline">\(g\)</span> 的邻域。因此 <span
class="math inline">\(K\)</span> 是一个开集。</p>
<p>考察 <span class="math inline">\(\forall g\in G\setminus
K\)</span>，考虑 <span class="math inline">\(gU\)</span>，假设 <span
class="math inline">\(gU\cap K\neq \varnothing\)</span>，则令 <span
class="math inline">\(h\in gU\cap K\)</span>，<span
class="math inline">\(\exists g&#39;\in U\)</span>，有 <span
class="math inline">\(gg&#39;=h\)</span>. 于是 <span
class="math inline">\(g=hg&#39;^{-1}\in K\)</span>，矛盾。</p>
<p>因而 <span class="math inline">\(gU\)</span> 是 <span
class="math inline">\(g\)</span> 的邻域且 <span
class="math inline">\(gU\subseteq G\setminus K\)</span>，因此 <span
class="math inline">\(G\setminus K\)</span> 是开集。</p>
<p>由于 <span class="math inline">\(K\)</span> 是非空集合，<span
class="math inline">\(K\)</span> 与 <span
class="math inline">\(G\setminus K\)</span> 均为开集，<span
class="math inline">\(G\)</span> 为连通而 <span
class="math inline">\(G=K\sqcup (G\setminus K)\)</span>，有 <span
class="math inline">\(G\setminus K=\varnothing\)</span>. 因此 <span
class="math inline">\(K=G=&lt;U&gt;\)</span>.</p></li>
</ul>
<h3 id="矩阵群-matrix-groups">矩阵群 (Matrix Groups)</h3>
<ul>
<li><h4 id="常见的矩阵集合">常见的矩阵集合</h4>
<ul>
<li><h5 id="mat_ntimes-nmathbbr-性质研究"><span
class="math inline">\(Mat_{n\times n}(\mathbb{R})\)</span> 性质研究</h5>
<p><span class="math inline">\(Mat_{n\times n}(\mathbb{R})=\set{n\times
n \text{实矩阵}}\cong
\mathbb{R}^{n^2}\)</span>，其在加法下构成群而在乘法下不是群。</p></li>
<li><h5 id="glnmathbbr-一般线性群性质的研究"><span
class="math inline">\(GL(n,\mathbb{R})\)</span>
（一般线性群）性质的研究</h5>
<p><span class="math inline">\(GL(n,\mathbb{R})=\set{M\in Mat_{n\times
n}(\mathbb{R})\mid \det M\neq 0}\subseteq
\mathbb{R}^{n^2}\)</span>，且是一个开集。</p>
<p>我们来研究一下它的性质。</p>
<p>首先看乘法：</p>
<p><span class="math inline">\(Mat_{n\times n}(\mathbb{R})\times
Mat_{n\times n}(\mathbb{R})\xrightarrow{m} Mat_{n\times
n}(\mathbb{R})\)</span> 定义为矩阵乘法，则 <span
class="math inline">\(m\)</span> 是连续映射。</p>
<p>因此我们将该乘法限制在开子集 <span
class="math inline">\(GL(n,\mathbb{R})\)</span>
上所得到的限制映射也是连续映射。</p>
<p>接着看取逆：</p>
<p><span class="math inline">\(GL(n,\mathbb{R})\xrightarrow{i}
GL(n,\mathbb{R})\)</span> 是取逆映射，由于 <span
class="math inline">\(M^{-1}=\cfrac{M^{\star}}{\det M}\)</span>，其中
<span class="math inline">\(M^\star\)</span>
是伴随矩阵，伴随是一个连续映射；行列式也是一个连续映射，因此 <span
class="math inline">\(i\)</span> 也是一个连续映射。</p>
<p>综上，一般线性群 <span
class="math inline">\(GL(n,\mathbb{R})\)</span> 确实是一个拓扑群。</p>
<p>在我们得到一个拓扑群之后，我们通常会研究如下问题：</p>
<ul>
<li><p>该拓扑群是否是紧的？ 答案是否定的，因为 <span
class="math inline">\(GL(n,\mathbb{R})\)</span>
是一个欧氏空间的子集，它既不是闭集也不是有界的，故自然不是紧集。</p></li>
<li><p>该拓扑群是否是连通的？ 答案也是否定的，行列式的正负显然至少将
<span class="math inline">\(GL(n,\mathbb{R})\)</span>
切分为了两部分，因此不是连通集合。（<span
class="math inline">\(\det:Mat_{n\times n}(\mathbb{R})\to
\mathbb{R}\)</span> 是一个连续映射，但 <span
class="math inline">\(\det(GL(n,\mathbb{R}))=\mathbb{R}\setminus
\set{0}\)</span>，该集合不连通，因此 <span
class="math inline">\(GL(n,\mathbb{R})\)</span> 也不是连通）</p></li>
<li><p>该拓扑群的连通分支是什么？ 事实上，令 <span
class="math inline">\(A=\set{M\in GL(n,\mathbb{R})\mid \det
A&gt;0},B=\set{M\in GL(n,\mathbb{R})\mid \det B&lt;0}\)</span>，则有
<span class="math inline">\(A,B\)</span> 就是 <span
class="math inline">\(GL(n,\mathbb{R})\)</span> 的连通分支。</p>
<p>证明留作练习。提示：由于 <span class="math inline">\(A,B\)</span>
都是欧氏空间中开子集，我们不妨证明 <span
class="math inline">\(A,B\)</span> 是道路连通。</p>
<p>我们对矩阵做 <span class="math inline">\(LU\)</span> 分解，其中 <span
class="math inline">\(L\)</span> 是下三角阵，<span
class="math inline">\(U\)</span> 是上三角阵，我们对 <span
class="math inline">\(L\)</span> 与 <span
class="math inline">\(U\)</span>
分别移动为对角矩阵，就可以构造一条任意矩阵到对角阵的道路。</p>
<p>对于对角阵，不失一般性地，我们可以通过 <span
class="math inline">\(\begin{pmatrix}\cos\theta&amp;\sin\theta\\-\sin\theta&amp;\cos\theta\end{pmatrix}\)</span>
构造一个 <span
class="math inline">\(\text{diag}(1,1)\to\text{diag}(-1,-1)\)</span>
的连续变换。</p></li>
</ul></li>
<li><h5 id="slnmathbbr-性质研究"><span
class="math inline">\(SL(n,\mathbb{R})\)</span> 性质研究</h5>
<p>特殊线性群 <span class="math inline">\(SL(n,\mathbb{R})=\set{M\in
GL(n,\mathbb{R})\mid \det M=1}\)</span>. 这是一个 <span
class="math inline">\(GL(n,\mathbb{R})\)</span>
的子群，故也是一个拓扑群。</p>
<p>上面我们已经说明了它自然是一个拓扑群。</p>
<ul>
<li>该拓扑群是否是紧的？
答案是否定的，尽管它是闭集，但它不是一个有界集合。</li>
<li>该拓扑群是否是连通的？
答案是肯定的，它确实是一个连通空间。证明方法：考虑映射 <span
class="math inline">\(f:A=\set{M\in GL(n,\mathbb{R})\mid \det M&gt;0}\to
SL(n,\mathbb{R})\)</span>，<span
class="math inline">\(f(M)=\cfrac{M}{(\det M)^{1/n}}\)</span>，于是
<span class="math inline">\(f\)</span> 是连续的，由于 <span
class="math inline">\(A\)</span> 是连通的，因此 <span
class="math inline">\(f(A)=SL(n,\mathbb{R})\)</span> 是连通的。</li>
</ul></li>
<li><h5 id="正交矩阵群性质研究">正交矩阵群性质研究</h5>
<p>正交矩阵群 <span class="math inline">\(O(n)=\set{M\in
GL(n,\mathbb{R})\mid M^TM=I}\)</span>，特殊正交矩阵群 <span
class="math inline">\(SO(n)=\set{M\in O(n)\mid \det M=1}\)</span>.
它们自然也是拓扑群（分别为 <span
class="math inline">\(GL(n,\mathbb{R})\)</span> 与 <span
class="math inline">\(SL(n,\mathbb{R})\)</span> 的子群）。</p>
<ul>
<li><h6 id="正交矩阵群-on-与特殊正交矩阵群-son-是紧的">正交矩阵群 <span
class="math inline">\(O(n)\)</span> 与特殊正交矩阵群 <span
class="math inline">\(SO(n)\)</span> 是紧的</h6>
<p>正交矩阵群 <span class="math inline">\(O(n)\)</span> 与特殊正交矩阵群
<span class="math inline">\(SO(n)\)</span> 是紧的。</p>
<p>证明：令 <span class="math inline">\(A=(a_{ij})\in O(n)\)</span>，则
<span class="math inline">\(A^T A=I\)</span>.</p>
<p>于是 <span class="math inline">\(\sum_{j=1}^n
a_{ij}a_{kj}=\begin{cases}1&amp;i=k\\0&amp;i\neq
k\end{cases}\)</span>，令 <span
class="math inline">\(f_{ik}:Mat_{n\times n}(\mathbb{R})\to
\mathbb{R}\)</span>，其中 <span
class="math inline">\(f_{ik}(A)=\sum_{j=1}^n a_{ij}a_{jk}\)</span>，则
<span class="math inline">\(f\)</span> 是连续映射，且 <span
class="math inline">\(f_{ik}^{-1}(0)\)</span> 与 <span
class="math inline">\(f^{-1}_{ik}(1)\)</span> 是闭集，因此 <span
class="math inline">\(O(n)=\bigcap_{i,k=1,i\neq k}^{n} f_{ik}^{-1}(0)
\cap \bigcap_{i=1}^n f_{ii}^{-1}(1)\)</span> 为闭集。</p>
<p>由于<span class="math inline">\(\sum_{j=1}^n |a_{ij}|^2=1,\forall
i\)</span>，因此 <span class="math inline">\(|a_{ij}|\leq
1\)</span>，因此 <span class="math inline">\(O(n)\)</span> 有界。</p>
<p>因此 <span class="math inline">\(O(n)\)</span> 是紧集，类似地有 <span
class="math inline">\(SO(n)=O(n)\cap \det^{-1}(1)\)</span>
是紧集。</p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="群作用与商空间">10. 群作用与商空间</h2>
<h3 id="群作用与商空间-1">群作用与商空间</h3>
<ul>
<li><h4 id="抽象代数中的群作用与商空间">抽象代数中的群作用与商空间</h4>
<p><strong>群作用</strong></p>
<p>设 <span class="math inline">\(G\)</span> 是一个群，<span
class="math inline">\(X\)</span> 是一个集合，我们定义 <span
class="math inline">\(G\)</span>-作用（记作 <span
class="math inline">\(G\curvearrowright X\)</span>）：<span
class="math inline">\(G\times X\to X\)</span>，<span
class="math inline">\((g,x)\to g\cdot x\)</span>.</p>
<p>这个作用需要满足 <span class="math inline">\((hg)\cdot x=h\cdot
(g\cdot x)\)</span>，且 <span class="math inline">\(e\cdot x=x,\forall
x\in G,\forall g,h\in G\)</span>.</p>
<p><strong>商群</strong></p>
<p><span class="math inline">\(X/G=\set{\text{所有 }G\text{
轨道}}\)</span>，轨道的定义为 <span class="math inline">\(x,y\in
X\)</span>，称 <span class="math inline">\(x,y\)</span> 落在同一轨道上若
<span class="math inline">\(\exists g\in G\)</span> 使得 <span
class="math inline">\(x=gy\)</span>.</p></li>
<li><h4 id="拓扑群的群作用-group-action">拓扑群的群作用 (Group
Action)</h4>
<p>令 <span class="math inline">\(G\)</span> 是一个拓扑群，令 <span
class="math inline">\(X\)</span> 是一个拓扑空间。一个 <span
class="math inline">\(G\)</span>-作用是一个映射 <span
class="math inline">\(G\times X\xrightarrow{f} X,(g,x)\to g\cdot
x\)</span>.</p>
<p>该映射 <span class="math inline">\(f\)</span> 需要满足下述性质：</p>
<ul>
<li><span class="math inline">\(f\)</span> 需要是一个连续映射；</li>
<li><span class="math inline">\((hg)\cdot x=h(g\cdot x)\)</span>，<span
class="math inline">\(\forall x\in X,\forall g,h\in G\)</span></li>
<li><span class="math inline">\(e\cdot x=x\)</span>，<span
class="math inline">\(\forall x\in X\)</span>.</li>
</ul></li>
<li><h4 id="拓扑群的商空间-quotient-space">拓扑群的商空间 (Quotient
Space)</h4>
<p><span class="math inline">\(\forall x,y\in
X\)</span>，定义一个等价关系：<span class="math inline">\(x\sim
y\)</span> 若 <span class="math inline">\(\exists g\in G\)</span> 使得
<span class="math inline">\(x=gy\)</span>.</p>
<p>我们首先验证等价关系：</p>
<p>自反性：<span class="math inline">\(x=e\cdot x\)</span>；</p>
<p>对称性：<span class="math inline">\(x\sim y\)</span>，于是 <span
class="math inline">\(\exists g\in G\)</span>，使得 <span
class="math inline">\(x=gy\)</span>，一定有 <span
class="math inline">\(y=g^{-1}x\)</span>，因此 <span
class="math inline">\(y\sim x\)</span>；</p>
<p>传递性：<span class="math inline">\(x\sim y,y\sim z\)</span>，则
<span class="math inline">\(\exists gh\in G\)</span>，使得 <span
class="math inline">\(x=gy,y=hz\)</span>，于是 <span
class="math inline">\(x=g(hz)=(gh)z\)</span>，因此 <span
class="math inline">\(x\sim z\)</span>.</p>
<p>因此这确实是一个等价关系</p>
<p>如此有 <span class="math inline">\(\sim\)</span> 给出了 <span
class="math inline">\(X\)</span> 的一个划分
(Partition)，我们将划分中的每一个子集称之为 <span
class="math inline">\(G\)</span>-轨道 (<span
class="math inline">\(G\)</span>-orbit).</p>
<p>令 <span class="math inline">\(X/G\)</span> 是对应于 <span
class="math inline">\(\sim\)</span> 给出分划的粘合空间，我们将 <span
class="math inline">\(X/G\)</span> 称作是<strong>商空间 (Quotient
Space)</strong>，有时我们也称其为<strong>轨道空间 (Orbit
Space)</strong>.</p></li>
<li><h4 id="商空间的例子">商空间的例子</h4>
<ul>
<li><h5 id="环面-torus">环面 Torus</h5>
<p>回忆：曾经我们通过矩形对边粘合构成了环面。</p>
<p>现在我们来看如何用商空间观点构造环面。我们固定 <span
class="math inline">\(v_1,v_2\in \mathbb{R}^2\)</span>，使得 <span
class="math inline">\(v_1\not\parallel v_2\)</span>.</p>
<p>令 <span class="math inline">\(\Lambda=\mathbb{Z}\cdot v_1 \oplus
\mathbb{Z}\cdot v_2\cong \mathbb{Z}^2\)</span>，<span
class="math inline">\(\Lambda\subseteq
\mathbb{R}^2\)</span>，这被称作一个<strong>格点 (Lattice)</strong>.</p>
<figure>
<img src="\10-1.png" alt="image-20231026100731447" />
<figcaption aria-hidden="true">image-20231026100731447</figcaption>
</figure>
<p>如图是一个 Lattice 的例子，其中 <span
class="math inline">\(v_1\)</span> 位于 <span
class="math inline">\(x\)</span> 轴。</p>
<p>我们在 <span class="math inline">\(\mathbb{R}^2\)</span> 上定义一个
<span class="math inline">\(\Lambda\)</span>-作用，作用的方式为：<span
class="math inline">\((mv_1,nv_2)\cdot(x,y)=(x,y)+mv_1+nv_2\)</span>.
这有时也被称为平移作用。</p>
<p>我们考虑商空间 <span
class="math inline">\(\mathbb{R^2}/\Lambda\)</span>，则该商空间同胚于一个环面。</p>
<figure>
<img src="\10-2.png" alt="image-20231026101101349" />
<figcaption aria-hidden="true">image-20231026101101349</figcaption>
</figure>
<p>注意如图中平行四边形，其对边按照相同方向粘合到了一起。</p>
<ul>
<li><h6 id="additional-topic-黎曼曲面-riemann-surface">*Additional
Topic: 黎曼曲面 (Riemann Surface)</h6>
<p>我们将 <span class="math inline">\(\Lambda\)</span> 看作 <span
class="math inline">\(\mathbb{C}\)</span> 中的一个子集，<span
class="math inline">\(\Lambda=\mathbb{Z}\cdot 1\oplus \mathbb{Z}\cdot
\tau\)</span>，<span class="math inline">\(\tau\in H=\set{z\in
\mathbb{C}\mid \text{Im} z&gt;0}\)</span>.</p>
<p>那么 <span class="math inline">\(\mathbb{C}/\Lambda\)</span>
还有一个从 <span class="math inline">\(\mathbb{C}\)</span>
诱导的复结构，这个曲面被称作是一个<strong>黎曼曲面 (Riemann
Surface)</strong>。</p>
<p>此外，该曲面<strong>亏格 (Genus)</strong>是 <span
class="math inline">\(1\)</span>，这还是一个<strong>椭圆曲线</strong>。（回忆：复分析讲到的
<span class="math inline">\(\wp\)</span> 函数）</p>
<p><span class="math inline">\(\text{d}z\)</span> 在 <span
class="math inline">\(\mathbb{C}/\Lambda\)</span> 上是一个全纯微分，有
<span class="math inline">\(\int_A \text{d}z=1,\int_B
\text{d}z=\tau\)</span>.</p>
<p>这意味着，对于不同的 <span
class="math inline">\(\tau\)</span>，我们可以得到不同的复结构，这与先前环面的拓扑结构于
<span class="math inline">\(\tau\)</span> 无关不同。</p>
<figure>
<img src="\10-3.png" alt="image-20231026101842695" />
<figcaption aria-hidden="true">image-20231026101842695</figcaption>
</figure>
<p>事实上，令 <span
class="math inline">\(SL(2,\mathbb{Z})\curvearrowright
H\)</span>，我们定义 <span
class="math inline">\(\begin{pmatrix}a&amp;b\\c&amp;d\end{pmatrix}
\tau=\cfrac{a\tau+b}{c\tau+d}\)</span>，这被称作莫比乌斯变换。那么 <span
class="math inline">\(H/SL(2,\mathbb{Z})\)</span>
给出了环面上所有复结构可能的参数空间（模空间 Modulus Space），<span
class="math inline">\(\tau\in H/SL(2,\mathbb{Z})\)</span>
一一对应于环面上所有的复结构。</p>
<p>这个参数空间长成什么样呢？</p>
<figure>
<img src="\10-4.png" alt="image-20231026102252939" />
<figcaption aria-hidden="true">image-20231026102252939</figcaption>
</figure></li>
</ul></li>
<li><h5 id="射影空间-projective-space-1">射影空间 (Projective
Space)</h5>
<p>令 <span class="math inline">\(S^n\subseteq \mathbb{R}^{n+1}\)</span>
是单位球面，考虑二元群 <span
class="math inline">\(\mathbb{Z}/2\mathbb{Z}=\set{-1,1}\)</span>，其中
<span class="math inline">\(-1\)</span> 是生成元，<span
class="math inline">\(1\)</span>
是恒等元，群运算定义为恒等运算。定义二元群作用在 <span
class="math inline">\(S^n\)</span> 上，其中 <span
class="math inline">\((-1)\cdot x:=-x\)</span>.</p>
<p>则 <span
class="math inline">\(S^n/(\mathbb{Z}/2\mathbb{Z})=\mathbb{R}P^n\)</span>
得到了实射影空间。</p>
<p>考虑另一种构造：</p>
<p>令 <span class="math inline">\(\mathbb{R}^\star=\mathbb{R}\setminus
\set{0}\)</span>，我们有 <span
class="math inline">\(\mathbb{R}^\star\)</span>
在乘法下成群。我们定义一个群作用 <span
class="math inline">\(\mathbb{R}^\star\curvearrowright
\mathbb{R}^{n+1}\setminus \set{0}\)</span>：<span
class="math inline">\(\lambda \cdot(x_1,\cdots,x_{n+1}):=(\lambda
x_1,\cdots,\lambda x_{n+1})\)</span>，其中 <span
class="math inline">\((x_1,\cdots,x_{n+1})\in \mathbb{R}^{n+1}\setminus
\set{0}\)</span>.</p>
<p>则 <span class="math inline">\((\mathbb{R}^{n+1}\setminus
\set{0})/\mathbb{R}^{\star}=\mathbb{R}P^n\)</span> 就是实射影空间。</p>
<p>这引出了射影空间上<strong>齐次坐标 (Homogeneous
Coordinate)</strong>的概念：<span
class="math inline">\(\mathbb{R}P^n=\set{[x_1:\cdots:x_{n+1}]\mid
(x_1,\cdots,x_{n+1})\in \mathbb{R}^{n+1}\setminus\set{0}}\)</span></p>
<p>其中 <span class="math inline">\([x_1:\cdots:x_{n+1}]=[\lambda
x_1:\cdots :\lambda x_{n+1}],\forall \lambda\neq 0\)</span>.</p>
<p>在有了齐次坐标之后，我们还能引入如下概念：</p>
<ul>
<li><h6 id="典范图册-canonical-chart">典范图册 Canonical Chart</h6>
<p><span class="math inline">\(\mathbb{R}P^n\)</span> 中存在有 <span
class="math inline">\(n+1\)</span> 个元素的<strong>典范图册 (Canonical
Charts)</strong>，令 <span class="math inline">\(U_i\subseteq
\mathbb{R}P^n\)</span>，其中 <span
class="math inline">\(U_i=\set{[x_1:\cdots:x_{n+1}]\in \mathbb{R}P^n
\mid x_i\neq 0}\subseteq^{\text{open}}
\mathbb{R}P^n\)</span>，则我们可以将这中坐标写成 <span
class="math inline">\([x_1,\cdots,x_i,\cdots,x_{n+1}]=[\cfrac{x_1}{x_i}:\cdots:1:\cdots:\cfrac{x_{n+1}}{x_i}]\)</span>.</p>
<p>此时有 <span class="math inline">\(U_i\)</span> 同胚于 <span
class="math inline">\(\mathbb{R}^n\)</span>，这是由于在固定 <span
class="math inline">\(x_i\)</span> 为 <span
class="math inline">\(1\)</span>
后，其余元素已经没有所谓的“自由度”了。与此同时，<span
class="math inline">\(\set{U_i}_{i=1}^{n+1}\)</span> 是一个射影空间
<span class="math inline">\(\mathbb{R}P^n\)</span>
的开覆盖。（因此，<span class="math inline">\(\mathbb{R}P^n\)</span>
是一个流形）</p></li>
</ul>
<p>对于复射影空间，<span
class="math inline">\(\mathbb{C}^\star:=\mathbb{C}\setminus\set{0}\)</span>，我们定义群作用
<span class="math inline">\(\mathbb{C}^\star \curvearrowright
\mathbb{C}^{n+1}\setminus\set{0}:\lambda(x_1,\cdots,x_{n+1})=(\lambda
x_1,\cdots,\lambda x_{n+1})\)</span>.</p>
<p>在这个群作用下我们得到了复射影空间 <span
class="math inline">\(\mathbb{C}P^n\)</span>，也能定义齐次坐标和典范图册：<span
class="math inline">\(U_i=\set{[x_1:\cdots:x_{n+1}]\in\mathbb{C}P^n\mid
x_i\neq 0}\subseteq^{\text{open}} \mathbb{C}P^n\)</span>.</p>
<p>也有 <span class="math inline">\(U_i\)</span> 同胚于 <span
class="math inline">\(\mathbb{C}^n\)</span>，且 <span
class="math inline">\(U_i\)</span> 形成了 <span
class="math inline">\(\mathbb{C}P^n\)</span> 的开覆盖。（因此，<span
class="math inline">\(\mathbb{C}P^n\)</span> 是一个复流形）</p>
<ul>
<li><h6
id="additional-topic-mathbbcpn-上的-zariski-topology">*Additional Topic:
<span class="math inline">\(\mathbb{C}P^n\)</span> 上的 Zariski
Topology</h6>
<p>定义 <span class="math inline">\(\mathbb{C}P^n\)</span>
上的另一种拓扑，称作 Zariski Topology。</p>
<p>一个多项式 <span class="math inline">\(f(x_1,\cdots,x_{n+1})\)</span>
被称作是一个<strong>齐次多项式 (Homogeneous)</strong>，如果 <span
class="math inline">\(f(\lambda x_1,\cdots,\lambda x_{n+1})=\lambda^d
f(x_1,\cdots,x_{n+1})\)</span>，其中 <span class="math inline">\(d\in
\mathbb{Z}_{\geq 0}\)</span>，被称为是齐次多项式的<strong>次数
(Degree)</strong>。</p>
<p>我们如此定义 Zariski Topology：一个子集 <span
class="math inline">\(F\subset \mathbb{C}P^n\)</span> 是闭集，若 <span
class="math inline">\(F\)</span> 是某一些 <span
class="math inline">\(\mathbb{C}[x_1,\cdots,x_{n+1}]\)</span>
中齐次多项式的公共零点。这被称为是射影空间的 Zariski Topology.</p>
<p>小练习：事实上，我们定义 <span
class="math inline">\(U_i=\set{[x_1:\cdots:x_{n+1}]\in \mathbb{C}P^n\mid
x_i\neq 0}\subset \mathbb{C}P^n\)</span>，我们在 <span
class="math inline">\(\mathbb{C}P^n\)</span> 上装备 Zariski
Topology，考虑 <span class="math inline">\(U_i\)</span>
上的子空间拓扑，则有 <span class="math inline">\(U_i\)</span>
同胚于装备了 Zariski Topology 的 <span
class="math inline">\(\mathbb{C}^n\)</span>。</p>
<p>提示：<span class="math inline">\(\set{[x_1,\cdots,x_{n+1}]\in
\mathbb{C}P^n\mid f(x_1,\cdots,x_{n+1})=0}\cap U_{n+1}\)</span>，<span
class="math inline">\(f\)</span> 齐次可以被写成 <span
class="math inline">\(\set{(x_1,\cdots,x_n)\in \mathbb{C}^n\mid
g(x_1,\cdots,x_n)=f(x_1,\cdots,x_n,1)=0}\)</span>.</p></li>
</ul></li>
<li><h5 id="子群作用">子群作用</h5>
<p>令 <span class="math inline">\(G\)</span> 是一个拓扑群，<span
class="math inline">\(H\)</span> 是 <span
class="math inline">\(G\)</span> 的子群。那么存在作用 <span
class="math inline">\(H\curvearrowright G\)</span>：<span
class="math inline">\(h\cdot g=h\cdot g\)</span>（其中右边是群 <span
class="math inline">\(G\)</span> 中乘法，左边是作用的符号），<span
class="math inline">\(h\in H,g\in G\)</span>.</p>
<p>可以验证 <span class="math inline">\(G/H\)</span>
是所有右陪集组成的集合 <span class="math inline">\(=\set{Hg\mid g\in
G}\)</span>。</p></li>
<li><h5 id="矩阵群的作用">矩阵群的作用</h5>
<p>考虑矩阵群 <span
class="math inline">\(O(n)\)</span>（正交矩阵群）的作用，<span
class="math inline">\(O(n)\curvearrowright S^{n-1}\subseteq
\mathbb{R}^n\)</span>. 这个群作用是<strong>传递的
(Transitive)</strong>（回忆：传递指的是 <span
class="math inline">\(\forall x\in
S^{n-1}\)</span>，这个点所在的轨道是全空间），或者说 <span
class="math inline">\(\forall x,y\in S^{n-1}\)</span>，<span
class="math inline">\(x,y\)</span> 在同一个 <span
class="math inline">\(O(n)\)</span>-轨道中，也就是 <span
class="math inline">\(\exists A\in O(n)\)</span>，使得 <span
class="math inline">\(Ax=y\)</span>.</p>
<p>证明：</p>
<p><span class="math inline">\(\forall x_1\in
S^{n-1}\)</span>，将其延拓为一组 <span
class="math inline">\(\mathbb{R}^n\)</span> 的标准正交基 <span
class="math inline">\(x_1,\cdots, x_{n}\)</span>.</p>
<p>类似地 <span class="math inline">\(\forall y_1\in
S^{n-1}\)</span>，也可以将其延拓为一组 <span
class="math inline">\(\mathbb{R}^n\)</span> 的标准正交基 <span
class="math inline">\(y_1,\cdots,y_n\)</span>.</p>
<p>那么存在正交矩阵 <span class="math inline">\(A\in O(n)\)</span>，使得
<span
class="math inline">\((Ax_1,\cdots,Ax_n)=(y_1,\cdots,y_n)\)</span>.</p>
<p>于是 <span class="math inline">\(Ax_1=y_1\)</span>.</p>
<p>考虑一个嵌入映射：<span class="math inline">\(O(n-1)\to
O(n)\)</span>：<span
class="math inline">\(B\to\begin{pmatrix}1&amp;0\\0&amp;B\end{pmatrix}\)</span>，并且在这个嵌入下，<span
class="math inline">\(O(n-1)\)</span> 可以看作是 <span
class="math inline">\(O(n)\)</span> 的一个子群。</p>
<p>现在令 <span
class="math inline">\(e_1=\begin{pmatrix}1\\0\\\vdots\\0\end{pmatrix},\cdots,e_n=\begin{pmatrix}0\\0\\\vdots\\1\end{pmatrix}\)</span>
是一组 <span class="math inline">\(\mathbb{R}^n\)</span> 的标准基，</p>
<p>我们有 <span class="math inline">\(Ae_1=e_1\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(A=\begin{pmatrix}1&amp;0\\0&amp;B\end{pmatrix},B\in
O(n-1)\)</span>.</p>
<p>于是我们把 <span class="math inline">\(O(n-1)\subseteq O(n)\)</span>
称作 <span class="math inline">\(e_1\)</span> 的<strong>稳定化子
(Stabilizer)</strong>。</p>
<p>我们令 <span class="math inline">\(\pi:O(n)\to S^{n-1}:A\to
Ae_1\)</span>，我们有 <span class="math inline">\(\pi\)</span>
是连续的且是满射（因为 <span class="math inline">\(O(n)\curvearrowright
S^{n-1}\)</span> 是传递的）。</p>
<p>由于 <span class="math inline">\(O(n)\)</span> 是紧的，<span
class="math inline">\(S^{n-1}\)</span> 是 Hausdorff，因此 <span
class="math inline">\(\pi\)</span> 是粘合映射。</p>
<p>我们考虑这个粘合映射对应的分划：这个分划即为所有的左陪集 <span
class="math inline">\(\set{AO(n-1)\mid A\in O(n)}\)</span>.</p>
<p>因此如果我们取商群 <span
class="math inline">\(O(n)/O(n-1)\)</span>，这个群同胚于 <span
class="math inline">\(S^{n-1}\)</span>.</p>
<p>类似地，可以考虑嵌入 <span class="math inline">\(SO(n-1)\to
SO(n)\)</span>，我们可以得到 <span
class="math inline">\(SO(n)/SO(n-1)\)</span> 同胚于 <span
class="math inline">\(S^{n-1}\)</span>.</p></li>
</ul></li>
<li><h4
id="构造商空间的粘合映射一定是开映射">构造商空间的粘合映射一定是开映射</h4>
<p>令 <span class="math inline">\(G\)</span> 作用于 <span
class="math inline">\(X\)</span> 上，若考虑粘合映射 <span
class="math inline">\(\pi:X\to
X/G\)</span>，则该粘合映射一定是开映射，也就是说，<span
class="math inline">\(\forall\)</span> 开集 <span
class="math inline">\(U\subseteq X\)</span>，有 <span
class="math inline">\(\pi(U)\)</span> 是 <span
class="math inline">\(X/G\)</span> 中开集。</p>
<p>证明：取开集 <span class="math inline">\(U\)</span>， <span
class="math inline">\(\pi(U)\subseteq X/G\)</span>，它是开集当且仅当
<span class="math inline">\(\pi^{-1}(\pi(U))\)</span> 是开集。</p>
<p>我们考虑证明如下事实：<span
class="math inline">\(\pi^{-1}(\pi(U))\)</span> 总可以写成 <span
class="math inline">\(\bigcup_{g\in G}g\cdot U\)</span>.</p>
<p><span class="math inline">\(\forall x\in \bigcup_{g\in G}g\cdot
U\)</span>，<span class="math inline">\(\exists g\in G,y\in
U\)</span>，使得 <span class="math inline">\(x=gy\)</span>，于是 <span
class="math inline">\(\pi(x)=\pi(y)\in \pi(U)\)</span>；</p>
<p>令 <span class="math inline">\(x\in \pi^{-1}\pi(U)\)</span>，<span
class="math inline">\(\pi(x)\in \pi(U)\)</span>，也就是 <span
class="math inline">\(\exists y\in U\)</span>，使得 <span
class="math inline">\(\pi(x)=\pi(y)\)</span>，也就是 <span
class="math inline">\(\exists g\in G\)</span>，使得 <span
class="math inline">\(x=gy\)</span>.</p>
<p>因此事实得到证明。由于 <span class="math inline">\(U\)</span>
是开集，由于平移映射 <span class="math inline">\(g:X\to X,x\to g\cdot
x\)</span> 是一个同胚，有 <span class="math inline">\(gU\)</span>
是一个开集，因此 <span
class="math inline">\(\pi^{-1}(\pi(U))=\bigcup_{g\in G}gU\)</span>
是开集。</p>
<p>因此这是一个开映射。</p></li>
</ul>
<h2 id="同伦">11. 同伦</h2>
<h3 id="群作用收尾">群作用收尾</h3>
<ul>
<li><h4 id="回顾商空间粘合映射">回顾：商空间粘合映射</h4>
<p>考虑 <span class="math inline">\(G\curvearrowright X\)</span>
给出粘合映射，有 <span class="math inline">\(\pi:X\to
X/G\)</span>，我们有 <span class="math inline">\(\pi\)</span>
是一个开映射。</p></li>
<li><h4
id="整体空间与商空间连通性的关系">整体空间与商空间连通性的关系</h4>
<p>考虑群作用 <span class="math inline">\(G\curvearrowright
X\)</span>，<span class="math inline">\(X/G\)</span> 与群 <span
class="math inline">\(G\)</span> 都是连通的，则 <span
class="math inline">\(X\)</span> 是连通的。</p>
<p>证明：根据连通性的定义，假设 <span class="math inline">\(X=A\cup
B\)</span>，使得 <span class="math inline">\(A\cap
B=\varnothing\)</span>，且 <span class="math inline">\(A,B\)</span>
为非空开集。</p>
<p>我们知道，<span class="math inline">\(\pi:X\to X/G\)</span>
是开映射，因此 <span class="math inline">\(X/G=\pi(A)\cup
\pi(B)\)</span>，并且 <span class="math inline">\(\pi(A),
\pi(B)\)</span> 都是非空开集。因此 <span
class="math inline">\(\pi(A)\cap \pi(B)\neq \varnothing\)</span> （<span
class="math inline">\(X/G\)</span> 是连通），令 <span
class="math inline">\(\pi(x)\in \pi(A)\cap \pi(B)\)</span>，则有 <span
class="math inline">\(A\cap Gx\neq\varnothing, B\cap Gx\neq
\varnothing\)</span>. 不仅如此，我们有 <span
class="math inline">\(Gx=(A\cap Gx)\sqcup (B\cap Gx)\)</span>.</p>
<p>然而，令 <span class="math inline">\(f:G\to X,
f(g)=gx\)</span>，<span class="math inline">\(f\)</span>
是一个连续映射因为 <span class="math inline">\(f\)</span> 是 <span
class="math inline">\(G\to G\times X\to X\)</span>
的复合，两个映射分别是嵌入映射与群作用的结构映射，故 <span
class="math inline">\(Gx=f(G)\)</span> 也是连通集合，这与上面 <span
class="math inline">\(Gx\)</span> 的定义矛盾。</p></li>
<li><h4 id="特殊正交群-son-是连通的">特殊正交群 <span
class="math inline">\(SO(n)\)</span> 是连通的</h4>
<p>特殊正交群 <span class="math inline">\(SO(n)\)</span> 是连通的。</p>
<p>证明：归纳法。<span class="math inline">\(SO(1)\)</span>
只有一个单点，故是连通集。</p>
<p>上节课我们讲到 <span class="math inline">\(SO(n+1)/SO(n)\cong
S^{n}\)</span>，由于 <span class="math inline">\(S^n\)</span>
是连通的，根据归纳假设有 <span class="math inline">\(SO(n)\)</span>
是连通的，根据上面的定理有 <span class="math inline">\(SO(n+1)\)</span>
是连通的。</p></li>
</ul>
<h3 id="同伦理论-homotopy-theorem">同伦理论 (Homotopy Theorem)</h3>
<ul>
<li><h4 id="引入动机">引入动机</h4>
<ul>
<li><h5 id="为了引入同伦群-homotopy-groups">为了引入同伦群 (Homotopy
Groups)</h5>
<p>定义拓扑不变量：同伦群 (Homotopy
Groups)，这门课将只会讲授一维同伦群（基本群, Fundamental
Group）。</p></li>
<li><h5 id="引入同伦等价-homotopy-equivalences">引入同伦等价 (Homotopy
Equivalences)</h5>
<p>为了引入一个比同胚稍弱的等价关系，将复杂的空间等价为简单的空间。</p></li>
</ul></li>
<li><h4 id="同伦-homotopy">同伦 (Homotopy)</h4>
<p>让我们先来看几个例子：</p>
<figure>
<img src="\11-1.png" alt="image-20231031153943390" />
<figcaption aria-hidden="true">image-20231031153943390</figcaption>
</figure>
<p>如图，圆周打到球面上能“缩”成一点。</p>
<figure>
<img src="\11-2.png" alt="image-20231031154109993" />
<figcaption aria-hidden="true">image-20231031154109993</figcaption>
</figure>
<p>如图，圆周打到环面上有时能“缩”成一点（绿圈），有时不能（橙圈）。这意味着环面与球面在一定意义下是不同的。</p>
<p>又如：考虑如下情形：</p>
<figure>
<img src="\11-3.png" alt="image-20231031154332346" />
<figcaption aria-hidden="true">image-20231031154332346</figcaption>
</figure>
<p>球面在 <span class="math inline">\(\mathbb{R}^3\)</span>
中能收缩为一点，但不能在 <span class="math inline">\(S^2\)</span>
中缩成一点。</p>
<p>同理，<span class="math inline">\(S^n\)</span> 在 <span
class="math inline">\(\mathbb{R}^{n+1}\)</span> 可以缩成一点，但不能在
<span class="math inline">\(S^n\)</span> 中缩成一点。</p>
<p>我们应该怎样表示映射的“收缩”呢？来看下面的定义。</p>
<ul>
<li><h5 id="同伦的定义-homotopic">同伦的定义 (Homotopic)</h5>
<p>令 <span class="math inline">\(f,g\)</span> 为 <span
class="math inline">\(X\to Y\)</span> 连续映射，则 <span
class="math inline">\(f\)</span> 与 <span
class="math inline">\(g\)</span> <strong>同伦 (Homotopic)</strong> 若
<span class="math inline">\(\exists\)</span> 连续映射 <span
class="math inline">\(F:X\times I\to Y\)</span>，其中 <span
class="math inline">\(I=[0,1]\)</span>，使得 <span
class="math inline">\(F(x,0)=f(x),F(x,1)=g(x),\forall x\in
X\)</span>.</p>
<p>记作 <span class="math inline">\(f\underset{F}{\simeq}g\)</span></p>
<p>从直观上看，这即是</p>
<figure>
<img src="\11-4.png" alt="image-20231031154813338" />
<figcaption aria-hidden="true">image-20231031154813338</figcaption>
</figure></li>
<li><h5 id="相对同伦的定义-relative-homotopic">相对同伦的定义 (Relative
Homotopic)</h5>
<p>若 <span class="math inline">\(\exists A\subset X\)</span> 使得 <span
class="math inline">\(f|_A=g|_A\)</span>，若 <span
class="math inline">\(\exists F:X\times I\to Y\)</span> 使得 <span
class="math inline">\(F(x,0)=f(x); F(x,1)=g(x),\forall x\in
X\)</span>，且 <span class="math inline">\(F(x,t)=f(x),\forall x\in
A,t\in [0,1]\)</span>，称 <span class="math inline">\(f\)</span> 与
<span class="math inline">\(g\)</span> 相对于子空间 <span
class="math inline">\(A\)</span> 同伦. 记作 <span
class="math inline">\(f\underset{F}{\simeq}g\text{ rel } A\)</span>.</p>
<p>直观上看，这意味着 <span class="math inline">\(A\)</span>
里面的点在同伦时始终保持不动。</p></li>
<li><h5 id="例子直线同伦-straight-line-homotopy">例子：直线同伦
(Straight-Line Homotopy)</h5>
<p>令 <span class="math inline">\(C\subset \mathbb{R}^n\)</span>
是一个凸集（Convex Set，即为 <span class="math inline">\(\forall x,y\in
C\)</span>，有 <span class="math inline">\(\forall t\in
[0,1]\)</span>，<span class="math inline">\(tx+(1-t)y\in
C\)</span>），令 <span class="math inline">\(f,g:X\to C\)</span>
是任意两个连续映射，则有 <span class="math inline">\(f\simeq
g\)</span>.</p>
<p>证明：令 <span
class="math inline">\(F(x,t)=(1-t)f(x)+tg(x)\)</span>，则有 <span
class="math inline">\(f\underset{F}{\simeq} g\)</span>.</p></li>
<li><h5 id="同伦是一个等价关系">同伦是一个等价关系</h5>
<p>引理：对所有 <span class="math inline">\(X\to Y\)</span>
的连续映射，同伦是一个等价关系。</p>
<p>证明：自反性 <span class="math inline">\(f\simeq f\)</span>：<span
class="math inline">\(F(x,t)=f(x),\forall x\in X,t\in I\)</span>
即得；</p>
<p>对称性 <span class="math inline">\(f\underset{F}{\simeq} g\Rightarrow
g\simeq f\)</span>：令 <span
class="math inline">\(G(x,t)=F(x,1-t),\forall x\in X,t\in
I\)</span>，则有 <span class="math inline">\(G\)</span> 是连续的且 <span
class="math inline">\(G(x,0)=g(x), G(x,1)=f(x)\)</span>，于是 <span
class="math inline">\(g\underset{G}{\simeq} f\)</span>.</p>
<p>传递性：<span class="math inline">\(f\underset{F}{\simeq}
g,g\underset{G}{\simeq} h\Rightarrow f\simeq h\)</span>：定义 <span
class="math inline">\(H(x,t)=\begin{cases}F(x,2t)&amp;0\leq t\leq
\frac{1}{2}\\G(x,2t-1)&amp;\frac{1}{2}\leq t\leq
1\end{cases}\)</span></p>
<p>于是有 <span class="math inline">\(f\underset{H}{\simeq}
h\)</span>.</p>
<p>注：相对同伦也是一个等价关系。这里略去不再证明。</p></li>
<li><h5
id="复合映射间的同伦同伦被复合保持">复合映射间的同伦（同伦被复合保持）</h5>
<figure>
<img src="\11-5.png" alt="image-20231031160355464" />
<figcaption aria-hidden="true">image-20231031160355464</figcaption>
</figure>
<p>如图所示，若 <span class="math inline">\(f\underset{F}{\simeq}
g\text{ rel } A\)</span>，则 <span class="math inline">\(h\circ
f\underset{h\circ F}{\simeq} h\circ g\text{ rel } A\)</span>.</p>
<figure>
<img src="\11-6.png" alt="image-20231031160555054" />
<figcaption aria-hidden="true">image-20231031160555054</figcaption>
</figure>
<p>如图所示，若 <span class="math inline">\(g\underset{G}{\simeq}
h\text{ rel } B\)</span>，则 <span class="math inline">\(g\circ
f\underset{G(f(x),t)}{\simeq} h\circ f\text{ rel }
f^{-1}(B)\)</span>.</p>
<p>证明：</p>
<p>先看上面的式子。<span class="math inline">\(F:X\times I\to
Y\)</span>，有 <span
class="math inline">\(F(x,0)=f(x),F(x,1)=g(x),\forall x\in
A\)</span>，并且 <span class="math inline">\(F(x,t)=f(x),\forall x\in
A,t\in I\)</span>. 于是 <span class="math inline">\(h\circ F(x,0)=h\circ
f(x), h\circ F(x,1)=h\circ g(x)\)</span>.</p>
<p>不仅如此，<span class="math inline">\(h\circ F(x,t)=h\circ
f(x),\forall x\in A,t\in I\)</span>，由于 <span
class="math inline">\(h\circ F\)</span> 确实连续，于是 <span
class="math inline">\(h\circ f\underset{h\circ f}{\simeq} h\circ g\text{
rel } A\)</span>.</p>
<p>再看下面的式子。有 <span class="math inline">\(G(y,0)=g(y),
G(y,1)=h(y),\forall y\in Y\)</span>. 且 <span
class="math inline">\(G(y,t)=g(y),\forall y\in B\)</span> 于是 <span
class="math inline">\(G(f(x),0) = g(f(x)), G(f(x),1)=h(f(x))\)</span>.
另外 <span class="math inline">\(G(f(x),t)=g(f(x)),\forall x\in
f^{-1}(B)\)</span>. 类似地即有 <span class="math inline">\(g\circ
f\underset{G(f(x),t)}{\simeq} h\circ f\text{ rel }
f^{-1}(B)\)</span>.</p></li>
</ul></li>
<li><h4 id="基本群-fundamental-group">基本群 (Fundamental Group)</h4>
<p>考虑道路 <span class="math inline">\(\gamma:[0,1]\to X\)</span> 使得
<span class="math inline">\(\gamma(0)=\gamma(1)\)</span>
（注：这种情况等价于给出 <span class="math inline">\(S^1\to
X\)</span>），我们将这样的道路称作是 <span
class="math inline">\(X\)</span> 中<strong>环路 (Loop)</strong>。</p>
<p>我们在 <span class="math inline">\(X\)</span> 中选择一个标志点 (Base
Point) <span class="math inline">\(p\in X\)</span>，考虑集合：<span
class="math inline">\(X\)</span> 中所有环路，使得 <span
class="math inline">\(\gamma(0)=\gamma(1)=p\)</span>
或者说这些环路的基础点为 <span class="math inline">\(p\)</span>。令
<span class="math inline">\(A=\set{0,1}\subseteq[0,1]\)</span>，则相对
<span class="math inline">\(A\)</span>
同伦的关系是一个等价关系，我们记一个环路 <span
class="math inline">\(\gamma\)</span> 所在的等价类为 <span
class="math inline">\(&lt;\gamma&gt;\)</span>.</p>
<p>我们来定义乘法：令 <span class="math inline">\(\alpha,\beta\)</span>
为两个基础点为 <span class="math inline">\(p\)</span> 的环路，令 <span
class="math inline">\(\alpha\cdot \beta:[0,1]\to
X\)</span>，形如下图所示：</p>
<figure>
<img src="\11-7.png" alt="image-20231031162110179" />
<figcaption aria-hidden="true">image-20231031162110179</figcaption>
</figure>
<p>我们定义乘积为 <span
class="math inline">\(\alpha\cdot\beta(t)=\begin{cases}\alpha(2t)&amp;0\leq
t&lt;\cfrac{1}{2}\\\beta(2t-1)&amp;\cfrac{1}{2}\leq t\leq
1\end{cases}\)</span>.</p>
<p>问题：这个乘法是否满足严格的结合律？</p>
<p>然而并不是。<span class="math inline">\((\alpha\cdot
\beta)\cdot\gamma(t)=\begin{cases}\alpha(4t)&amp;0\leq
t&lt;1/4\\\beta(4t-1)&amp;1/4\leq t&lt;1/2\\\gamma(2t-1)&amp;1/2\leq
t\leq 1\end{cases}\)</span></p>
<p>但 <span
class="math inline">\(\alpha\cdot(\beta\cdot\gamma)(t)=\begin{cases}\alpha(2t)&amp;0\leq
t&lt;1/2\\\beta(4t-2)&amp;1/2\leq t&lt;3/4\\\gamma(4t-3)&amp;3/4\leq
t\leq 1\end{cases}\)</span></p>
<p>这两个映射“环绕的速度”是不相同的。</p>
<p>为了改进这一点，我们不再考虑道路自己，而是考虑道路的同伦类，即 <span
class="math inline">\(&lt;a&gt;\cdot &lt;\beta&gt;:=&lt;a\cdot
\beta&gt;\)</span> 上的运算。</p>
<p>如此，我们需要解决如下几个问题：</p>
<ol type="1">
<li>验证定义是良定的；</li>
</ol>
<p>事实上，定义确实是良定的：令 <span
class="math inline">\(\alpha&#39;\underset{F}{\simeq} \alpha\text{ rel
}\set{0,1}, \beta&#39;\underset{G}{\simeq} \beta\text{ rel
}\set{0,1}\)</span>，则令 <span
class="math inline">\(H(s,t)=\begin{cases}F(2s,t)&amp;0\leq s\leq
1/2\\G(2s-1,t)&amp;1/2\leq s\leq 1\end{cases}\)</span></p>
<p>从而 <span class="math inline">\(\alpha&#39;\cdot
\beta&#39;\underset{H}{\simeq} \alpha\cdot\beta\)</span>.</p>
<figure>
<img src="\11-8.png" alt="image-20231031163231221" />
<figcaption aria-hidden="true">image-20231031163231221</figcaption>
</figure>
<ol start="2" type="1">
<li>验证如下定理：</li>
</ol>
<p>考虑所有基本点为 <span class="math inline">\(p\)</span> 的 <span
class="math inline">\(X\)</span>
中环路同伦类组成的集合，这个集合构成了一个群，群的乘法为 <span
class="math inline">\(&lt;\alpha&gt;\cdot&lt;\beta&gt;=&lt;\alpha\cdot\beta&gt;\)</span>.</p>
<p>证明：</p>
<p>结合律：</p>
<p>即要证明，<span
class="math inline">\((\alpha\cdot\beta)\cdot\gamma\simeq\alpha\cdot(\beta\cdot\gamma)
\text{ rel }\set{0,1}\)</span>.</p>
<p>考虑 <span class="math inline">\(f:[0,1]\to [0,1]\)</span>，有 <span
class="math inline">\(f(s)=\begin{cases}2s&amp;0\leq s\leq
1/4\\s+1/4&amp;1/4\leq s\leq 1/2\\\cfrac{s+1}{2}&amp;1/2\leq s\leq
1\end{cases}\)</span></p>
<p>这是对 <span class="math inline">\([0,1]\)</span> 的重新参数化，且
<span class="math inline">\((\alpha\cdot\beta)\cdot\gamma =
(\alpha\cdot(\beta\cdot\gamma))\circ f\)</span></p>
<figure>
<img src="\11-9.png" alt="image-20231031163627077" />
<figcaption aria-hidden="true">image-20231031163627077</figcaption>
</figure>
<p>我们做出如下的声称：<span class="math inline">\(f\)</span> 同伦于
<span class="math inline">\(id: [0,1]\to [0,1]\text{ rel
}\set{0,1}\)</span>.</p>
<p>令 <span class="math inline">\(F(s,t)=\begin{cases}(2-t)s&amp;0\leq
s\leq 1/4\\s+1/4-t/4&amp;1/4\leq s\leq
1/2\\(1/2+t/2)s+1/2-t/2&amp;1/2\leq s\leq 1\end{cases}\)</span>，于是
<span class="math inline">\(f\underset{F}{\simeq} id\text{ rel
}\set{0,1}\)</span>.</p>
<p>于是 <span
class="math inline">\((\alpha\cdot\beta)\cdot\gamma=(\alpha\cdot(\beta\cdot\gamma))\circ
f\simeq (\alpha\cdot (\beta\cdot\gamma))\circ id= \alpha\cdot(\beta\cdot
\gamma)\text{ rel }\set{0,1}\)</span>.</p>
<p>恒等元：</p>
<p>令 <span class="math inline">\(e(t)=p,\forall t\in
[0,1]\)</span>，则考察 <span class="math inline">\(f\)</span>，有 <span
class="math inline">\(f(s)=\begin{cases}0&amp;0\leq s\leq
1/2\\2s-1&amp;1/2\leq s\leq 1\end{cases}\)</span></p>
<p>此时有 <span class="math inline">\(e\cdot \alpha=\alpha\circ
f\)</span>.</p>
<p>同理可以构造出 <span class="math inline">\(f\)</span> 同伦于 <span
class="math inline">\(id\)</span>.</p>
<p>因此 <span class="math inline">\(e\cdot\alpha=\alpha\circ f\simeq
\alpha\circ id=\alpha\text{ rel }\set{0,1}\)</span>.</p>
<p>也就是 <span
class="math inline">\(&lt;e&gt;\cdot&lt;\alpha&gt;=&lt;\alpha&gt;\)</span>.</p>
<p>类似地 <span
class="math inline">\(&lt;\alpha&gt;\cdot&lt;e&gt;=&lt;\alpha&gt;\)</span>.</p>
<p>逆元：</p>
<p>令 <span class="math inline">\(\alpha^{-1}(s)=\alpha(1-s),0\leq s\leq
1\)</span>.</p>
<p>首先验证良定义：若 <span
class="math inline">\(\alpha\underset{F}\simeq \beta\)</span>，则 <span
class="math inline">\(\alpha^{-1}\underset{G}\simeq\beta^{-1}\)</span>，其中
<span class="math inline">\(G(s,t)=F(1-s,t)\)</span>，因此 <span
class="math inline">\(&lt;\alpha&gt;^{-1}\)</span>
不依赖于代表元的选取。</p>
<p>令 <span class="math inline">\(f:I\to I\)</span>，有 <span
class="math inline">\(f(s)=\begin{cases}2s&amp;0\leq s\leq
1/2\\2-2s&amp;1/2\leq s\leq 1\end{cases}\)</span>.</p>
<p>则 <span class="math inline">\(\alpha\cdot\alpha^{-1}=\alpha \circ
f\)</span>.</p>
<p>可以证明 <span class="math inline">\(f\simeq g\text{ rel
}\set{0,1}\)</span>，有 <span class="math inline">\(g(s)=0,\forall 0\leq
s\leq 1\)</span>.</p>
<p>因此 <span class="math inline">\(\alpha\cdot\alpha^{-1}=\alpha\circ
f\simeq \alpha\circ g=e\text{ rel }\set{0,1}\)</span>.</p>
<p>类似地，<span class="math inline">\(\alpha^{-1}\cdot\alpha\simeq
e\text{ rel }\set{0,1}\)</span>.</p>
<p>因而 <span
class="math inline">\(&lt;\alpha^{-1}&gt;=&lt;\alpha&gt;^{-1}\)</span>.</p>
<p>我们将这个群称作 <span class="math inline">\(X\)</span> 关于基点
<span class="math inline">\(p\)</span> 处的<strong>基本群 (Fundamental
Group)</strong>，记作 <span class="math inline">\(\pi_1(X,p)\)</span>.
<span class="math inline">\(\forall &lt;\gamma(t)&gt;\in
\pi_1(X,p)\)</span>，它是一些环路的等价类，且 <span
class="math inline">\(\gamma(t)\)</span> 都落在包含点 <span
class="math inline">\(p\)</span> 的道路连通分支中。</p>
<p>因此，当我们研究基本群时，我们总可以假设 <span
class="math inline">\(X\)</span> 是道路连通的。</p>
<p>注：为什么是 <span class="math inline">\(\pi_1\)</span>？</p>
<p>实际上我们可以定义一般的同伦群：我们令 <span
class="math inline">\(S^n\)</span> 是 <span
class="math inline">\(n\)</span> 维球面，我们可以固定 <span
class="math inline">\(s_0\in
S^n\)</span>，考虑所有的同伦类，该同伦是相对于 <span
class="math inline">\(s_0\)</span> 的同伦，所有这样的同伦类（<span
class="math inline">\(S^n\xrightarrow{\gamma}X,\gamma(s_0)=p\)</span>）也可以构成群，记作
<span class="math inline">\(\pi_n\)</span>，<span
class="math inline">\(n\)</span> 维同伦群。（本课只研究 <span
class="math inline">\(n=1\)</span> 情形）</p></li>
</ul>
<h2 id="基本群">12. 基本群</h2>
<h3 id="基本群-1">基本群</h3>
<ul>
<li><h4 id="回忆基本群的定义">回忆：基本群的定义</h4>
<p><span class="math inline">\(\pi_1(X,p)=\set{&lt;\gamma&gt;\mid
\gamma\text{ loop at } p}\)</span>，其中 <span
class="math inline">\(\gamma\)</span> 是一个基础点为 <span
class="math inline">\(p\)</span> 的环路。</p>
<ul>
<li><h5 id="注基本群定义的推广">注：基本群定义的推广</h5>
<p>对基本群的定义我们有如下的推广：令 <span
class="math inline">\(\gamma_1,\gamma_2\in X\)</span> 是两个道路，使得
<span
class="math inline">\(\gamma_1(1)=\gamma_2(0)\)</span>，我们还可以令
<span class="math inline">\(\gamma_1\cdot
\gamma_2(s)=\begin{cases}\gamma_1(2s)&amp;0\leq s\leq
1/2\\\gamma_2(2s-1)&amp;1/2\leq s\leq 1\end{cases}\)</span>，这是 <span
class="math inline">\(\gamma_1\)</span> 与 <span
class="math inline">\(\gamma_2\)</span> 的拼接。</p>
<p>如果我们如此操作则可以得到下述性质：</p>
<ul>
<li>若 <span class="math inline">\(\gamma_1\simeq \gamma_1&#39;\text{
rel }\set{0,1},\gamma_2\simeq\gamma_2&#39;\text{ rel
}\set{0,1}\)</span>，则 <span class="math inline">\(\gamma_1\cdot
\gamma_2\simeq \gamma_1&#39;\cdot\gamma_2&#39;\text{ rel
}\set{0,1}\)</span>.</li>
<li>若 <span class="math inline">\(\gamma_1(1)=\gamma_2(0),
\gamma_2(1)=\gamma_3(0)\)</span>，则 <span
class="math inline">\(\gamma_1\cdot(\gamma_2\cdot\gamma_3)\simeq
(\gamma_1\cdot\gamma_2)\cdot\gamma_3\text{ rel }\set{0,1}\)</span>.</li>
<li>令 <span
class="math inline">\(\gamma^{-1}(s)=\gamma(1-s)\)</span>，则 <span
class="math inline">\(\gamma\cdot\gamma^{-1}\simeq \text{constant path
at } \gamma(0)\text{ rel }\set{0,1}\)</span>，且 <span
class="math inline">\(\gamma^{-1}\cdot\gamma\simeq \text{constant path
at }\gamma(1)\text{ rel }\set{0,1}\)</span>.</li>
</ul>
<p>不难注意到这些性质与我们定义基本群时类似。</p></li>
</ul>
<p>问：令 <span class="math inline">\(X\)</span> 是道路连通空间，问
<span class="math inline">\(\pi_1(X,p)\)</span> 是否依赖于 <span
class="math inline">\(p\)</span> 的选取？</p></li>
<li><h4 id="pi_1-群的结构与-p-的选取无关"><span
class="math inline">\(\pi_1\)</span> 群的结构与 <span
class="math inline">\(p\)</span> 的选取无关</h4>
<p>令 <span class="math inline">\(X\)</span> 是道路连通，则任取两个点
<span class="math inline">\(p,q\in X\)</span>，<span
class="math inline">\(\pi_1(X,p)\)</span> 与 <span
class="math inline">\(\pi_1(X,q)\)</span> 是同构的。我们将同构类记作
<span class="math inline">\(\pi_1(X)\)</span>.</p>
<p>证明：</p>
<p>选取道路 <span class="math inline">\(\gamma\)</span> 连接 <span
class="math inline">\(p\)</span> 与 <span
class="math inline">\(q\)</span>，定义一个映射 <span
class="math inline">\(\gamma_\star:\pi_1(X,p)\to\pi_1(X,q)\)</span>, 有
<span class="math inline">\(&lt;\alpha&gt;\to
&lt;\gamma^{-1}\cdot\alpha\cdot\gamma&gt;\)</span></p>
<figure>
<img src="\12-1.png" alt="image-20231102100352405" />
<figcaption aria-hidden="true">image-20231102100352405</figcaption>
</figure>
<p>由注的第一条，我们有 <span
class="math inline">\(\gamma_\star\)</span> 是良定义的；</p>
<p>由注的第二、第三条，有 <span
class="math inline">\(\begin{aligned}\gamma_\star(&lt;\alpha&gt;\cdot&lt;\beta&gt;)&amp;=&lt;\gamma^{-1}\cdot
\alpha\cdot\beta\cdot\gamma&gt;=&lt;\gamma^{-1}\alpha\gamma
\gamma^{-1}\beta\gamma&gt;\\&amp;=&lt;\gamma^{-1}\alpha\gamma&gt;&lt;\gamma^{-1}\beta\gamma&gt;=\gamma_\star(\alpha)\cdot\gamma_\star(\beta)\end{aligned}\)</span>（式中省略了一些乘号）</p>
<p>因此 <span class="math inline">\(\gamma_\star\)</span>
是一个群同态；</p>
<p>那么 <span class="math inline">\(\gamma_\star\)</span>
是否是群同构呢？由第三条，我们知道 <span
class="math inline">\((\gamma^{-1})_\star\)</span> 是 <span
class="math inline">\(\gamma_\star\)</span>
的逆，因此正反映射都是群同态，<span
class="math inline">\(\gamma_\star\)</span> 是群同构。</p>
<ul>
<li><h5 id="连续映射诱导基本群群同态">连续映射诱导基本群群同态</h5>
<p>思考： 拓扑空间 <span class="math inline">\(X\)</span>对应了一个
<span class="math inline">\(\pi_1\)</span> 群，若 <span
class="math inline">\(f:X\to Y\)</span> 连续映射，该映射是否诱导 <span
class="math inline">\(\pi_1\)</span> 群之间的同态呢？</p>
<p>事实上，令 <span class="math inline">\(p\in X\)</span>，<span
class="math inline">\(f(p)=q\in Y\)</span>，<span
class="math inline">\(\alpha:[0,1]\to X\)</span> 是一个环路，考虑 <span
class="math inline">\(f\circ \alpha\)</span>，则这得到了 <span
class="math inline">\(Y\)</span> 中一个基本点为 <span
class="math inline">\(q\)</span> 的环路。</p>
<p>如果 <span class="math inline">\(\alpha\simeq\alpha_1\text{ rel
}\set{0,1}\)</span>，自然有 <span
class="math inline">\(f\circ\alpha\simeq f\circ\alpha_1\text{ rel
}\set{0,1}\)</span>.</p>
<p>因此我们得到映射，记作 <span
class="math inline">\(f_\star:\pi_1(X,p)\to\pi_1(Y,q)\)</span>，<span
class="math inline">\(&lt;\alpha&gt;\to&lt;f\circ\alpha&gt;\)</span>.</p>
<p>我们验证它是群同态：</p>
<p><span
class="math inline">\(f_\star(&lt;\alpha&gt;&lt;\beta&gt;)=f_\star(&lt;\alpha\cdot\beta&gt;)=&lt;(f\circ\alpha)(f\circ\beta)&gt;=f_\star(&lt;\alpha&gt;)f_\star(&lt;\beta&gt;)\)</span>.</p>
<p>其自然是一个群同态。</p></li>
</ul></li>
<li><h4
id="连续映射诱导群同态映射的基本性质">连续映射诱导群同态映射的基本性质</h4>
<p>令 <span class="math inline">\(f:X\to Y\)</span>，<span
class="math inline">\(g:Y\to Z\)</span> 是两个连续映射，则 <span
class="math inline">\((g\circ f)_\star=g_\star\circ
f_\star\)</span>，<span
class="math inline">\((id_X)_\star=id_{\pi_1(X)}\)</span>。</p>
<p>证明：</p>
<p><span class="math inline">\((g\circ
f)_\star(&lt;\alpha&gt;)=&lt;g\circ f\circ\alpha&gt;=g_\star(&lt;f\circ
\alpha&gt;)=g_\star\circ f_\star(\alpha)\)</span>.</p>
<p><span
class="math inline">\((id_{X})_\star(&lt;\alpha&gt;)=&lt;id_X\circ\alpha&gt;=&lt;\alpha&gt;\)</span>.</p></li>
<li><h4
id="同胚映射诱导基本群的同构映射">同胚映射诱导基本群的同构映射</h4>
<p>若 <span class="math inline">\(f:X\to Y\)</span> 是一个同胚映射，则
<span class="math inline">\(f_\star\)</span> 是一个群同构。</p>
<p>证明：考虑 <span class="math inline">\(X\xrightarrow{f}
Y\xrightarrow{f^{-1}} X\)</span>，<span
class="math inline">\(Y\xrightarrow{f^{-1}}X\xrightarrow{f}Y\)</span>.</p>
<p>于是 <span class="math inline">\((f^{-1})_\star\circ
f_\star=(f^{-1}\circ f)_\star=(id_X)_\star=id_{\pi_1(X)}\)</span>, <span
class="math inline">\(f_\star\circ (f^{-1})_\star=(f\circ
f^{-1})_\star=(id_Y)_\star=id_{\pi_1(Y)}\)</span>.</p>
<p>自然，<span class="math inline">\(f_\star\)</span>
是一个同构。</p></li>
<li><h4 id="基本群是拓扑不变量">基本群是拓扑不变量</h4>
<p>根据上面的定理，我们可以看出 <span
class="math inline">\(\pi_1(X)\)</span>
确实是一个拓扑不变量。（由于同胚映射保持基本群同构）</p>
<ul>
<li><h5 id="注基本群定义出的函子-functor">注：基本群定义出的函子
(Functor)</h5>
<p>事实上，在先前的构造中，我们构造了一个叫做<strong>函子
(Functor)</strong> 的结构 <span
class="math inline">\(\pi_1\)</span>，它给出了一个从所有带有基本点(base
point)的拓扑空间到群范畴的对应。</p>
<p>如果给定一个拓扑空间 <span class="math inline">\(X\)</span> 以及一个
base point <span class="math inline">\(p\)</span>，我们得到了一个 <span
class="math inline">\(\pi_1(X,p)\)</span> 的对应。</p>
<p>若给出 <span class="math inline">\(f:(X,p)\to
(Y,q)\)</span>，则这被对应到了 <span
class="math inline">\(f_\star:\pi_1(X,p)\to \pi_1(Y,q)\)</span>.</p>
<p>并且该对应满足 <span class="math inline">\((g\circ
f)_\star=g_\star\circ f_\star\)</span>，<span
class="math inline">\((id_X)_\star=id_{\pi_1(X,p)}\)</span>.</p>
<p>（回忆：拓扑学范畴研究的是<strong>对象</strong>与<strong>态射</strong>）</p></li>
</ul></li>
<li><h4 id="基本群的例子">基本群的例子</h4>
<ul>
<li><h5 id="mathbbrn-中凸集的基本群"><span
class="math inline">\(\mathbb{R}^n\)</span> 中凸集的基本群</h5>
<p>设 <span class="math inline">\(C\subset \mathbb{R}^n\)</span>，则
<span class="math inline">\(\pi_1(C)=\set{e}\)</span>.
（任意给一条环路，环路可以通过直线同伦达到恒等映射）</p>
<p>我们也称这种情况为<strong>单连通
(simply-connected)</strong>，即称拓扑空间 <span
class="math inline">\(X\)</span> 为<strong>单连通</strong>的，若 <span
class="math inline">\(X\)</span> 中的基本群为平凡群 <span
class="math inline">\(\set{e}\)</span>。</p></li>
<li><h5 id="圆周-s1-的基本群">圆周 <span
class="math inline">\(S^1\)</span> 的基本群</h5>
<p>令 <span class="math inline">\(S^1=\set{e^{2\pi i\theta}\mid 0\leq
\theta&lt;1}\)</span>.</p>
<figure>
<img src="\12-2.png" alt="image-20231102103319564" />
<figcaption aria-hidden="true">image-20231102103319564</figcaption>
</figure>
<p>若道路不转圈，则其跟恒等道路同伦；</p>
<p>还可以注意到顺时针转 <span class="math inline">\(k\)</span>
圈的道路彼此同伦。</p>
<p>我们猜想：<span
class="math inline">\(\pi_1(S^1)=\mathbb{Z}\)</span>.</p>
<p>令 <span class="math inline">\(\pi:\mathbb{R}\to S^1\)</span>，<span
class="math inline">\(x\to e^{2\pi ix}\)</span>.</p>
<p><span class="math inline">\(\forall
n\in\mathbb{Z}\)</span>，考虑道路：<span
class="math inline">\(\gamma_n(s)=ns\)</span>，<span
class="math inline">\(s\in [0,1]\)</span>.</p>
<p>考虑 <span
class="math inline">\(\pi\circ\gamma_n\)</span>，则它是一个 <span
class="math inline">\(S^1\)</span> 上的环路，基本点为 <span
class="math inline">\(1\in
S^1\)</span>。形象地看，这是一个这样的映射：</p>
<figure>
<img src="\12-3.png" alt="image-20231102104237549" />
<figcaption aria-hidden="true">image-20231102104237549</figcaption>
</figure>
<p>那么 <span class="math inline">\(\pi\circ\gamma_n\)</span> 就是沿着
<span class="math inline">\(S^1\)</span> 转 <span
class="math inline">\(n\)</span> 圈的道路。</p>
<p>我们期望证明下面的定理：令 <span
class="math inline">\(\phi:\mathbb{Z}\to \pi_1(S^1,1)\)</span>，<span
class="math inline">\(\phi(n):=&lt;\pi\circ\gamma_n&gt;\)</span>，则
<span class="math inline">\(\phi\)</span> 是一个群同构。</p>
<ul>
<li><h6 id="一个基本的观察">一个基本的观察</h6>
因为 <span class="math inline">\(\mathbb{R}\)</span> 是一个凸集，令
<span class="math inline">\(\gamma:[0,1]\to\mathbb{R}\)</span>，使得
<span class="math inline">\(\gamma(0)=0,\gamma(1)=n\)</span>，则 <span
class="math inline">\(\gamma\simeq \gamma_n\text{ rel
}\set{0,1}\)</span>，由直线同伦给出。</li>
</ul>
<p>我们首先证明下面的引理：</p>
<ul>
<li><h6 id="phi-是一个群同态"><span class="math inline">\(\phi\)</span>
是一个群同态</h6>
<p><span class="math inline">\(\phi\)</span> 是一个群同态。</p>
<p>证明：</p>
<p>我们想要证明 <span class="math inline">\(\phi(m+n)=\phi(m)\cdot
\phi(n),\forall m,n\in \mathbb{Z}\)</span>.</p>
<p>令 <span
class="math inline">\(\sigma:[0,1]\to\mathbb{R}\)</span>，<span
class="math inline">\(\sigma(s)=\gamma_n(s)+m\)</span>. 我们有 <span
class="math inline">\(\pi\circ\sigma=\pi\circ\gamma_n\)</span>.</p>
<p>并且，<span
class="math inline">\((\gamma_m\cdot\sigma)(0)=0\)</span>，<span
class="math inline">\((\gamma_m\cdot\sigma)(1)=m+n\)</span>.</p>
<p>因此 ，<span class="math inline">\(\phi(m+n)=&lt;\pi\circ
\gamma_{m+n}&gt;=&lt;\pi\circ(\gamma_m\cdot\sigma)&gt;\)</span>，最后一个等号由上面的观察给出。</p>
<p>于是这又可以写成 <span
class="math inline">\(&lt;(\pi\circ\gamma_m)\cdot(\pi\circ\sigma)&gt;=&lt;(\pi\circ\gamma_m)\cdot(\pi\circ\gamma_n)&gt;=\phi(m)\cdot\phi(n)\)</span>.</p>
<p>因此这是一个群同态。</p></li>
<li><h6 id="道路提升引理-path-lifting-lemma">道路提升引理 (Path-lifting
Lemma)</h6>
<p>考虑道路 <span class="math inline">\(\sigma:[0,1]\to
S^1\)</span>，使得 <span
class="math inline">\(\sigma(0)=1\)</span>。那么 <span
class="math inline">\(\exists!\tilde\sigma:[0,1]\to
\mathbb{R}\)</span>（存在且唯一），使得 <span
class="math inline">\(\tilde\sigma(0)=0\)</span> 且 <span
class="math inline">\(\pi\circ\tilde\sigma=\sigma\)</span>.</p>
<p>此时我们将 <span class="math inline">\(\tilde\sigma\)</span> 称为
<span class="math inline">\(\sigma\)</span> 的一个<strong>提升
(Lift)</strong>。</p>
<p>直观来看，这就是在说</p>
<figure>
<img src="\12-4.png" alt="image-20231102105452748" />
<figcaption aria-hidden="true">image-20231102105452748</figcaption>
</figure>
<p>如图所示的道路对应是唯一的。（这也能从直观上解释为什么引理是正确的）</p>
<p>证明：</p>
<p>令 <span class="math inline">\(U=S^1\setminus\set{-1}\)</span>，<span
class="math inline">\(V=S^1\setminus\set{1}\)</span>.</p>
<p>有 <span class="math inline">\(\set{U,V}\)</span> 是 <span
class="math inline">\(S^1\)</span> 的开覆盖，并且 <span
class="math inline">\(\pi|_{(n-1/2,n+1/2)}:(n-1/2,n+1/2)\to U\)</span>
同胚；<span class="math inline">\(\pi|_{(n,n+1)}:(n,n+1)\to V\)</span>
同胚（<span class="math inline">\(\forall n\in
\mathbb{Z}\)</span>）。</p>
<p>由于 <span class="math inline">\([0,1]\)</span>
是一个紧度量空间，根据 Lebesgue 引理，<span
class="math inline">\(\exists
0=t_0&lt;t_1&lt;\cdots&lt;t_n=1\)</span>，有 <span
class="math inline">\([t_i,t_{i+1}]\subset \sigma^{-1}(U)\)</span> 或
<span class="math inline">\(\sigma^{-1}(V)\)</span>.</p>
<p>（</p>
<p>回忆：</p>
<p><strong>Lebesgue 引理 (Lebesgue's Lemma)</strong></p>
<p>令 <span class="math inline">\(X\)</span> 是一个紧的度量空间，令
<span class="math inline">\(X=\bigcup_\alpha U_\alpha\)</span> 是 <span
class="math inline">\(X\)</span> 的开覆盖。则 <span
class="math inline">\(\exists \delta&gt;0\)</span>，将 <span
class="math inline">\(\delta\)</span> 称作关于 <span
class="math inline">\(X\)</span> 的开覆盖 <span
class="math inline">\(\set{U_\alpha}\)</span> 的 <strong>Lebesgue 数
(Lebesgue Number)</strong>，使得 <span class="math inline">\(\forall
X\)</span> 的子集，若其直径小于 <span
class="math inline">\(\delta\)</span>，则其一定被包含在某一个 <span
class="math inline">\(U_\alpha\)</span> 里。</p>
<p>）</p>
<p>因为 <span class="math inline">\(\sigma(0)=1\not\in V\)</span>，有
<span class="math inline">\(\sigma([0,t_1])\subset U\)</span>. 令 <span
class="math inline">\(f=(\pi|_{(-1/2,1/2)})^{-1}\)</span>，令 <span
class="math inline">\(\tilde\sigma(s)=f\circ \sigma(s),0\leq s\leq
t_1\)</span>，于是 <span
class="math inline">\(\pi\circ\tilde\sigma(s)=\sigma(s)\)</span>.</p>
<p>假设我们已经在 <span class="math inline">\([0,t_k]\)</span>
上定义好了 <span
class="math inline">\(\tilde\sigma\)</span>，我们将其延拓到 <span
class="math inline">\([0,t_{k+1}]\)</span> 上。</p>
<p>若 <span class="math inline">\(\sigma([t_k,t_{k+1}])\subset
U\)</span>，假设 <span
class="math inline">\(\sigma([t_k,t_{k+1}])\subset(n-1/2,n+1/2),n\in
\mathbb{Z}\)</span>.</p>
<p>那么令 <span
class="math inline">\(g:=(\pi|_{(n-1/2,n+1/2)})^{-1}\)</span>，令 <span
class="math inline">\(\tilde\sigma(s)=g\circ\sigma(s),t_k\leq s\leq
t_{k+1}\)</span>，于是 <span
class="math inline">\(\pi\circ\tilde\sigma=\sigma,0\leq s\leq
t_{k+1}\)</span>.</p>
<p>若 <span class="math inline">\(\sigma([t_k,t_{k+1}])\subset
V\)</span>，假设 <span
class="math inline">\(\sigma([t_k,t_{k+1}])\subset (n,n+1),n\in
\mathbb{Z}\)</span>，于是令 <span
class="math inline">\(h:=(\pi|_{n,n+1})^{-1}\)</span>，令 <span
class="math inline">\(\tilde\sigma(s)=h\circ\sigma(s),t_k\leq s\leq
t_{k+1}\)</span>，于是 <span
class="math inline">\(\pi\circ\tilde\sigma=\sigma,0\leq s\leq
t_{k+1}\)</span>.</p>
<p>由归纳法，我们总可以将 <span class="math inline">\(\sigma\)</span>
提升为 <span class="math inline">\(\tilde\sigma\)</span>.</p>
<p>唯一性由每一步提升的唯一性即得。</p></li>
<li><h6 id="同伦提升引理-homotopy-lifting-lemma">同伦提升引理
(Homotopy-lifting Lemma)</h6>
<p>若考虑同伦 <span class="math inline">\(F:I\times I\to S^1\)</span>
连续映射，使得 <span class="math inline">\(F(0,t)=F(1,t)=1,\forall 0\leq
t\leq 1\)</span>，即该同伦保持 <span
class="math inline">\(\set{0,1}\)</span> 不动。</p>
<p>则 <span class="math inline">\(\exists! \tilde F:I\times I\to
\mathbb{R}\)</span>，使得 <span class="math inline">\(\pi\circ \tilde F=
F\)</span>（提升条件），<span class="math inline">\(\tilde F(0,t)=0,
\forall 0\leq t\leq 1\)</span>（初始条件）。</p>
<p>证明：</p>
<p>证明的思路与道路提升引理类似。</p>
<p>由于 <span class="math inline">\(I\times I\)</span>
也是一个紧的度量空间，由于 Lebesgue 引理，<span
class="math inline">\(\exists
0=s_0&lt;s_1&lt;\cdots&lt;s_m=1,0=t_1&lt;t_2&lt;\cdots&lt;t_k=1\)</span>，使得
<span class="math inline">\([s_i,s_{i+1}]\times[t_j,t_{j+1}]\subset
F^{-1}(U)\)</span> 或 <span
class="math inline">\(F^{-1}(V)\)</span>，其中 <span
class="math inline">\(U=S^1\setminus\set{-1}\)</span>，<span
class="math inline">\(V\in S^1\setminus\set{1}\)</span>.</p>
<p>由于 <span class="math inline">\(F(\set{0}\times [0,t_1])=1\not\in
V\)</span>，则令 <span
class="math inline">\(f=(\pi|_{(-1/2,1/2)})^{-1}\)</span>，令 <span
class="math inline">\(\tilde F(s,t)=f\circ F(s,t), \forall s,t\in
[0,s_1]\times [0,t_1]\)</span>.</p>
<p>之后的证明，可以对两个指标做归纳法，于是 <span
class="math inline">\(\exists!\tilde F\)</span> 使得 <span
class="math inline">\(\pi\circ\tilde F=F\)</span>，且 <span
class="math inline">\(\tilde F(0,t)=0,\forall 0\leq t\leq
1\)</span>.</p></li>
</ul>
<p>在有了上述两个引理后，我们现在可以证明 <span
class="math inline">\(\pi_1(S^1,1)\cong \mathbb{Z}\)</span> 了，即 <span
class="math inline">\(\phi:\mathbb{Z}\to
\pi_1(S^1,1),\phi(n)=&lt;\pi\circ\gamma_n&gt;\)</span>
是一个群同构。</p>
<p>证明：</p>
<p>根据我们的引理，这是一个群同态。我们只需要证明单、满射。</p>
<p>满射：由道路提升引理，我们可以看出 <span
class="math inline">\(\phi\)</span> 是一个满射。</p>
<p>单射：假设 <span class="math inline">\(\phi(n)=e\in
\pi_1(S^1,1)\)</span>，则由定义 <span class="math inline">\(\exists
F:I\times I\to S^1\)</span>，使得 <span
class="math inline">\(F(s,0)\)</span> 是常数道路，<span
class="math inline">\(F(s,1)=\pi\circ\gamma_n(s)\)</span>，其中 <span
class="math inline">\(F(0,t)=F(1,t)=1\in S^1,\forall t\)</span>.</p>
<p>由同伦提升引理，<span class="math inline">\(\exists\tilde F:I\times
I\to \mathbb{R}\)</span>，由 <span class="math inline">\(\pi\circ \tilde
F=F,\tilde F(0,t)=0\)</span>.</p>
<p>考虑子空间 <span class="math inline">\(A=I\times \set{0}\cup
\set{0}\times I\cup \set{1}\times I\)</span>，<span
class="math inline">\(A\)</span> 形如：</p>
<figure>
<img src="\12-5.png" alt="image-20231102112133116" />
<figcaption aria-hidden="true">image-20231102112133116</figcaption>
</figure>
<p>根据定义，我们有 <span class="math inline">\(F(A)=\set{1}\subseteq
S^1\)</span>.</p>
<p>由于 <span class="math inline">\(\pi\circ \tilde F=F\)</span>，于是
<span class="math inline">\(\tilde
F(A)\subseteq\mathbb{Z}\)</span>。</p>
<p>由于 <span class="math inline">\(A\)</span> 是连通的，有 <span
class="math inline">\(\tilde F(A)=\set{m}\)</span>，对于某个整数 <span
class="math inline">\(m\)</span>.</p>
<p>由于 <span class="math inline">\(\tilde F(0,t)=0\)</span>，有 <span
class="math inline">\(\tilde F(A)=\set{0}\)</span>.</p>
<p>由于 <span class="math inline">\(\tilde F(s,1)\)</span> 是 <span
class="math inline">\(\pi\circ\gamma_n\)</span>
的提升，根据道路提升的唯一性，有 <span class="math inline">\(\tilde
F(s,1)=\gamma_n\)</span>，于是 <span
class="math inline">\(n=\gamma_n(1)=\tilde F(1,1)=0\)</span>.</p>
<p>于是 <span class="math inline">\(\phi\)</span> 是单射。</p></li>
</ul></li>
</ul>
<h2 id="基本群与同伦等价">13. 基本群与同伦等价</h2>
<h3 id="圆周的基本群">圆周的基本群</h3>
<ul>
<li><h4 id="回忆圆周的基本群">回忆：圆周的基本群</h4>
<p><span class="math inline">\(\pi_1(S^1)\cong
\mathbb{Z}\)</span>.</p></li>
<li><h4
id="应用brouwer-不动点定理-brouwer-fixed-point-theorem">应用：Brouwer
不动点定理 (Brouwer Fixed-Point Theorem)</h4>
<p>考虑单位球 <span
class="math inline">\(B\)</span>，其维数为任意，考虑一个连续映射 <span
class="math inline">\(f:B\to B\)</span>，那么一定 <span
class="math inline">\(\exists x\in B\)</span> 使得 <span
class="math inline">\(f(x)=x\)</span>.</p>
<p>证明：</p>
<p>我们这里只证明 <span class="math inline">\(\text{dim}\leq 2\)</span>
的情形，通常情况以后会学到。</p>
<p>首先看 <span class="math inline">\(\text{dim}=1\)</span> 的情形。</p>
<p><span class="math inline">\(B=[-1,1]\subset \mathbb{R}\)</span>.
这就是在说 <span class="math inline">\(f:[-1,1]\to[-1,1]\)</span>
连续，该映射有不动点。</p>
<p>考虑下图，</p>
<figure>
<img src="\13-1.png" alt="image-20231107152556826" />
<figcaption aria-hidden="true">image-20231107152556826</figcaption>
</figure>
<p>这就是在说橙色的函数图像与绿色对角线有交点。</p>
<p>假设 <span class="math inline">\(f(x)\neq x\)</span>, <span
class="math inline">\(\forall x\in I\)</span>，那么令 <span
class="math inline">\(A=\set{x\in I\mid f(x)&lt;x}\)</span>，<span
class="math inline">\(B=\set{x\in I\mid f(x)&gt;x}\)</span>，那么有
<span class="math inline">\(I=A\sqcup B\)</span>.</p>
<p>由于 <span class="math inline">\(f(-1)\neq -1\)</span>，有 <span
class="math inline">\(f(-1)&gt;-1\)</span>，且 <span
class="math inline">\(f(1)\neq 1\)</span>，有 <span
class="math inline">\(f(1)&lt;1\)</span>.</p>
<p>因此 <span class="math inline">\(A\neq \varnothing, B\neq
\varnothing\)</span>.</p>
<p>我们考察 <span class="math inline">\(A,B\)</span> 集合的开闭性。令
<span class="math inline">\(g(x)=f(x)-x\)</span>，有 <span
class="math inline">\(g:[-1,1]\to \mathbb{R}\)</span> 且 <span
class="math inline">\(g\)</span> 是连续映射。</p>
<p>于是 <span class="math inline">\(A=g^{-1}(-\infty,0),
B=g^{-1}(0,+\infty)\)</span>. 从而 <span
class="math inline">\(A,B\)</span> 均为开集，这将连通的 <span
class="math inline">\([-1,1]\)</span>
区间分解为了两个非空开集的不交并，矛盾！</p>
<p>接着考察 <span class="math inline">\(\text{dim}=2\)</span>
的情形。</p>
<p>令 <span class="math inline">\(D=\set{(x,y)\mid x^2+y^2\leq
1}\)</span>，这是一个二维的球。假设 <span class="math inline">\(\exists
f:D\to D\)</span> 连续且 <span class="math inline">\(\forall x\in
D,f(x)\neq x\)</span>.</p>
<p>那么 <span class="math inline">\(\forall x\in D\)</span>，考虑射线
<span class="math inline">\((f(x),x)\)</span>，延长直到射线与圆周 <span
class="math inline">\(S^1\subseteq D\)</span> 相交。将与圆周的交点记作
<span class="math inline">\(g(x)\)</span>.</p>
<p>那么 <span class="math inline">\(g(x):D\to S^1\)</span>
映射，如图所示：</p>
<figure>
<img src="\13-2.png" alt="image-20231107153403741" />
<figcaption aria-hidden="true">image-20231107153403741</figcaption>
</figure>
<p>由于 <span class="math inline">\(f\)</span> 是连续的，并且 <span
class="math inline">\(f(x)\neq x\)</span>，因此 <span
class="math inline">\(g\)</span> 也是连续的。</p>
<p>并且若将 <span class="math inline">\(g\)</span> 限制在 <span
class="math inline">\(S^1\)</span> 上，有 <span
class="math inline">\(g\)</span> 是一个恒等映射，即 <span
class="math inline">\(g|_{S^1}=id|_{S^1}\)</span>。</p>
<p>如果我们考虑嵌入映射：<span class="math inline">\(i:S^1\to
D\)</span>，那么 <span class="math inline">\(g\circ i:S^1\to D\to
S^1\)</span> 是恒等映射。</p>
<p>那么 <span class="math inline">\((g\circ
i)_\star\)</span>（连续映射诱导的群同态）<span
class="math inline">\(=g_\star\circ
i_\star=(id|_{S^1})_\star=id_{\pi_1(S^1)}\)</span>.</p>
<p>那么定有 <span class="math inline">\(g_\star\)</span> 是满射，但由于
<span class="math inline">\(\pi_1(S^1)\cong\mathbb{Z}\)</span>，<span
class="math inline">\(D\subseteq \mathbb{R}^2\)</span>
是一个凸集，这意味着 <span class="math inline">\(\pi_1(D)\)</span>
是一个平凡群 <span class="math inline">\(\set{e}\)</span>，因此 <span
class="math inline">\(g_\star:\pi_1(D)\to \pi_1(S^1)\)</span>
不可能是一个满射，矛盾。</p></li>
</ul>
<h3 id="基本群-2">基本群</h3>
<ul>
<li><h4 id="单连通空间的判别">单连通空间的判别</h4>
<p>考虑 <span class="math inline">\(X\)</span> 中两个开集 <span
class="math inline">\(U,V\)</span>，使得 <span
class="math inline">\(X=U\cup V\)</span>. 如果 <span
class="math inline">\(U, V\)</span> 都是单连通的（<span
class="math inline">\(\pi_1(U)=\pi_1(V)=\set{e}\)</span>，事实上，<span
class="math inline">\(U,V\)</span> 此时是道路连通的），并假设 <span
class="math inline">\(U\cap V\)</span> 是道路连通的，那么 <span
class="math inline">\(X\)</span> 是单连通的，也就是 <span
class="math inline">\(\pi_1(X)=\set{e}\)</span>。</p>
<p>证明：</p>
<p>固定 <span class="math inline">\(p\in U\cap V\)</span>，考虑环路
<span class="math inline">\(\alpha:I=[0,1]\to X\)</span> 拥有基础点
<span class="math inline">\(p\)</span>.</p>
<p>那么 <span class="math inline">\(I=[0,1]\)</span>
也有一个开覆盖：<span class="math inline">\(\alpha^{-1}(U)\cup
\alpha^{-1}(V)\)</span>，由于 <span class="math inline">\(I\)</span>
是一个紧的度量空间，由 Lebesgue 引理，<span
class="math inline">\(\exists
0=t_0&lt;t_1&lt;\cdots&lt;t_n=1\)</span>，使得 <span
class="math inline">\([t_k,t_{k+1}]\subset\alpha^{-1}(U)\)</span> 或
<span class="math inline">\(\alpha^{-1}(V)\)</span>.</p>
<p>令 <span class="math inline">\(\alpha_k(s)=\alpha((t_k-t_{k-1})\cdot
s+t_{k-1}),s\in [0,1]\)</span> （<span
class="math inline">\(\alpha\)</span> 限制在 <span
class="math inline">\([t_{k-1},t_{k}]\)</span> 上），则 <span
class="math inline">\(\alpha_k(0)=\alpha(t_{k-1}),\alpha_k(1)=\alpha(t_k)\)</span>.</p>
<p>如果 <span class="math inline">\(\alpha(t_k)\in U\)</span>，我们连接
<span class="math inline">\(p\)</span> 与 <span
class="math inline">\(\alpha(t_k)\)</span>，得到道路 <span
class="math inline">\(\gamma_k\subset U\)</span>.</p>
<p>同理，若 <span class="math inline">\(\alpha(t_k)\in
V\)</span>，我们连接 <span class="math inline">\(p\)</span> 与 <span
class="math inline">\(\alpha(t_k)\)</span>，得到道路 <span
class="math inline">\(\gamma_k\subset V\)</span>.</p>
<p>若 <span class="math inline">\(\alpha(t_k)\in U\cap
V\)</span>，我们连接 <span class="math inline">\(p\)</span> 与 <span
class="math inline">\(\alpha(t_k)\)</span>，得到道路 <span
class="math inline">\(\gamma_k\subset U\cap V\)</span>（由于 <span
class="math inline">\(U\cap V\)</span> 道路连通，这可以做到）。</p>
<p>于是有 <span
class="math inline">\(\alpha\simeq(\alpha_1\gamma_1^{-1})(\gamma_1\alpha_2\gamma_2^{-1})\cdots(\gamma_{n-1}\alpha_n)\text{
rel}\set{0, 1}\)</span>.</p>
<figure>
<img src="\13-3.png" alt="image-20231107155631257" />
<figcaption aria-hidden="true">image-20231107155631257</figcaption>
</figure>
<p>如图所示，我们事实上是做了一个环路的分解。</p>
<p>括号中的每个环路都是 <span class="math inline">\(U\)</span> 或 <span
class="math inline">\(V\)</span> 中的环路。由于 <span
class="math inline">\(U\)</span> 与 <span
class="math inline">\(V\)</span> 都是单连通区间，我们有 <span
class="math inline">\(\gamma_k\alpha_{k+1}\gamma_{k+1}^{-1}\simeq
e\text{ rel}\set{0,1}\)</span>.</p>
<p>因此 <span class="math inline">\(\alpha\simeq e\text{
rel}\set{0,1}\)</span>.</p>
<p>因此 <span class="math inline">\(X\)</span> 确实是单连通区域，<span
class="math inline">\(\pi_1(X)\cong \set{e}\)</span>。</p></li>
<li><h4 id="高位球面的基本群是平凡群">高位球面的基本群是平凡群</h4>
<p>高维球面 <span class="math inline">\(S^n\)</span>
的基本群是平凡群，即 <span
class="math inline">\(\pi_1(S^n)=\set{e}\)</span> 若 <span
class="math inline">\(n\geq 2\)</span>。</p>
<p>证明：</p>
<p>令 <span
class="math inline">\(U=S^n\setminus\set{(1,0,0,\cdots,0)}\)</span>，<span
class="math inline">\(V=S^n\setminus\set{(-1,0,0,\cdots,0)}\)</span>.</p>
<p>我们有 <span class="math inline">\(U,V\)</span> 都是开集，且 <span
class="math inline">\(S^n=U\cup V\)</span>，有 <span
class="math inline">\(U, V\)</span> 同胚于 <span
class="math inline">\(\mathbb{R}^n\)</span>，因此 <span
class="math inline">\(\pi_1(U)=\pi_1(V)=\set{e}\)</span>.</p>
<p>考察集合 <span class="math inline">\(U\cap V\)</span>，它同胚于 <span
class="math inline">\(\mathbb{R}^n\setminus\set{0}\)</span>，当 <span
class="math inline">\(n\geq 2\)</span> 时这是道路连通的空间。</p>
<p>因此 <span class="math inline">\(\pi_1(S^n)\)</span>
确实是平凡群。</p>
<p>（这个定理也解释了 <span class="math inline">\(U\cap V\)</span>
道路连通的必要性，因为当 <span class="math inline">\(n=1\)</span>
其他条件依然成立，但 <span
class="math inline">\(\mathbb{R}^1\setminus\set{0}\)</span>
不是道路连通）</p></li>
<li><h4
id="乘积空间的基本群同构于基本群的乘积">乘积空间的基本群同构于基本群的乘积</h4>
<p><span class="math inline">\(\pi_1(X\times Y)\cong \pi_1(X)\times
\pi_1(Y)\)</span>.</p>
<p>证明：</p>
<p>选择 <span class="math inline">\(x_0\in X,y_0\in Y\)</span>，选 <span
class="math inline">\((x_0,y_0)\)</span> 作为基本点。考察 <span
class="math inline">\(p_1,p_2\)</span> 为两个投影映射。</p>
<p>接下来我们构造一个群同态：令映射 <span
class="math inline">\(\phi:\pi_1(X\times Y)\to \pi_1(X)\times
\pi_1(Y)\)</span>.</p>
<p>其中 <span
class="math inline">\(&lt;\alpha&gt;\to((p_1)_\star(&lt;\alpha&gt;),(p_2)_\star(&lt;\alpha&gt;))\)</span>，<span
class="math inline">\(\alpha\)</span> 是 <span
class="math inline">\((x_0,y_0)\)</span> 处的环路。</p>
<p>我们想要验证这是一个同构。我们知道 <span
class="math inline">\(\phi\)</span>
是一个群同态，只需验证其为单射、满射。</p>
<p>记 <span class="math inline">\(e\in \pi_1(X\times Y), e_1\in
\pi_1(X), e_2\in \pi_1(Y)\)</span> 恒等元。</p>
<p>单射：</p>
<p>如果 <span class="math inline">\(p_1\circ\alpha \underset{F}{\simeq}
e_1\text{ rel}\set{0,1}, p_2\circ\alpha\underset{G}{\simeq} e_2\text{
rel}\set{0,1}\)</span></p>
<p>那么 <span class="math inline">\(\alpha\underset{(F,G)}{\simeq}
e\text{ rel}\set{0,1}\)</span>，于是 <span
class="math inline">\(\phi\)</span> 是一个单射。</p>
<p>满射：</p>
<p>令 <span class="math inline">\(\alpha\)</span> 是 <span
class="math inline">\(X\)</span> 中环路，令 <span
class="math inline">\(\beta\)</span> 是 <span
class="math inline">\(Y\)</span> 中环路。</p>
<p>令 <span
class="math inline">\(\gamma(s)=(\alpha(s),\beta(s))\)</span>，那么有
<span class="math inline">\(\gamma\)</span> 是乘积空间中的环路，并且
<span
class="math inline">\(p_1\circ\gamma=\alpha,p_2\circ\gamma=\beta\)</span>.</p>
<p>根据定义，<span
class="math inline">\(\phi(&lt;\gamma&gt;)=(&lt;\alpha&gt;,&lt;\beta&gt;)\)</span>.
因此 <span class="math inline">\(\phi\)</span> 是一个满射。</p>
<ul>
<li><h5 id="例子环面的基本群">例子：环面的基本群</h5>
<p>令 <span class="math inline">\(T\)</span> 是环面，我们知道 <span
class="math inline">\(T=S^1\times S^1\)</span>.</p>
<p>从而 <span
class="math inline">\(\pi_1(T)=\mathbb{Z}^2\)</span>.</p></li>
</ul></li>
</ul>
<h3 id="同伦等价-homotopy-equivalence">同伦等价 (Homotopy
Equivalence)</h3>
<ul>
<li><h4 id="回忆同胚的概念">回忆：同胚的概念</h4>
<p><span class="math inline">\(X,Y\)</span> 被称为是同胚的，如果 <span
class="math inline">\(\exists f:X\to Y,g:Y\to X\)</span> 连续映射，且
<span class="math inline">\(f\circ g=id_Y,g\circ f=id_X\)</span>。</p>
<p>注意到同胚的限制非常强，我们可否对这个限制进行放松？</p></li>
<li><h4 id="定义同伦等价-homotopy-equivalence">定义：同伦等价 (Homotopy
Equivalence)</h4>
<p>我们将 <span class="math inline">\(X,Y\)</span>
称作是<strong>同伦等价 (Homotopy Equivalent)</strong>的，若 <span
class="math inline">\(\exists f:X\to Y,g:Y\to X\)</span> 连续映射，且
<span class="math inline">\(g\circ f\simeq id_X,f\circ g\simeq
id_Y\)</span>.</p>
<p>此时 <span class="math inline">\(f,g\)</span>
被称为是<strong>同伦等价 (Homotopy Equivalence)</strong>，将 <span
class="math inline">\(f,g\)</span> 称为是对方的<strong>同伦逆 (Homotopy
Inverse)</strong>.</p>
<p>此时也记作 <span class="math inline">\(X\simeq Y\)</span>。</p>
<p>易知，<span class="math inline">\(X\cong Y\Rightarrow X\simeq
Y\)</span>.</p></li>
<li><h4 id="同伦等价的基本性质">同伦等价的基本性质</h4>
<ul>
<li><h5 id="同伦等价是一个等价关系">同伦等价是一个等价关系</h5>
<p>同伦等价是等价关系。</p>
<p>证明：</p>
<p>自反性：<span class="math inline">\(id_X:X\to X\)</span>
是一个同伦等价（这事实上是同胚），因此 <span
class="math inline">\(X\simeq X\)</span>.</p>
<p>对称性：由定义这自然是对称的。</p>
<p>传递性：若 <span class="math inline">\(X\simeq Y,Y\simeq
Z\)</span>，则 <span class="math inline">\(\exists\)</span>
下面的图表：</p>
<figure>
<img src="\13-4.png" alt="image-20231107162558406" />
<figcaption aria-hidden="true">image-20231107162558406</figcaption>
</figure>
<p>其中 <span class="math inline">\(g\circ f\simeq id_X,f\circ g\simeq
id_Y\)</span>, <span class="math inline">\(\phi\psi\simeq
id_Z,\psi\phi\simeq id_Y\)</span>.</p>
<p>于是 <span class="math inline">\(g\circ \psi\circ \phi\circ f\simeq
g\circ id_Y\circ f=g\circ f\simeq id_X\)</span>.</p>
<p><span class="math inline">\(\phi\circ f\circ g\circ\psi\simeq
\phi\circ id_Y\circ\psi=\phi\circ\psi\simeq id_Z\)</span></p>
<p>从而这是一个等价关系。</p></li>
<li><h5
id="构造同伦等价的一个基本例子形变收缩-deformation-retraction">构造同伦等价的一个基本例子：形变收缩
(Deformation Retraction)</h5>
<p><span class="math inline">\(A\subset X\)</span>，假设 <span
class="math inline">\(\exists F:X\times I\to X\)</span>，有 <span
class="math inline">\(F(x,0)=x,F(x,1)\in A\)</span>，且 <span
class="math inline">\(F(x,t)=x\)</span> 若 <span
class="math inline">\(x\in A\)</span>. 这意味着 <span
class="math inline">\(A\)</span> 中的点对 <span
class="math inline">\(F\)</span> 是不动点。则我们将 <span
class="math inline">\(F\)</span> 称作是一个从 <span
class="math inline">\(X\)</span> 到 <span
class="math inline">\(A\)</span> 的<strong>形变收缩 (Deformation
Retraction)</strong>.</p>
<p>直观上看，将 <span class="math inline">\(F\)</span> 看作一族从 <span
class="math inline">\(X\)</span> 到 <span
class="math inline">\(X\)</span> 的映射，这族映射从 <span
class="math inline">\(X\)</span> 逐渐收缩到 <span
class="math inline">\(A\)</span> 并保持 <span
class="math inline">\(A\)</span> 中点不动。</p>
<p>事实上，我们会有：<span class="math inline">\(X\simeq A\)</span>.</p>
<p>证明：</p>
<p>考虑 <span class="math inline">\(i:A\to X\)</span> 是嵌入映射以及映射
<span class="math inline">\(f(x)=F(x,1): X\to A\)</span>。</p>
<p>一方面，我们有 <span class="math inline">\(f\circ
i=id_A\)</span>。</p>
<p>另一方面，我们有 <span class="math inline">\(i\circ
f\underset{F}{\simeq} id_X\)</span>. 这是由于左侧为 <span
class="math inline">\(F(x,1)\)</span>，右侧为 <span
class="math inline">\(F(x,0)\)</span>，这直接给出了同伦。</p></li>
<li><h5 id="可缩空间-contractable-space">可缩空间 (Contractable
Space)</h5>
<p>我们称 <span class="math inline">\(X\)</span> 是<strong>可缩的
(Contractable)</strong>，若 <span class="math inline">\(id_X\)</span>
与某个常数映射 <span class="math inline">\(p\in X\)</span>
是同伦的。</p>
<p>令 <span class="math inline">\(i:p\to X\)</span> 是嵌入映射，令 <span
class="math inline">\(f=c_p:x\to p\)</span>，那么 <span
class="math inline">\(f\circ i=id_p\)</span>，<span
class="math inline">\(i\circ f\simeq id_X\)</span>，因此 <span
class="math inline">\(X\simeq\set{p}\)</span>.</p>
<p>换言之，可缩意味着空间在同伦意义上是平凡的。</p>
<p><strong>注</strong>：可缩并不意味着存在一个到单点的形变收缩，我们会在将来举例说明这一点。</p></li>
</ul></li>
<li><h4 id="同伦等价的例子">同伦等价的例子</h4>
<ul>
<li><h5 id="凸集是可缩的">凸集是可缩的</h5>
<p>令 <span class="math inline">\(X\)</span> 是欧氏空间 <span
class="math inline">\(\mathbb{R}^n\)</span> 中的凸集，则 <span
class="math inline">\(X\)</span>
是可缩的。更进一步地，它可以形变收缩到一个点。</p>
<p>证明：令 <span class="math inline">\(x_0=X\)</span>，令 <span
class="math inline">\(F(x,t)=(1-t)x+tx_0\)</span>，则 <span
class="math inline">\(F(x,0)=x,F(x,1)=x_0\)</span>，这给出了一个 <span
class="math inline">\(X\)</span> 上的形变收缩（直线收缩）。</p>
<figure>
<img src="\13-5.png" alt="image-20231107164246549" />
<figcaption aria-hidden="true">image-20231107164246549</figcaption>
</figure></li>
<li><h5 id="mathbbrnsetminusset0-可以形变收缩到-sn-1"><span
class="math inline">\(\mathbb{R}^n\setminus\set{0}\)</span>
可以形变收缩到 <span class="math inline">\(S^{n-1}\)</span></h5>
<p><span class="math inline">\(\mathbb{R}^n\setminus\set{0}\)</span>
可以形变收缩到 <span class="math inline">\(S^{n-1}\)</span>.</p>
<p>证明：</p>
<p>令 <span
class="math inline">\(F(x,t)=(1-t)x+t\cfrac{x}{|x|}\)</span>，则由于
<span class="math inline">\(x\in \mathbb{R}\setminus\set{0}\)</span>，有
<span class="math inline">\(|x|\neq 0\)</span>，故 <span
class="math inline">\(F\)</span> 是良定义的。</p>
<p>并且 <span class="math inline">\(F(x,0)=x,F(x,1)=\cfrac{x}{|x|}\in
S^{n-1}\)</span>，且有 <span class="math inline">\(F(x,t)=x,\forall x\in
S^{n-1}\)</span>.</p>
<p>故这给出了一个形变收缩。</p>
<figure>
<img src="\13-6.png" alt="image-20231107164633236" />
<figcaption aria-hidden="true">image-20231107164633236</figcaption>
</figure></li>
<li><h5 id="对圆柱进行形变收缩">对圆柱进行形变收缩</h5>
<figure>
<img src="\13-7.png" alt="image-20231107164851507" />
<figcaption aria-hidden="true">image-20231107164851507</figcaption>
</figure>
<p>如图所示，可以将圆柱“压缩”成一个圆形。</p>
<p>我们也可以用粘合映射来考察这一点：</p>
<figure>
<img src="\13-8.png" alt="image-20231107165059582" />
<figcaption aria-hidden="true">image-20231107165059582</figcaption>
</figure>
<p>注：什么时候粘合与形变压缩可以交换？只要在压缩前后，本来应该粘合在一起的点仍然粘合在一起，本来没有粘合在一起的点仍然没有粘合在一起，那么这两个操作就是可以交换的。需要具体例子具体分析。</p></li>
<li><h5 id="莫比乌斯带的同伦等价">莫比乌斯带的同伦等价</h5>
<p>留作作业：我们将在作业中证明莫比乌斯带是 <span
class="math inline">\(\simeq S^1\)</span> 的。</p></li>
</ul></li>
</ul>
<h2 id="同伦等价进一步研究">14. 同伦等价：进一步研究</h2>
<h3 id="同伦等价">同伦等价</h3>
<ul>
<li><h4 id="形变收缩的例子">形变收缩的例子</h4>
<ul>
<li><h5 id="去掉一点环面的形变收缩">去掉一点环面的形变收缩</h5>
<p><span class="math inline">\(X\)</span> 是环面，则 <span
class="math inline">\(X\setminus\set{p}\simeq S^1\cup S^1\)</span></p>
<p>考察粘合映射：</p>
<figure>
<img src="\14-1.png" alt="image-20231109095158768" />
<figcaption aria-hidden="true">image-20231109095158768</figcaption>
</figure>
<p>如图，所有点都可以往边界上收缩直到边界，最终得到：</p>
<figure>
<img src="\14-2.png" alt="image-20231109095336333" />
<figcaption aria-hidden="true">image-20231109095336333</figcaption>
</figure>
<p>从立体上看，这事实上也可以看成是构成环面的两个圆分别收缩：</p>
<figure>
<img src="\14-3.png" alt="image-20231109095450215" />
<figcaption aria-hidden="true">image-20231109095450215</figcaption>
</figure></li>
<li><h5
id="去掉一点实射影平面的形变收缩">去掉一点实射影平面的形变收缩</h5>
<p><span
class="math inline">\(\mathbb{R}P^2\setminus\set{p}\simeq\mathbb{R}P^1=S^1\)</span></p>
<p>同样地，考虑粘合，我们同样可以把所有内部点收缩到边界：</p>
<figure>
<img src="\14-4.png" alt="image-20231109095726778" />
<figcaption aria-hidden="true">image-20231109095726778</figcaption>
</figure>
<p>这事实上就是 <span
class="math inline">\(S^1/\mathbb{Z}_2=\mathbb{R}P^1=S^1\)</span>. 其中
<span class="math inline">\(-1\cdot x = -x\)</span>.</p></li>
</ul></li>
<li><h4
id="同伦映射诱导的基本群同态基本相同">同伦映射诱导的基本群同态基本相同</h4>
<p>考虑 <span class="math inline">\(f\underset{F}\simeq g:X\to
Y\)</span>，则 <span class="math inline">\(g_\star:\pi_1(X,p)\to
\pi(Y,g(p))\)</span>，它等于如下映射的复合：<span
class="math inline">\(\pi_1(X,p)\xrightarrow{f_\star}\pi_1(X,f(p))\xrightarrow{\gamma_\star}\pi_1(Y,g(p))\)</span>，其中
<span class="math inline">\(\gamma_\star\)</span>
为交换标志点（基本点）的同构，<span
class="math inline">\(\gamma\)</span> 是一条道路，<span
class="math inline">\(\gamma(s)=F(p,s)\)</span>，<span
class="math inline">\(\gamma_\star(&lt;\alpha&gt;)=&lt;\gamma^{-1}\cdot\alpha\cdot\gamma&gt;\)</span>.</p>
<p>证明：</p>
<p>选取 <span class="math inline">\(\alpha\)</span> 为 <span
class="math inline">\(X\)</span> 中的环路，其基本点为 <span
class="math inline">\(p\)</span>.</p>
<p>我们想要证明，<span class="math inline">\(g\circ\alpha\simeq
\gamma^{-1}\cdot(f\circ \alpha)\cdot \gamma\text{
rel}\set{0,1}\)</span>.</p>
<p>我们构造映射 <span class="math inline">\(G:I\times I\to
Y\)</span>，其中 <span
class="math inline">\(G(s,t)=F(\alpha(s),t)\)</span>.</p>
<p><span class="math inline">\(G\)</span> 的形状如下所示：</p>
<figure>
<img src="\14-5.png" alt="image-20231109100538640" />
<figcaption aria-hidden="true">image-20231109100538640</figcaption>
</figure>
<p>注意到我们想要证明的同伦就是正方形边界上的两条道路同伦。</p>
<p>令 <span class="math inline">\(\beta_1:I\to I\times I\)</span>，<span
class="math inline">\(\beta_1=\begin{cases}(0,2s)&amp;0\leq s\leq
1/2\\(2s-1,1)&amp;1/2\leq s\leq 1\end{cases}\)</span>.</p>
<figure>
<img src="\14-6.png" alt="image-20231109100757163" />
<figcaption aria-hidden="true">image-20231109100757163</figcaption>
</figure>
<p>令 <span class="math inline">\(\beta_2:I\to I\times I\)</span>，<span
class="math inline">\(\beta_2=\begin{cases}(2s,0)&amp;0\leq s\leq
1/2\\(1,2s-1)&amp;1/2\leq s\leq 1\end{cases}\)</span>.</p>
<figure>
<img src="\14-7.png" alt="image-20231109100846776" />
<figcaption aria-hidden="true">image-20231109100846776</figcaption>
</figure>
<p>由于正方形是一个凸集，并且 <span
class="math inline">\(\beta_1\)</span> 与 <span
class="math inline">\(\beta_2\)</span> 起点和终点一致，因此 <span
class="math inline">\(\beta_1\simeq\beta_2\text{
rel}\set{0,1}\)</span>.</p>
<p>因此 <span
class="math inline">\(\gamma\cdot(g\circ\alpha)=G\circ\beta_1\simeq
G\circ\beta_2=(f\circ\alpha)\cdot\gamma\text{
rel}\set{0,1}\)</span>.</p>
<p>从而 <span
class="math inline">\(g\circ\alpha\simeq\gamma^{-1}\cdot(f\circ\alpha)\cdot\gamma\text{
rel}\set{0,1}\)</span>.</p>
<p>由此我们证明结论。</p></li>
<li><h4
id="同伦等价空间的基本群相同基本群是同伦不变量">同伦等价空间的基本群相同（基本群是同伦不变量）</h4>
<p>若 <span class="math inline">\(X,Y\)</span> 是同伦等价的空间，则
<span class="math inline">\(\pi_1(X)\cong\pi_1(Y)\)</span>.</p>
<p>证明：</p>
<p>令 <span class="math inline">\(f:X\to Y, g:Y\to X\)</span>
是两个互为同伦逆的映射，即 <span
class="math inline">\(id_X\underset{F}\simeq g\circ
f,id_Y\underset{G}\simeq f\circ g\)</span>.</p>
<p>固定 <span class="math inline">\(p=g(q)\in X,q\in
Y\)</span>，我们想要证明 <span
class="math inline">\(f_\star:\pi_1(X,p)\to \pi_1(Y,f(p))\)</span>
是一个群同构。</p>
<p>考虑 <span class="math inline">\(\gamma\)</span> 是 <span
class="math inline">\(X\)</span> 里的道路，其中 <span
class="math inline">\(\gamma(s)=F(p,s)\)</span>，由上面的定理，有 <span
class="math inline">\((g\circ f)_\star=\gamma_\star:\pi_1(X,p)\to
\pi_1(X,g\circ f(p))\)</span>（<span
class="math inline">\(\gamma_\star\circ id_{X\star}= (g\circ
f)_\star\)</span>）</p>
<p>由于 <span class="math inline">\((g\circ f)_\star=g_\star\circ
f_\star\)</span> 是同构，有 <span class="math inline">\(f_\star\)</span>
是单射。</p>
<p>类似地，有 <span class="math inline">\((f\circ g)_\star:\pi_1(Y,q)\to
\pi_1(Y,f\circ g(q))\)</span> 是群同构，有 <span
class="math inline">\(f_\star\)</span> 是一个满射。</p>
<p>因此 <span class="math inline">\(f_\star\)</span> 是一个双射，<span
class="math inline">\(f_\star\)</span> 自然是同态，有 <span
class="math inline">\(f_\star\)</span> 是同构。</p></li>
<li><h4 id="形变收缩保持基本群">形变收缩保持基本群</h4>
<p>令 <span class="math inline">\(A\subset X\)</span> 是 <span
class="math inline">\(X\)</span> 的子空间，<span
class="math inline">\(\exists\)</span> 从 <span
class="math inline">\(X\)</span> 至 <span
class="math inline">\(A\)</span> 的形变收缩，则 <span
class="math inline">\(\pi_1(X)\cong\pi_1(A)\)</span>.</p>
<p>证明：由上面定理立得。</p></li>
<li><h4 id="可缩空间的基本群是平凡群">可缩空间的基本群是平凡群</h4>
<p>若 <span class="math inline">\(X\)</span> 是可缩的，则 <span
class="math inline">\(\pi_1(X)\cong\set{e}\)</span>.</p>
<p>证明：由上面定理立得。</p></li>
<li><h4 id="形变收缩的基本群">形变收缩的基本群</h4>
<p><span class="math inline">\(\mathbb{R}^n\setminus\set{0}\simeq
S^{n-1}\)</span>，因此 <span
class="math inline">\(\pi_1(\mathbb{R}^n\setminus\set{0})=\begin{cases}\mathbb{Z}&amp;n=2\\\set{e}&amp;n\geq
3\end{cases}\)</span>.</p>
<p>类似地，圆柱和莫比乌斯带的基本群都是 <span
class="math inline">\(\mathbb{Z}\)</span>.</p></li>
<li><h4 id="可缩空间的基本性质">可缩空间的基本性质</h4>
<p>以下给出关于可缩空间的性质：</p>
<ul>
<li><ol type="1">
<li><span class="math inline">\(X\)</span> 是可缩的等价于 <span
class="math inline">\(X\simeq\set{p}\)</span>；</li>
</ol></li>
<li><ol start="2" type="1">
<li>考虑两个映射 <span class="math inline">\(f,g:X\to Y\)</span>，其中
<span class="math inline">\(Y\)</span> 是一个可缩空间，则 <span
class="math inline">\(f\simeq g\)</span>；</li>
</ol></li>
<li><ol start="3" type="1">
<li><span class="math inline">\(X\)</span> 是可缩等价于 <span
class="math inline">\(id_X\simeq C_p,\forall p\in X\)</span>，其中 <span
class="math inline">\(C_p\)</span> 是映射至 <span
class="math inline">\(p\)</span> 的常数映射。</li>
</ol></li>
</ul>
<p>证明：</p>
<ol type="1">
<li></li>
</ol>
<p><span class="math inline">\((\Rightarrow)\)</span>: 显然；</p>
<p><span class="math inline">\((\Leftarrow)\)</span>: 设 <span
class="math inline">\(X\xrightarrow{f}\set{p},\set{p}\xrightarrow{g}X\)</span>，那么
<span class="math inline">\(g\circ f\underset{F}\simeq
id_{X}\)</span>，于是 <span class="math inline">\(F\)</span> 给出了一个
<span class="math inline">\(id_X\)</span> 到常数映射 <span
class="math inline">\(C_q(q=g(p))\)</span> 的同伦收缩，因此 <span
class="math inline">\(X\)</span> 是可缩空间。</p>
<ol start="2" type="1">
<li></li>
</ol>
<p><span class="math inline">\(f=id_Y\circ f\simeq C_p\circ
f\)</span>，其中 <span class="math inline">\(p\in Y,C_p\)</span>
为常数映射。</p>
<p>而 <span class="math inline">\(C_p\circ f=C_p\circ g\simeq id_Y\circ
g=g\)</span>.</p>
<p>因此 <span class="math inline">\(f\)</span> 与 <span
class="math inline">\(g\)</span> 同伦。</p>
<ol start="3" type="1">
<li></li>
</ol>
<p>令 <span class="math inline">\(id_X\simeq C_p\)</span>，<span
class="math inline">\(\forall x\in X\)</span>，由于 <span
class="math inline">\(X\)</span> 是可缩空间，根据 (2) 我们有 <span
class="math inline">\(C_x\simeq C_p\simeq id_X\)</span>.</p>
<ul>
<li><h5
id="注可缩与形变收缩到一个点并不等价">注：可缩与形变收缩到一个点并不等价</h5>
<p>令 <span class="math inline">\(X\)</span> 是可缩空间，<span
class="math inline">\(p\in X\)</span>，那么有可能出现 <span
class="math inline">\(\not\exists\)</span> 从 <span
class="math inline">\(X\)</span> 到 <span
class="math inline">\(\set{p}\)</span> 的形变收缩。</p>
<p>我们考虑如下反例：</p>
<p>令 <span class="math inline">\(X\)</span> 是一个“梳子空间”，这是说
<span class="math inline">\(X=([0,1]\times
\set{0})\cup(\bigcup_{n=1}^{\infty}\set{\cfrac{1}{n}}\times[0,1])\cup(
\set{0}\times [0,1])\)</span>，如下图所示：</p>
<figure>
<img src="\14-8.png" alt="image-20231109103602160" />
<figcaption aria-hidden="true">image-20231109103602160</figcaption>
</figure>
<p>令 <span class="math inline">\(p=(0,1)\in X\)</span>，则 <span
class="math inline">\(\not\exists\)</span> 从 <span
class="math inline">\(X\)</span> 至 <span
class="math inline">\(\set{p}\)</span> 的形变收缩。</p>
<figure>
<img src="\14-9.png" alt="image-20231109103723752" />
<figcaption aria-hidden="true">image-20231109103723752</figcaption>
</figure>
<p>这是易于理解的，因为一个到 <span
class="math inline">\(\set{p}\)</span> 的形变收缩 <span
class="math inline">\(F:X\times I\to X\)</span>
是一个整体连续的映射，我们考察 <span
class="math inline">\(F(-,t)\)</span> 在 <span
class="math inline">\((1,1),(1/2,1),(1/3,1),\cdots\)</span>
的取值，它们是趋于点 <span class="math inline">\(p\)</span> 的，<span
class="math inline">\(F(p,t)=1\)</span>，这与这些点需要先回到 <span
class="math inline">\(x\)</span> 轴上再移动到点 <span
class="math inline">\(p\)</span> 矛盾。</p></li>
</ul></li>
<li><h4 id="van-kampen-定理-van-kampen-theorem">Van-Kampen 定理
(Van-Kampen Theorem)</h4>
<p>回忆：上节课我们学到，若 <span class="math inline">\(X=U\cup
V\)</span> 开覆盖，<span
class="math inline">\(\pi_1(U)=\pi_1(V)=\set{e}\)</span>，<span
class="math inline">\(U\cap V\)</span> 是道路连通，则 <span
class="math inline">\(\pi_1(X)=\set{e}\)</span>。</p>
<p>这个定理启示我们将 <span class="math inline">\(X\)</span>
分解为更小的空间。我们将进行推广，进而得到 Van-Kampen
定理。首先我们进行代数准备工作：</p>
<ul>
<li><h5 id="群的自由积-free-product-of-groups">群的自由积 (Free Product
of Groups)</h5>
<p><span class="math inline">\(G_1,G_2\)</span> 是两个群，</p>
<p>回忆：在抽象代数中我们学过<strong>直积 (Direct Product)</strong>，有
<span class="math inline">\(G_1\times G_2=\set{(g_1,g_2)\mid g_1\in
G_1,g_2\in G_2}\)</span>，乘法定义为 <span
class="math inline">\((g_1,g_2)\cdot(g_1&#39;,g_2&#39;)=(g_1g_1&#39;,g_2g_2&#39;)\)</span>。</p>
<p>上述定义的直积拥有这样的特点：考虑 <span
class="math inline">\((g_1,e)\cdot(e,g_2)=(g_1,g_2)=(e,g_2)\cdot(g_1,e)\)</span>，也就是说直积中部分非平凡乘法是可交换的，就算
<span class="math inline">\(G_1,G_2\)</span>
是不可交换的。直积的定义给乘法的定义加了一些“可交换”的限制。</p>
<p>我们接下来定义<strong>自由积 (Free Product)</strong>：<span
class="math inline">\(G_1\star G_2\)</span>.</p>
<p>引入<strong>单词 (word)</strong>，一个单词是一个序列 <span
class="math inline">\(g_1g_2\cdots g_m\)</span>，使得 <span
class="math inline">\(g_i\in G_1\)</span> 或 <span
class="math inline">\(G_2\)</span>.</p>
<p>一个单词被称为是<strong>约化的 (Reduced)</strong>，若：</p>
<ul>
<li><ol type="1">
<li><span class="math inline">\(\forall g_i\)</span>，<span
class="math inline">\(g_i\)</span> 不是 <span
class="math inline">\(G_1\)</span> 或 <span
class="math inline">\(G_2\)</span> 的恒等元；</li>
</ol></li>
<li><ol start="2" type="1">
<li><span class="math inline">\(\forall\)</span> 相邻的元素 <span
class="math inline">\(g_i\)</span> 与 <span
class="math inline">\(g_{i+1}\)</span>，有 <span
class="math inline">\(g_i,g_{i+1}\)</span> 属于不同的群 <span
class="math inline">\(G_1,G_2\)</span>. (<span
class="math inline">\(g_i\in G_1\Rightarrow g_{i+1}\in G_2\)</span>,
<span class="math inline">\(g_i\in G_2\Rightarrow g_{i+1}\in
G_1\)</span>)</li>
</ol></li>
</ul>
<p>理解上看，约化可以被理解为这个序列在某种意义上是不可简化的，也就是不能去掉单位元，不能把相邻元素乘起来。</p>
<p>我们定义 <span class="math inline">\(G_1\star
G_2=\set{\text{约化的单词}}\)</span>，定义<strong>乘法</strong>：<span
class="math inline">\((g_1g_2\cdots g_m)\cdot(h_1h_2\cdots h_n)=
(g_1\cdots g_mh_1\cdots h_n) \text{
约化后的结果}\)</span>，我们来解释“约化后的结果”一词的意思：</p>
<p>若 <span class="math inline">\(g_m,h_1\)</span>
属于同一个群，那么我们考虑新的单词 <span
class="math inline">\((g_1\cdots g_{m-1}(g_mh_1)h_2\cdots
h_n)\)</span>；</p>
<p>此时，若 <span class="math inline">\(g_mh_1=e\)</span>，则我们删去
<span class="math inline">\((g_mh_1)\)</span>，即考虑 <span
class="math inline">\((g_1\cdots g_{m-1}h_2\cdots h_n)\)</span>
回到第一步进行约化；</p>
<p>若 <span class="math inline">\(g_mh_1\neq
e\)</span>，约化结束，得到约化结束的单词。</p>
<p>若 <span class="math inline">\(g_m,h_1\)</span>
属于不同的群，我们不需要进行约化，得到约化结束的单词。</p>
<p>可以说明，经过有限多步之后，我们得到了一个约化后的单词，我们将这个单词称为约化前两个元素的乘积。</p>
<p>定义<strong>单位元</strong>：空单词；</p>
<p>定义<strong>逆元</strong>：<span class="math inline">\((g_1,\cdots
g_m)^{-1}=(g_m^{-1}\cdots g_1^{-1})\)</span>.</p>
<p>我们可以验证，我们得到了一个群结构 <span
class="math inline">\(G_1\star G_2\)</span>，将其称作 <span
class="math inline">\(G_1\)</span> 与 <span
class="math inline">\(G_2\)</span> 的自由积。</p>
<p>进一步推广，我们可以考虑指标集 <span class="math inline">\(I\)</span>
关联的群的自由积：</p>
<p>定义 <span class="math inline">\(\underset{_{\alpha\in
I}}{\large\star} G_\alpha\)</span> 为所有约化的单词 <span
class="math inline">\(g_1\cdots g_m\)</span> 使得 <span
class="math inline">\(g_i\in
G_{\alpha_i}\)</span>，乘法与逆元同上定义。（需要注意，尽管指标集可以是无限群，但是单词的长度都是有限的）</p>
<p>如果 <span class="math inline">\(G_\alpha\cong \mathbb{Z},\forall
\alpha\)</span>，则 <span class="math inline">\(\underset{_{\alpha\in
I}}{\large\star} G_\alpha\)</span> 称作一个<strong>自由群 (Free
group)</strong>。</p>
<p>对自由积有如下泛性质：</p>
<ul>
<li><h6 id="自由积的泛性质-universal-property">自由积的泛性质 (Universal
Property)</h6>
<p><span class="math inline">\(\forall \alpha\)</span>，我们都有嵌入映射
<span class="math inline">\(i_\alpha:G_\alpha\to \underset{_{\alpha\in
I}}{\large\star} G_\alpha\)</span>，其中 <span
class="math inline">\(g\to g,g\neq e\)</span>，<span
class="math inline">\(e\to \text{空单词}\)</span>.</p>
<p>假设给定一些群同态 <span
class="math inline">\(\varphi_\alpha:G_\alpha\to H,\forall
\alpha\)</span>，其中 <span class="math inline">\(H\)</span>
是一个固定好的群，那么 <span class="math inline">\(\exists!\)</span>
群同态 <span class="math inline">\(\varphi:\underset{_{\alpha\in
I}}{\large\star} G_\alpha\to H\)</span>，使得 <span
class="math inline">\(\varphi\circ i_\alpha=\varphi_\alpha\)</span>.
这即是如下的交换图表：</p>
<figure>
<img src="\14-10.png" alt="image-20231109111107691" />
<figcaption aria-hidden="true">image-20231109111107691</figcaption>
</figure>
<p>证明：</p>
<p>令 <span class="math inline">\(g_1\cdots g_m\in \underset{_{\alpha\in
I}}{\large\star} G_\alpha\)</span>，定义 <span
class="math inline">\(\varphi(g_1\cdots
g_m):=\varphi_{\alpha_1}(g_1)\cdots
\varphi_{\alpha_m}(g_m)\)</span>，这便得到了唯一的合理映射。</p></li>
</ul></li>
</ul>
<p>考虑拓扑空间 <span class="math inline">\(X\)</span>，它有一个开覆盖
<span class="math inline">\(\bigcup_\alpha A_\alpha\)</span>，若 <span
class="math inline">\(\exists x_0\in \bigcap_\alpha
A_\alpha\)</span>，考虑嵌入 <span
class="math inline">\(i_\alpha:A_\alpha\to
X\)</span>，则有诱导的基本群群同态：<span
class="math inline">\(i_{\alpha\star}:\pi_1(A_\alpha,x_0)\to\pi_1(X,x_0)\)</span>.</p>
<p>由上面的泛性质，有 <span class="math inline">\(\exists
!\phi:\underset{_{\alpha}}{\large\star} \pi_1(A_\alpha,x_0)\to
\pi_1(X,x_0)\)</span>，使得 <span
class="math inline">\(\phi|_{\pi_1(A_\alpha,x_0)}=i_{\alpha\star}\)</span>.</p>
<ul>
<li><h5 id="van-kampen-定理-van-kampen-theorem-1">Van-Kampen 定理
(Van-Kampen Theorem)</h5>
<p>令 <span class="math inline">\(X=\bigcup_\alpha A_\alpha\)</span>
开覆盖，<span class="math inline">\(\exists x_0\in \bigcap_\alpha
A_\alpha\)</span>，如果 <span class="math inline">\(A_\alpha\)</span>
以及 <span class="math inline">\(A_\alpha\cap A_\beta\)</span>
是道路连通 <span class="math inline">\(\forall
\alpha,\beta\)</span>，则考虑 <span
class="math inline">\(\phi:\underset{_{\alpha}}{\large\star}
\pi_1(A_\alpha,x_0)\to \pi_1(X,x_0)\)</span>，它是一个满射；</p>
<p>若进一步假设 <span class="math inline">\(A_\alpha\cap A_\beta\cap
A_\gamma\)</span> 也都是道路连通，<span class="math inline">\(\forall
\alpha,\beta,\gamma\)</span>，则 <span class="math inline">\(\ker
\phi\)</span> 是正规子群 <span
class="math inline">\(N\)</span>，且正规子群 <span
class="math inline">\(N\)</span> 由下面这些元素生成：<span
class="math inline">\(((i_{\alpha\beta})_\star (w))
((i_{\beta\alpha})_\star (w))^{-1}\)</span>，其中 <span
class="math inline">\(i_{\alpha\beta}: A_\alpha\cap A_\beta\to
A_\alpha\)</span> 嵌入映射，<span
class="math inline">\(i_{\beta\alpha}:A_\beta\cap A_\alpha\to
A_\beta\)</span> 嵌入映射，<span class="math inline">\(w\)</span> 是
<span class="math inline">\(A_\alpha\cap A_\beta\)</span> 中环路。</p>
<p>解释：直观上看，<span class="math inline">\(w\)</span> 是 <span
class="math inline">\(A_\alpha\cap A_\beta\)</span>
中的环路，这是将环路先看作 <span class="math inline">\(A_\beta\)</span>
中的环路，再将环路看作 <span class="math inline">\(A_\alpha\)</span>
中的环路并相乘，这最终是将这些环路看作 <span
class="math inline">\(X\)</span> 中的环路然后相乘。</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>拓扑学</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象代数学笔记</title>
    <url>/2023/10/12/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p>md 源代码：https://pastebin.ubuntu.com/p/jrxgSSQXqJ/</p>
<span id="more"></span>
<h2 id="群">群</h2>
<h3 id="群的概念">2.1 群的概念</h3>
<h4 id="半群幺群与群">半群、幺群与群</h4>
<p><strong>半群</strong></p>
<p>考察非空集合 <span class="math inline">\(S\)</span>，若在其上定义运算
<span
class="math inline">\(\cdot\)</span>，使得该运算保持封闭与结合律，那么则称
<span class="math inline">\(S\)</span> 关于 <span
class="math inline">\(\cdot\)</span>
成为一个<strong>半群</strong>，有时直接称 <span
class="math inline">\(S\)</span> 为一个<strong>半群</strong>。</p>
<blockquote>
<p>形式化地，称非空集合 <span class="math inline">\(S\)</span> 关于运算
<span class="math inline">\(\cdot\)</span> 是半群若：</p>
<ul>
<li><span class="math inline">\(\forall x,y\in S, x\cdot y\in
S\)</span></li>
<li><span class="math inline">\(\forall x,y,z\in S, (x\cdot y)\cdot
z=x\cdot(y\cdot z)\)</span></li>
</ul>
</blockquote>
<p><strong>含幺半群</strong></p>
<p>考察<strong>半群</strong> <span class="math inline">\(S\)</span>
中元素 <span class="math inline">\(e\)</span>，若有任意元素 <span
class="math inline">\(a\in S\)</span> 有 <span
class="math inline">\(ae=ea=a\)</span>，则称 <span
class="math inline">\(e\)</span> 是 <span
class="math inline">\(S\)</span> 的一个<strong>幺元</strong>，称 <span
class="math inline">\(S\)</span> 为<strong>幺半群</strong>。</p>
<p><strong>群</strong></p>
<p>若<strong>幺半群</strong> <span class="math inline">\(S\)</span>
额外满足对 <span class="math inline">\(S\)</span> 中任意元 <span
class="math inline">\(a\)</span> 皆存在 <span
class="math inline">\(a&#39;\in S\)</span> 满足 <span
class="math inline">\(aa&#39;=a&#39;a=e\)</span>，则称 <span
class="math inline">\(S\)</span> 是一个<strong>群</strong>，称 <span
class="math inline">\(a&#39;\)</span> 是 <span
class="math inline">\(a\)</span> 的<strong>逆元</strong>，记作 <span
class="math inline">\(a^{-1}\)</span>。</p>
<blockquote>
<p>形式化地，称集合 <span class="math inline">\(S\)</span> 关于运算
<span class="math inline">\(\cdot\)</span> 是群若：</p>
<ul>
<li><span class="math inline">\(\forall x,y\in S,x\cdot y\in
S\)</span></li>
<li><span class="math inline">\(\forall x,y,z\in S, (x\cdot y)\cdot
z=x\cdot(y\cdot z)\)</span></li>
<li><span class="math inline">\(\exists e\in S,\forall a\in S, a\cdot
e=e\cdot a=a\)</span></li>
<li><span class="math inline">\(\forall a\in S,\exists a&#39;\in S,
a\cdot a&#39;=a&#39;\cdot a=e\)</span></li>
</ul>
</blockquote>
<p><strong>交换群</strong></p>
<p>若群 <span class="math inline">\(G\)</span> 关于 <span
class="math inline">\(\cdot\)</span> 运算是可交换的，即 <span
class="math inline">\(ab=ba\)</span>，则称 <span
class="math inline">\(G\)</span>
为一个<strong>交换群</strong>，或者为一个<strong>Abel群</strong>。</p>
<h4 id="群的性质">群的性质</h4>
<ul>
<li>群的幺元唯一</li>
</ul>
<p>若 <span class="math inline">\(e\)</span> 与 <span
class="math inline">\(e&#39;\)</span> 都是幺元，则 <span
class="math inline">\(ee&#39;=e\)</span>, <span
class="math inline">\(ee&#39;=e&#39;\)</span>，于是 <span
class="math inline">\(e=e&#39;\)</span>.</p>
<ul>
<li>群元素的逆元唯一</li>
</ul>
<p>若 <span class="math inline">\(a_1\)</span> 与 <span
class="math inline">\(a_2\)</span> 都是 <span
class="math inline">\(a\)</span> 的逆元，则 <span
class="math inline">\(a_1=a_1e=a_1aa_2=(a_1a)a_2=ea_2=a_2\)</span>.</p>
<ul>
<li>群元素逆元的逆元是自身</li>
</ul>
<p>由上显然。</p>
<ul>
<li>左右消去律均成立</li>
</ul>
<p>即：若 <span class="math inline">\(ab=ac\)</span>，则 <span
class="math inline">\(b=c\)</span>；若 <span
class="math inline">\(ba=ca\)</span>，则 <span
class="math inline">\(b=c\)</span>。</p>
<p>证明：<span class="math inline">\(ab=ac\)</span>，于是 <span
class="math inline">\(a^{-1}ab=a^{-1}ac\)</span>，于是 <span
class="math inline">\(b=c\)</span>，右消去律同理。</p>
<ul>
<li>运算基本性质</li>
</ul>
<p>约定 <span class="math inline">\(a^k\)</span> 为 <span
class="math inline">\(k\)</span> 个 <span
class="math inline">\(a\)</span> 的乘积，约定 <span
class="math inline">\(a^{-k}\)</span> 为 <span
class="math inline">\(k\)</span> 个 <span
class="math inline">\(a^{-1}\)</span> 的乘积：</p>
<p><span class="math inline">\(a^n\cdot a^m=a^{n+m}\)</span>；</p>
<p><span class="math inline">\((a^n)^m=a^{nm}\)</span>；</p>
<p><span class="math inline">\((a^n)^{-m}=a^{-nm}\)</span></p>
<p>证明是显然的。</p>
<hr />
<h3 id="子群与陪集傍集">2.2 子群与陪集（傍集）</h3>
<h4 id="子群">子群</h4>
<p><strong>定义</strong></p>
<p>若 <span class="math inline">\(H\)</span> 是群 <span
class="math inline">\(G\)</span> 的子集，且在群 <span
class="math inline">\(G\)</span> 定义的运算下成群，则称 <span
class="math inline">\(H\)</span> 是 <span
class="math inline">\(G\)</span> 的<strong>子群</strong>，记作 <span
class="math inline">\(H\leq G\)</span>.</p>
<p>不难发现，子群关系具有传递性，即若 <span
class="math inline">\(H_1\leq H_2\leq G\)</span>，则 <span
class="math inline">\(H_1\leq G\)</span>.</p>
<p><strong>判别</strong></p>
<p><span class="math inline">\(H\)</span> 是 <span
class="math inline">\(G\)</span>
的子群当且仅当以下两点中任一点成立：</p>
<ul>
<li><span class="math inline">\(\forall a,b\in H, ab\in H, a^{-1}\in
H\)</span></li>
<li><span class="math inline">\(\forall a,b\in H,ab^{-1}\in
H\)</span></li>
</ul>
<p>证明是较显然的。</p>
<p>特别地，若 <span class="math inline">\(H\)</span>
是有限集，则只需要满足对运算的封闭就有 <span class="math inline">\(H\leq
G\)</span>.</p>
<p><strong>简单性质</strong></p>
<p>这些性质都易于验证：</p>
<ul>
<li><span class="math inline">\(H\leq G, K\leq G\)</span>，则 <span
class="math inline">\(H\cap K\leq G\)</span>.</li>
</ul>
<h4 id="中心生成子群与循环群">中心、生成子群与循环群</h4>
<p><strong>中心</strong></p>
<p>定义 <span class="math inline">\(C=\{c\in G| \forall g\in G,
gc=cg\}\)</span> 为群 <span class="math inline">\(G\)</span>
的<strong>中心</strong>，即与 <span class="math inline">\(G\)</span>
中所有元素可交换的元素构成的集合。</p>
<p>可以验证 <span class="math inline">\(C\leq G\)</span>.</p>
<p><strong>生成子群</strong></p>
<p><span class="math inline">\(S\)</span> 是群 <span
class="math inline">\(G\)</span> 的子集，定义 <span
class="math inline">\(G\)</span> 中所有包含 <span
class="math inline">\(S\)</span> 的子群的交为 <span
class="math inline">\(S\)</span> 的<strong>生成子群</strong>，记作 <span
class="math inline">\(&lt;S&gt;\)</span>.</p>
<p>若 <span class="math inline">\(S\leq G\)</span>，显然 <span
class="math inline">\(&lt;S&gt;=S\)</span>.</p>
<p><strong>循环群</strong></p>
<p>若群 <span class="math inline">\(G\)</span> 存在元素 <span
class="math inline">\(g\)</span> 使得 <span
class="math inline">\(&lt;g&gt;=G\)</span>，则称 <span
class="math inline">\(G\)</span> 为<strong>循环群</strong>，此时 <span
class="math inline">\(G\)</span> 中任意元素都可记作 <span
class="math inline">\(g^{p}\)</span>，其中 <span
class="math inline">\(p\in \mathbb{Z}\)</span>.</p>
<h4 id="周期循环子群与陪集">周期，循环子群与陪集</h4>
<p><strong>周期</strong></p>
<p>设 <span class="math inline">\(a\in G\)</span>，若存在最小的正整数
<span class="math inline">\(n\)</span> 使得 <span
class="math inline">\(a^n=e\)</span>，则称 <span
class="math inline">\(n\)</span> 是 <span
class="math inline">\(a\)</span> 的<strong>周期</strong>，否则称 <span
class="math inline">\(a\)</span> 的周期为 <span
class="math inline">\(\infty\)</span>，<span
class="math inline">\(a\)</span> 的周期记作 <span
class="math inline">\(o(a)\)</span>.</p>
<p><strong>循环子群</strong></p>
<p>若 <span class="math inline">\(a\)</span> 是 <span
class="math inline">\(G\)</span> 的元素，<span
class="math inline">\(o(a)=n\)</span>，则 <span
class="math inline">\(|&lt;a&gt;|=n\)</span>，且 <span
class="math inline">\(&lt;a&gt;=\{e,a,a^2,\cdots,a^{n-1}\}\)</span>，称这是由
<span class="math inline">\(a\)</span>
生成的<strong>循环子群</strong>。</p>
<p><strong>陪集</strong></p>
<p>考虑 <span class="math inline">\(H\leq G\)</span>，定义 <span
class="math inline">\(Ha=\{ha|h\in H\}\)</span>，其中 <span
class="math inline">\(a\in G\)</span>，称 <span
class="math inline">\(Ha\)</span> 为 <span
class="math inline">\(H\)</span>
的一个<strong>右陪集</strong>（傍集），左陪集可类似定义。</p>
<p>陪集有一些有趣的性质：</p>
<ul>
<li><span class="math inline">\(\forall a,b\in G,\)</span> 要么 <span
class="math inline">\(Ha=Hb\)</span>，要么 <span
class="math inline">\(Ha\cap Hb=\emptyset\)</span>.</li>
</ul>
<p>证明：</p>
<p>首先证明：<span class="math inline">\(Ha=Hb\Leftrightarrow ab^{-1}\in
H\)</span>（对于左陪集，<span class="math inline">\(aH=bH\Leftrightarrow
a^{-1}b\in H\)</span>）</p>
<p>右推左：<span class="math inline">\(\forall c=ha\in Ha\)</span>，有
<span class="math inline">\(c=(hab^{-1})b\in Hb\)</span>，<span
class="math inline">\(\forall c=hb\in Hb\)</span>，有 <span
class="math inline">\(c=(hba^{-1})=(h(ab^{-1})^{-1})a\in
Ha\)</span>.</p>
<p>左推右：<span class="math inline">\(a=ea\in Ha=Hb\)</span>，于是
<span class="math inline">\(\exists h\in H\)</span>, <span
class="math inline">\(hb=a\)</span>，于是 <span
class="math inline">\(h=ab^{-1}\)</span>，即 <span
class="math inline">\(ab^{-1}\in H\)</span>.</p>
<p>于是若 <span class="math inline">\(Ha\neq Hb\)</span>，假设 <span
class="math inline">\(p\in Ha\cap Hb\neq \emptyset\)</span>，则 <span
class="math inline">\(p=h_1a=h_2b\)</span>，于是 <span
class="math inline">\(a^{-1}b=h_1^{-1}h_2\in H\)</span>，与 <span
class="math inline">\(Ha\neq Hb\)</span> 矛盾。</p>
<ul>
<li><span class="math inline">\(\forall a,b\in G\)</span>, <span
class="math inline">\(|Ha|=|Hb|=|H|\)</span>.</li>
</ul>
<p>证明：显然。</p>
<ul>
<li>定义关系 <span class="math inline">\(a\sim b\)</span> 若 <span
class="math inline">\(Ha=Hb\)</span>，则该关系为<strong>等价关系</strong>。</li>
</ul>
<p>证明：自反性与对称性显然，下面验证传递性：</p>
<p>若 <span class="math inline">\(a\sim b\)</span>，<span
class="math inline">\(b\sim c\)</span>，有 <span
class="math inline">\(ab^{-1}\in H, bc^{-1}\in H\)</span>，于是 <span
class="math inline">\(ab^{-1}bc^{-1}=ac^{-1}\in H\)</span>，有 <span
class="math inline">\(a\sim c\)</span>。</p>
<h4 id="lagrange-定理">Lagrange 定理</h4>
<p><strong>内容</strong></p>
<p>若 <span class="math inline">\(H\leq G\)</span>，则 <span
class="math inline">\(|H| \mid |G|\)</span>，即 <span
class="math inline">\(|H|\)</span> 是 <span
class="math inline">\(|G|\)</span> 的因子。</p>
<p>进一步地，若记 <span class="math inline">\(H\)</span> 关于 <span
class="math inline">\(G\)</span> 不同的右（左）陪集个数为 <span
class="math inline">\([G:H]\)</span>（这也称为 <span
class="math inline">\(H\)</span> 在 <span
class="math inline">\(G\)</span> 中的<strong>指数</strong>），则有 <span
class="math inline">\(|G|=|H|\cdot[G:H]\)</span>。</p>
<p><strong>证明</strong></p>
<p>我们定义 <span class="math inline">\(\bar H\)</span> 表示 <span
class="math inline">\(H\)</span> 关于 <span
class="math inline">\(G\)</span> 右陪集的全体，即 <span
class="math inline">\(\bar H=\{Ha|a\in G\}\)</span>.</p>
<p>由上面对陪集的性质，不难发现：</p>
<p><span class="math inline">\(G=\bigcup_{a\in G}Ha=\bigcup_{S\in \bar
H} S\)</span>.</p>
<p>而由于 <span class="math inline">\(H\)</span>
的陪集两两大小相同且不相交，于是 <span
class="math inline">\(|G|=|H|\cdot |\bar H|\)</span>，即得结论。</p>
<p><strong>推论</strong></p>
<p>下面是一些关于 Lagrange 定理的简单推论，证明都较显然而略去。</p>
<ul>
<li>对任一有限群 <span class="math inline">\(G\)</span>，有 <span
class="math inline">\(\forall x\in G, o(x)\mid |G|\)</span>.</li>
<li>对任一有限群 <span class="math inline">\(G\)</span>，有 <span
class="math inline">\(\forall x\in G,x^{|G|}=e\)</span>.</li>
<li>对任一有限群 <span class="math inline">\(G\)</span>，若 <span
class="math inline">\(|G|=p\)</span>，<span
class="math inline">\(p\)</span> 为素数，则 <span
class="math inline">\(G\)</span> 为循环群。</li>
</ul>
<p>接下来是两个数论中的结论：</p>
<ul>
<li>Euler 定理：<span class="math inline">\(\forall a,n\in \mathbb{Z}^+,
(a,n)=1\)</span>，则 <span class="math inline">\(a^{\varphi(n)}\equiv
1(\bmod n)\)</span>.</li>
</ul>
<p>证明：定义群 <span class="math inline">\(G=\{a|a\leq n,
(a,n)=1\}\)</span>，容易验证 <span class="math inline">\(G\)</span>
关于模 <span class="math inline">\(n\)</span> 乘法成群且 <span
class="math inline">\(|G|=\varphi(n)\)</span>，随后应用上述推论 2
即可.</p>
<ul>
<li>Fermat 小定理：设质数 <span class="math inline">\(p\)</span>，则
<span class="math inline">\(\forall a\in \mathbb{Z}^+\)</span>，有 <span
class="math inline">\(a^p\equiv a(\bmod p)\)</span>.</li>
</ul>
<p>证明：利用 Euler 定理即得。</p>
<p>下面是一些习题中的推论：</p>
<ul>
<li>设 <span class="math inline">\(K\leq H\leq G\)</span>，则 <span
class="math inline">\([G:K]=[G:H]\cdot[H:K]\)</span>.</li>
<li>若 <span class="math inline">\(K\leq G, H\leq G\)</span>，则 <span
class="math inline">\(|HK|=\cfrac{|H|\cdot |K|}{|H\cap
K|}\)</span>，定义 <span class="math inline">\(HK=\{hk|h\in H,k\in
K\}\)</span>.</li>
</ul>
<p>证明：考虑记 <span class="math inline">\(D=H\cap K\)</span>，有 <span
class="math inline">\(HK=\bigcup_{h\in H} hK\)</span>，<span
class="math inline">\(H=\bigcup_{h\in H}hD\)</span>.</p>
<p>考察 <span class="math inline">\(h_1K=h_2K\Leftrightarrow
h_1^{-1}h_2\in K\Leftrightarrow h_1^{-1}h_2\in D\Leftrightarrow
h_1D=h_2D\)</span>.</p>
<p>于是 <span class="math inline">\(f : hK\to hD\)</span>
是一个双射.</p>
<p>于是 <span class="math inline">\(|HK|=|[hK]|\cdot
|K|=|[hD]|\cdot|K|=\cfrac{|H|\cdot|K|}{|H\cap K|}\)</span>.</p>
<ul>
<li>若 <span class="math inline">\(H\leq G, K\leq G\)</span>，则 <span
class="math inline">\(Hg\cap Kg=(H\cap K)g\)</span>.</li>
</ul>
<hr />
<h3 id="正规子群与商群">2.3 正规子群与商群</h3>
<h4 id="正规子群">正规子群</h4>
<p><strong>定义</strong></p>
<p>若 <span class="math inline">\(H\leq G\)</span>，有 <span
class="math inline">\(\forall g\in G\)</span>, <span
class="math inline">\(gH=Hg\)</span>，则称 <span
class="math inline">\(H\)</span> 是 <span
class="math inline">\(G\)</span> 的一个<strong>正规子群</strong>，记作
<span class="math inline">\(H\vartriangleleft G\)</span>.</p>
<p><strong>判别</strong></p>
<p><span class="math inline">\(\forall g\in G,g^{-1}Hg\subset
H\Rightarrow H\vartriangleleft G\)</span>.</p>
<p>证明：</p>
<p>只需证明 <span class="math inline">\(gH=Hg\)</span>，我们来证 <span
class="math inline">\(gH\subseteq Hg\)</span>：</p>
<p><span class="math inline">\(\forall h\in H\)</span>，有 <span
class="math inline">\(ghg^{-1}=h_1\in H\)</span>，于是 <span
class="math inline">\(ghg^{-1}g=gh\in Hg\)</span>，即得结论。</p>
<p>反方向亦然。</p>
<p><strong>性质</strong></p>
<ul>
<li>若 <span class="math inline">\([G:H]=2\)</span>，则 <span
class="math inline">\(H\vartriangleleft G\)</span>.</li>
</ul>
<p>证明：设 <span class="math inline">\(a\bar\in H\)</span>，则 <span
class="math inline">\(G=H\cup Ha=H\cup aH\)</span>，于是 <span
class="math inline">\(Ha=aH\)</span>，于是 <span
class="math inline">\(H\vartriangleleft G\)</span>.</p>
<ul>
<li><span class="math inline">\(\forall h\in H\)</span>, <span
class="math inline">\(Hh=hH=H\)</span>.</li>
<li>正规子群不具有传递性</li>
</ul>
<h4 id="商群">商群</h4>
<p><strong>定义</strong></p>
<p>若 <span class="math inline">\(H\vartriangleleft G\)</span>，定义关于
<span class="math inline">\(H\)</span> 的陪集乘法 <span
class="math inline">\((Ha)\cdot(Hb)=Hab\)</span>，称陪集关于这样的乘法运算构成的集合为
<span class="math inline">\(H\)</span> 在 <span
class="math inline">\(G\)</span> 中的<strong>商群</strong>，记作 <span
class="math inline">\(G/H\)</span>.</p>
<p>将 <span class="math inline">\(Ha\)</span> 简记为 <span
class="math inline">\(\bar a\)</span>.</p>
<p>可以验证，这种陪集乘法定义是合理的，当且仅当 <span
class="math inline">\(H\vartriangleleft
G\)</span>，所以商群仅关于正规子群定义合理。</p>
<p><strong>简单性质</strong></p>
<p><span class="math inline">\(G/H\)</span> 中的幺元为 <span
class="math inline">\(\bar e\)</span>，<span class="math inline">\(\bar
a\)</span> 的逆元为 <span class="math inline">\(\bar
a^{-1}\)</span>.</p>
<h4 id="正规化子">正规化子</h4>
<p><strong>定义</strong></p>
<p><span class="math inline">\(H\leq G\)</span>，记 <span
class="math inline">\(N(H)=\{gH=Hg|g\in G\}\)</span>，称 <span
class="math inline">\(N(H)\)</span> 是 <span
class="math inline">\(H\)</span> 关于 <span
class="math inline">\(G\)</span> 的<strong>正规化子</strong>。</p>
<p>显然 <span class="math inline">\(H\vartriangleleft N(H)\)</span>，且
<span class="math inline">\(N(H)\)</span> 是 <span
class="math inline">\(G\)</span> 中的最大的满足 <span
class="math inline">\(H\)</span> 是正规子群的子群。</p>
<h4 id="换位子子群">换位子子群</h4>
<p><strong>定义</strong></p>
<p>记 <span class="math inline">\([a,b]=a^{-1}b^{-1}ab\)</span>，称其为
<span class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 的换位子元。</p>
<p>称 <span class="math inline">\(G\)</span> 中所有换位子元生成的子群为
<span class="math inline">\(G\)</span>
的<strong>换位子子群</strong>，也称为 <span
class="math inline">\(G\)</span> 的<strong>导群</strong>。</p>
<p>容易验证换位子子群是 <span class="math inline">\(G\)</span>
的正规子群，即 <span class="math inline">\([G,G]\vartriangleleft
G\)</span>.</p>
<p><strong>性质</strong></p>
<ul>
<li><span class="math inline">\(G/[G,G]\)</span> 是交换群，且若 <span
class="math inline">\(K\leq G\)</span>，<span
class="math inline">\(G/K\)</span> 是交换群，则 <span
class="math inline">\([G,G]\subseteq K\)</span>.</li>
</ul>
<p>证明：</p>
<p>记 <span class="math inline">\(H=[G,G]\)</span>，于是 <span
class="math inline">\(Hab=Haba^{-1}b^{-1}ba=(Haba^{-1}b^{-1})ba=Hba\)</span>.</p>
<p>另外，若 <span class="math inline">\(G/K\)</span> 交换，则 <span
class="math inline">\(Kaba^{-1}b^{-1}=K\)</span>，于是 <span
class="math inline">\([G,G]\subseteq K\)</span>.</p>
<hr />
<h3 id="同态与同构">2.4 同态与同构</h3>
<h4 id="同态与同构-1">同态与同构</h4>
<p><strong>定义</strong></p>
<p>考虑 <span class="math inline">\(f:G_1\to G_2\)</span>，满足 <span
class="math inline">\(f(ab)=f(a)f(b)\)</span>，<span
class="math inline">\(G_1,G_2\)</span> 是两个群，那么称 <span
class="math inline">\(f\)</span> 是 <span
class="math inline">\(G_1\)</span> 到 <span
class="math inline">\(G_2\)</span> 的<strong>同态</strong>。</p>
<p>若 <span class="math inline">\(f\)</span>
是单射，又称<strong>单同态</strong>；</p>
<p>若 <span class="math inline">\(f\)</span>
是满射，又称<strong>满同态</strong>或<strong>映上同态</strong>；</p>
<p>若 <span class="math inline">\(f\)</span> 是双射，则称 <span
class="math inline">\(f\)</span> 为一个<strong>同构</strong>。</p>
<p>定义 <span class="math inline">\(\Im f=\{f(g_1)|g_1\in
G_1\}\)</span>，称为 <span class="math inline">\(f\)</span>
的<strong>同态像</strong>；</p>
<p>定义 <span class="math inline">\(\ker f=\{g_1\in
G_1|f(g_1)=e_2\}\)</span>，称为 <span class="math inline">\(f\)</span>
的<strong>同态核</strong>。</p>
<p><strong>简单性质</strong></p>
<p>下面是一些容易验证的简单性质：</p>
<ul>
<li>同态将幺元映射至幺元、逆元映射至逆元.</li>
<li><span class="math inline">\(\Im f\leq G_2\)</span>.</li>
<li><span class="math inline">\(\ker f\vartriangleleft
G_1\)</span>.</li>
</ul>
<p><strong>自然同态</strong></p>
<p><span class="math inline">\(H \vartriangleleft G\)</span>，则称 <span
class="math inline">\(f : g\to \bar g\)</span> 为 <span
class="math inline">\(G\)</span> 到 <span
class="math inline">\(G/H\)</span> 的<strong>自然同态</strong>。</p>
<p><strong>同构等价类</strong></p>
<p>若存在同构映射 <span class="math inline">\(f:G_1\to
G_2\)</span>，则记 <span class="math inline">\(G_1\cong
G_2\)</span>，可以验证这是一个等价关系。</p>
<h4 id="同态与同构的相关定理">同态与同构的相关定理</h4>
<p><strong>同态基本定理</strong></p>
<p>考虑映上同态 <span class="math inline">\(f:G_1\to
G_2\)</span>，有其诱导了同构映射 <span class="math inline">\(\bar f:
G_1/\ker f \to G_2\)</span>，其中 <span class="math inline">\(\bar
f(\bar a)=f(a)\)</span>.</p>
<p><strong>推论</strong></p>
<ul>
<li><span class="math inline">\(f:G_1\to G_2\)</span> 同态，则 <span
class="math inline">\(G_1/\ker f\cong \Im f\)</span>.</li>
<li><span class="math inline">\(f: G_1\to G_2\)</span>
映上同态，则对任意 <span class="math inline">\(K\leq G_2\)</span>，有
<span class="math inline">\(f^{-1}(K)\leq G_1\)</span> 且 <span
class="math inline">\(\ker f\subseteq f^{-1}(K)\)</span>.</li>
<li><span class="math inline">\(f: G_1\to G_2\)</span> 映上同态，则映射
<span class="math inline">\(g : H\to f(H)\)</span> 定义了 <span
class="math inline">\(G_1\)</span> 中包含 <span
class="math inline">\(\ker f\)</span> 的子群与 <span
class="math inline">\(G_2\)</span> 中子群的双射，此时 <span
class="math inline">\(H\)</span> 是正规子群当且仅当 <span
class="math inline">\(f(H)\)</span> 是正规子群。另外有 <span
class="math inline">\(G_1/H\cong G_2/f(H)\)</span>.</li>
</ul>
<p>证明：</p>
<p><span class="math inline">\(g\)</span>
的双射和正规子群是易于验证的。</p>
<p>同构：构造同态 <span class="math inline">\(\varphi : g\to
\bar{f(g)}\)</span>，有 <span class="math inline">\(\Im
\varphi=G_2/f(H)\)</span> 且 <span class="math inline">\(\ker \varphi=
H\)</span>，即得结论.</p>
<ul>
<li><span class="math inline">\(f\)</span> 是单同态的充要条件是 <span
class="math inline">\(\ker f=\{e\}\)</span></li>
</ul>
<p><strong>第一同构定理</strong></p>
<p>若 <span class="math inline">\(H\vartriangleleft G\)</span> 且 <span
class="math inline">\(N\vartriangleleft G\)</span>，而 <span
class="math inline">\(H\subseteq N\)</span>，则 <span
class="math inline">\((G/H)/(N/H)\cong (G/N)\)</span></p>
<p>证明：</p>
<p>构造 <span class="math inline">\(f: G\to G/H\)</span> 自然同态，则
<span class="math inline">\(f(N)=N/H\)</span>，于是 <span
class="math inline">\(G/N\cong (G/H)/(N/H)\)</span>.</p>
<p><strong>第二同构定理</strong></p>
<p>若 <span class="math inline">\(H\vartriangleleft G\)</span>，<span
class="math inline">\(K\leq G\)</span>，则 <span
class="math inline">\(K\cap H \vartriangleleft K\)</span> 且 <span
class="math inline">\(KH/H\cong K/(H\cap K)\)</span>.</p>
<p>证明：</p>
<p>显然 <span class="math inline">\(H\vartriangleleft KH\)</span>，构造
<span class="math inline">\(f : K\to KH/H\)</span> 如下：<span
class="math inline">\(f(x)=xH=\bar x\)</span>，可以验证 <span
class="math inline">\(f\)</span> 是群同态.</p>
<p>有 <span class="math inline">\(\ker f=K\cap H\)</span>，于是有 <span
class="math inline">\(KH/H\cong K/(K\cap H)\)</span>.</p>
<p><strong>自同构与内自同构</strong></p>
<p>称 <span class="math inline">\(f:G\to G\)</span> 同构为 <span
class="math inline">\(G\)</span> 的一个<strong>自同构</strong>.</p>
<p>记 <span class="math inline">\(\text{Aut} G\)</span> 为 <span
class="math inline">\(G\)</span>
的自同构全体，它在映射的合成下构成一个群，称为 <span
class="math inline">\(G\)</span> 的<strong>自同构群</strong>。</p>
<p>对 <span class="math inline">\(a\in G\)</span>，定义 <span
class="math inline">\(a\)</span> 关于 <span
class="math inline">\(G\)</span> 的<strong>内自同构</strong> <span
class="math inline">\(f:g\to aga^{-1}\)</span>.</p>
<p>容易验证内自同构也成群，记作 <span class="math inline">\(\text{Inn}
G\)</span>.</p>
<p>下面证明：<span class="math inline">\(\text{Inn}G\vartriangleleft
\text{Aut}G\)</span> 且 <span class="math inline">\(\text{Inn} g\cong
G/C\)</span>，其中 <span class="math inline">\(C\)</span> 为 <span
class="math inline">\(G\)</span> 的中心。</p>
<p>证明：</p>
<p>正规子群是容易验证的，现在证明同构：</p>
<p>构造 <span class="math inline">\(\varphi:g\to (f: x\to
gxg^{-1})\)</span>.</p>
<p>可以说明 <span class="math inline">\(\ker
\varphi=C\)</span>，于是得到结论.</p>
<hr />
<h3 id="循环群与置换群">2.5&amp;2.6 循环群与置换群</h3>
<h4 id="循环群">循环群</h4>
<p><strong>简单性质</strong></p>
<ul>
<li>两个阶数相同的循环群同构</li>
<li>任意无限循环群同构于 <span
class="math inline">\(\mathbb{Z}\)</span>，任意有限循环群同构于 <span
class="math inline">\(\mathbb{Z}_n\)</span>，其中 <span
class="math inline">\(n\)</span> 为阶数</li>
<li>任意无限循环群的非平凡子群也是无限循环群</li>
<li>任意有限循环群的 <span class="math inline">\(r\)</span>
阶子群若存在，则唯一，且存在当且仅当 <span class="math inline">\(r\mid
n\)</span></li>
</ul>
<p><strong>循环群的判别</strong></p>
<p><span class="math inline">\(G\)</span> 是一个有限阶交换群，则 <span
class="math inline">\(G\)</span> 是循环群当且仅当 <span
class="math inline">\(|G|\)</span> 是使得 <span
class="math inline">\(\forall a\in G\)</span>，<span
class="math inline">\(a^{n}=e\)</span> 中自然数 <span
class="math inline">\(n\)</span> 的最小者。</p>
<p><strong>循环群的自同构群</strong></p>
<ul>
<li><p>考虑<strong>任意</strong>群 <span
class="math inline">\(G\)</span> 与一个自同构 <span
class="math inline">\(\sigma\)</span>，有如下结论成立：</p>
<ol type="1">
<li><p><span class="math inline">\(o(a)=o(\sigma(a))\)</span>.</p></li>
<li><p>设 <span class="math inline">\(S\subseteq G\)</span>，若 <span
class="math inline">\(G=&lt;S&gt;\)</span>，则 <span
class="math inline">\(G=&lt;\sigma(S)&gt;\)</span>.</p></li>
</ol></li>
</ul>
<p>二者证明都不算困难。</p>
<ul>
<li>若 <span class="math inline">\(G\)</span> 是无限循环群，则 <span
class="math inline">\(\text{Aut} G\)</span> 是二阶群。</li>
</ul>
<p>证明：考虑 <span class="math inline">\(Z\cong
G\)</span>，于是只需考察 <span
class="math inline">\(\sigma(1)\)</span>，由上面的 (2) 知道 <span
class="math inline">\(\sigma(1)\)</span> 只能是 <span
class="math inline">\(\pm 1\)</span>，于是得出结论。</p>
<ul>
<li>定义与 <span class="math inline">\(n\)</span> 互素的，模 <span
class="math inline">\(n\)</span> 同余乘法群为 <span
class="math inline">\(U_n\)</span>，即 <span
class="math inline">\(\{m|(m,n)=1\}\)</span>.</li>
<li><span class="math inline">\(Z_n\)</span> 中元素 <span
class="math inline">\(m\)</span> 是生成元当且仅当 <span
class="math inline">\((m,n)=1\)</span>.</li>
</ul>
<p>证明比较容易。</p>
<ul>
<li>设 <span class="math inline">\(G\)</span> 是 <span
class="math inline">\(n\)</span> 阶循环群，则 <span
class="math inline">\(\text{Aut} G\cong U_n\)</span>.</li>
</ul>
<p>事实上，构造映射 <span class="math inline">\(g:f\in \text{Aut} G\to
f(1)\)</span> 即可.</p>
<h4 id="置换群">置换群</h4>
<p><strong>Cayley 定理</strong></p>
<p>任意群 <span class="math inline">\(G\)</span>
必同构于某个集合上的<strong>变换群</strong>，而任意有限群都同构于某个<strong>置换群</strong>。</p>
<p>利用群作用即可构造这样的变换群。</p>
<p><strong>置换与循环</strong></p>
<ul>
<li>任意置换都能表示为若干不相交的循环之积，且这些循环间是可交换的。</li>
<li><span
class="math inline">\((i_1,i_2,\cdots,i_m)^{-1}=(i_m,i_{m-1},\cdots,i_1)\)</span>.</li>
<li>若 <span class="math inline">\(\sigma\)</span> 是一个置换，则 <span
class="math inline">\(\sigma^{-1}(i_1,\cdots,i_k)\sigma=(\sigma(i_1),\cdots,\sigma(i_k))\)</span></li>
</ul>
<p>证明：直接验证 <span class="math inline">\(i_1\sigma\)</span>
在作用下变为 <span class="math inline">\(i_2\sigma\)</span> 即可.</p>
<ul>
<li>任意置换都能表示为若干对换之积，且这些表示中对换个数的奇偶性相同。</li>
</ul>
<p><strong>奇置换与偶置换</strong></p>
<p>若一个置换能被表示为奇数个对换的乘积，则称其为<strong>奇置换</strong>，否则称其为<strong>偶置换</strong>。</p>
<ul>
<li>所有 <span class="math inline">\(n\)</span> 阶偶置换形成的群记作
<span class="math inline">\(A_n\)</span>，有 <span
class="math inline">\(A_n\leq S_n\)</span> 且 <span
class="math inline">\(|A_n|=\cfrac{1}{2}n!\)</span>，于是 <span
class="math inline">\(A_n\vartriangleleft S_n\)</span>，称这个群为 <span
class="math inline">\(n\)</span> 次<strong>交错群</strong>.</li>
</ul>
<p><strong>置换群的生成</strong></p>
<ul>
<li><span
class="math inline">\(S_n=&lt;(1,2),(1,3),\cdots,(1,n)&gt;\)</span>.</li>
</ul>
<p>证明显然；</p>
<ul>
<li><span
class="math inline">\(A_n=&lt;(1,2,3),(1,2,4),\cdots,(1,2,n)&gt;\)</span>.</li>
</ul>
<p>有 <span
class="math inline">\((1,i)(1,j)=(1,2,i)^2(1,2,j)\)</span>，于是进一步由
<span class="math inline">\(S_n\)</span> 的生成得结论。</p>
<ul>
<li><span
class="math inline">\(S_n=&lt;(1,2),(1,2,\cdots,n)&gt;\)</span>.</li>
</ul>
<p>记 <span class="math inline">\(\sigma=(1,2,\cdots,n)\)</span>.</p>
<p>我们来利用归纳构造 <span
class="math inline">\((1,k)\)</span>，设我们构造出了 <span
class="math inline">\((1,k-1)\)</span>，于是有 <span
class="math inline">\(\sigma^{-1}(1,k-1)\sigma=(2,k)\)</span></p>
<p>进而有 <span
class="math inline">\((2,k)(1,2)(2,k)=(1,k)\)</span>.</p>
<p>从而由 <span class="math inline">\(S_n\)</span> 的生成得到结论。</p>
<ul>
<li>若 <span class="math inline">\(n\geq 5\)</span>，则 <span
class="math inline">\(A_n\)</span> 是单群。</li>
</ul>
<p>设 <span class="math inline">\(\{e\}\neq K\vartriangleleft
A_n\)</span>，我们要证明 <span
class="math inline">\(K=A_n\)</span>，只需证明存在一个三循环，例如 <span
class="math inline">\((1,2,3)\in K\)</span>，如是我们构造置换</p>
<p><span
class="math inline">\(\gamma=\begin{pmatrix}1&amp;2&amp;3&amp;4&amp;5&amp;\cdots\\i&amp;j&amp;k&amp;l&amp;m&amp;\cdots\end{pmatrix}\)</span>，若
<span class="math inline">\(\gamma\)</span> 是奇置换则交换 <span
class="math inline">\(l\)</span>，<span class="math inline">\(m\)</span>
得到偶置换，从而</p>
<p><span
class="math inline">\(\gamma^{-1}(1,2,3)\gamma=(i,j,k)\)</span>，于是所有三循环属于
<span class="math inline">\(K\)</span>，进而有 <span
class="math inline">\(K=A_n\)</span></p>
<p>我们设 <span class="math inline">\(\alpha\in K\)</span>，有 <span
class="math inline">\(\alpha\)</span> 是除了 <span
class="math inline">\(e\)</span> 以外拥有最多不动点的置换，不动点即
<span class="math inline">\(x\alpha=x\)</span>。</p>
<p>假设 <span class="math inline">\(\alpha\)</span> 不是三循环，我们将
<span class="math inline">\(\alpha\)</span>
写作互不相交循环的情形，有两种情况：</p>
<ol type="1">
<li><span
class="math inline">\(\alpha=(i,j,k,\dots)\dots\)</span>，此时由于 <span
class="math inline">\(\alpha\)</span> 是偶置换，于是 <span
class="math inline">\(\alpha\)</span> 至少还需要动两个点，不妨设为 <span
class="math inline">\(l,m\)</span>，于是构造 <span
class="math inline">\(\beta=(k,l,m)\)</span>，有 <span
class="math inline">\(\gamma =
\beta^{-1}\alpha\beta=(i,j,l,\dots)\dots\)</span> 也是偶置换，考虑 <span
class="math inline">\(\tau=\alpha^{-1}\gamma\)</span>，显然 <span
class="math inline">\(\tau\neq e\)</span>，此时考虑除了 <span
class="math inline">\(i,j,k,l,m\)</span> 之外的元素，有若其在 <span
class="math inline">\(\alpha\)</span> 不动则在 <span
class="math inline">\(\tau\)</span> 不动，而 <span
class="math inline">\(\tau\)</span> 额外拥有 <span
class="math inline">\(j\)</span> 这个不动点，这与 <span
class="math inline">\(\alpha\)</span> 的定义矛盾；</li>
<li><span
class="math inline">\(\alpha=(i,j)(k,l)\dots\)</span>，此时任取一 <span
class="math inline">\(m\)</span> 构造 <span
class="math inline">\(\beta=(k,l,m)\)</span>，有 <span
class="math inline">\(\gamma=(i,j)(l,m)\dots\)</span>，仍考虑 <span
class="math inline">\(\tau=\alpha^{-1}\gamma\)</span>，仍有除了 <span
class="math inline">\(i,j,k,l,m\)</span> 之外的元素，若其在 <span
class="math inline">\(\alpha\)</span> 不动则在 <span
class="math inline">\(\tau\)</span> 不动，且 <span
class="math inline">\(\tau\)</span> 额外拥有 <span
class="math inline">\(i,j\)</span> 两个不动点，即使 <span
class="math inline">\(m\)</span> 变为动点，仍然比 <span
class="math inline">\(\alpha\)</span> 不动点少，矛盾。</li>
</ol>
<ul>
<li>推论：对 <span class="math inline">\(n\geq 5\)</span>，<span
class="math inline">\(S_n\)</span> 只有唯一非平凡正规子群 <span
class="math inline">\(A_n\)</span>.</li>
</ul>
<hr />
<h3 id="群对集合的作用">2.7 群对集合的作用</h3>
<h4 id="群作用">群作用</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(G\)</span> 为群，<span
class="math inline">\(S\)</span> 为集合，考虑一个 <span
class="math inline">\(G\times S\to S\)</span> 的映射 <span
class="math inline">\((g,s)\to g*s\)</span> 满足：</p>
<ol type="1">
<li><span class="math inline">\(e*x=x\)</span></li>
<li><span class="math inline">\((g_1g_2)*x=g_1*(g_2*x)\)</span></li>
</ol>
<p>对 <span class="math inline">\(\forall g\in G,x\in S\)</span>
成立，则称 <span class="math inline">\(G\)</span> 在 <span
class="math inline">\(S\)</span> 上定义了一个<strong>左作用</strong>，称
<span class="math inline">\(S\)</span> 为一个 <strong><span
class="math inline">\(G\)</span>-集合</strong>。</p>
<p>类似可定义右作用。在定义明确的情况下，可简记 <span
class="math inline">\(a*x\)</span> 为 <span
class="math inline">\(ax\)</span>。</p>
<p><strong>平移与共轭作用</strong></p>
<p>下面定义两个 <span class="math inline">\(S=G\)</span>
时的特殊作用。</p>
<ul>
<li>定义 <span
class="math inline">\(a*x=ax\)</span>，这样的左作用称为<strong>左平移</strong></li>
<li>定义 <span
class="math inline">\(a*x=axa^{-1}\)</span>，称这样的作用为<strong>共轭</strong></li>
</ul>
<p><strong>轨道与稳定化子</strong></p>
<ul>
<li>设 <span class="math inline">\(S\)</span> 是一个 <span
class="math inline">\(G\)</span>-集合，<span class="math inline">\(x\in
S\)</span>，称 <span class="math inline">\(Gx=\{gx|g\in G\}\)</span> 为
<span class="math inline">\(x\)</span> 在 <span
class="math inline">\(G\)</span> 作用下的<strong>轨道</strong>。</li>
<li>设 <span class="math inline">\(S\)</span> 是一个 <span
class="math inline">\(G\)</span>-集合，<span class="math inline">\(x\in
S\)</span>，称 <span class="math inline">\(\text{Stab} x=\{g\in
G|gx=x\}\)</span> 为 <span class="math inline">\(x\)</span> 在 <span
class="math inline">\(G\)</span>
中的<strong>迷向子群</strong>或<strong>稳定化子</strong>。</li>
</ul>
<p>下面说明一些轨道和稳定化子的性质：</p>
<ul>
<li><p><span class="math inline">\(\text{Stab} x\leq G\)</span></p></li>
<li><p>任意两条轨道要么互不相交，要么重合。推论：所有轨道对应了 <span
class="math inline">\(S\)</span> 的一个分划。</p></li>
<li><p><span class="math inline">\(|Gx|=[G:\text{Stab}
x]\)</span></p></li>
</ul>
<p>证明：设 <span class="math inline">\(H=\text{Stab} x\)</span>，定义
<span class="math inline">\(G/H\)</span> 为 <span
class="math inline">\(H\)</span> 在 <span
class="math inline">\(G\)</span> 中的左陪集集合，构造映射 <span
class="math inline">\(f: Gx\to G/H\)</span> 为 <span
class="math inline">\(gx\to gH\)</span> 即可。</p>
<p>容易验证这个映射是合理且双射的。</p>
<ul>
<li>推论：<span class="math inline">\(|S|=\sum_{x\in C}[G:\text{Stab}
x]\)</span>，其中 <span class="math inline">\(C\)</span>
是轨道中代表元集合。</li>
</ul>
<p>下面是一些共轭作用下轨道和稳定化子的应用：</p>
<ul>
<li>共轭作用的稳定化子就是中心化子。</li>
</ul>
<p><span class="math inline">\(\text{Stab} x=\{g\in
G|gxg^{-1}=x\}=\{g\in G|gx=xg\}\)</span>.</p>
<ul>
<li>若 <span class="math inline">\(G\)</span> 是一个有限群，<span
class="math inline">\(C\)</span> 是 <span
class="math inline">\(G\)</span> 的中心，则 <span
class="math inline">\(|G|=|C|+\sum [G:C(y_i)]\)</span>，其中 <span
class="math inline">\(C(y_i)\)</span> 表示 <span
class="math inline">\(y_i\)</span> 的中心化子，而 <span
class="math inline">\(y_i\)</span>
跑遍所有不止一个元素的共轭类全体。</li>
</ul>
<p><strong><span class="math inline">\(p\)</span> 群</strong></p>
<p>定义：若有限群 <span class="math inline">\(G\)</span> 满足 <span
class="math inline">\(|G|=p^m\)</span>，其中 <span
class="math inline">\(p\)</span> 为一个质数，则称 <span
class="math inline">\(G\)</span> 是一个 <span
class="math inline">\(p\)</span> 群。（该板块下的 <span
class="math inline">\(G\)</span> 默认为 <span
class="math inline">\(p\)</span> 群）</p>
<ul>
<li>任意 <span class="math inline">\(p\)</span>
群的中心不止一个元素</li>
</ul>
<p>利用上面的式子有 <span class="math inline">\(|G|=|C|+\sum
[G:C(y_i)]\)</span>，左右分别都是 <span class="math inline">\(p\)</span>
的倍数，而 <span class="math inline">\([G:C(y_i)]\)</span> 一定是 <span
class="math inline">\(p\)</span> 的倍数，于是若 <span
class="math inline">\(|C|=1\)</span>，则右侧不是 <span
class="math inline">\(p\)</span> 的倍数，矛盾。</p>
<ul>
<li>若 <span class="math inline">\(N\vartriangleleft G\)</span> 且 <span
class="math inline">\(N\neq \{e\}\)</span>，则 <span
class="math inline">\(C\cap N\neq \{e\}\)</span>，其中 <span
class="math inline">\(C\)</span> 为 <span
class="math inline">\(G\)</span> 的中心</li>
</ul>
<p>同样应用上面式子可得。</p>
<ul>
<li>若 <span class="math inline">\(H\leq G\)</span> 且 <span
class="math inline">\(H\neq G\)</span>，则 <span
class="math inline">\(H\subsetneq N(H)\)</span>，其中 <span
class="math inline">\(N(H)\)</span> 是 <span
class="math inline">\(H\)</span> 的正规化子</li>
</ul>
<p>对 <span class="math inline">\(|G|=p^m\)</span> 的 <span
class="math inline">\(m\)</span> 做归纳可得。</p>
<ul>
<li>若 <span class="math inline">\(\cfrac{|G|}{|H|}=p\)</span> 且 <span
class="math inline">\(H\leq G\)</span>，则 <span
class="math inline">\(H\vartriangleleft G\)</span>.</li>
</ul>
<p>由上一命题直接得。</p>
<p><strong>更多应用（可迁群，有趣的结论 etc.）</strong></p>
<ul>
<li><p>若 <span class="math inline">\(S\)</span> 关于 <span
class="math inline">\(G\)</span>
作用的轨道只有一个，则称这个作用为<strong>可迁作用</strong>，特别地，若
<span class="math inline">\(G\)</span> 为置换群，则称 <span
class="math inline">\(G\)</span> 为一个<strong>可迁群</strong></p></li>
<li><p>可以验证如下性质成立：<span class="math inline">\(A_n(n\geq
3)\)</span> 为可迁群；<span class="math inline">\(n\)</span>
次可迁群的阶可以被 <span class="math inline">\(n\)</span> 整除；<span
class="math inline">\(G\)</span> 是可迁群当且仅当 <span
class="math inline">\(G\)</span> 中所有保持 <span
class="math inline">\(1\)</span> 不动的元素构成的子群 <span
class="math inline">\(G_1\)</span> 有 <span
class="math inline">\([G:G_1]=n\)</span>.</p></li>
<li><p>Burnside 定理：设 <span class="math inline">\(n\)</span> 为 <span
class="math inline">\(S\)</span> 在 <span
class="math inline">\(G\)</span> 作用下形成的轨道数目，则有 <span
class="math inline">\(n=\cfrac{1}{|G|}\sum_{g\in G} |S_g|\)</span>，其中
<span class="math inline">\(S_g=\{x\in S|gx=x\}\)</span>.</p></li>
<li><p><span class="math inline">\(p^2\)</span> 阶群都是 Abel
群</p></li>
</ul>
<p>假设不是，则 <span class="math inline">\(|C|=p\)</span>，设 <span
class="math inline">\(a\bar\in C\)</span>，于是 <span
class="math inline">\(|C(a)|\geq p+1\)</span>，于是 <span
class="math inline">\(|C(a)|=G\)</span>，与 <span
class="math inline">\(a\bar \in C\)</span> 矛盾。</p>
<ul>
<li>设 <span class="math inline">\(G\)</span> 是一个有限群且有一个指数为
<span class="math inline">\(n\)</span> 的子群 <span
class="math inline">\(H\)</span>，即 <span
class="math inline">\([G:H]=n\)</span>，则必定有 <span
class="math inline">\(K\vartriangleleft G\)</span> 使得 <span
class="math inline">\(K\subseteq H\)</span> 且 <span
class="math inline">\([G:K]\mid n!\)</span> .</li>
</ul>
<p>考虑构造这样的这样的置换：<span class="math inline">\(g\in G\)</span>
将 <span class="math inline">\(xH\)</span> 映射至 <span
class="math inline">\(gxH\)</span>，可以验证这是一个 <span
class="math inline">\(n\)</span> 阶置换</p>
<p>于是可以构造一个到 <span class="math inline">\(n\)</span>
阶置换群的同态 <span class="math inline">\(f\)</span>，考虑 <span
class="math inline">\(\ker f\)</span> 即可。</p>
<hr />
<h3 id="sylow-定理">2.8 Sylow 定理</h3>
<p>本节定理的证明较长，故略去。（短小，但非常有用）</p>
<p><strong>Cauchy 定理</strong></p>
<p>设 <span class="math inline">\(G\)</span> 是一个有限 Abel 群，<span
class="math inline">\(p\)</span> 为素数，若 <span
class="math inline">\(p \mid |G|\)</span>，则在 <span
class="math inline">\(G\)</span> 中存在一个周期为 <span
class="math inline">\(p\)</span> 的元素。</p>
<p><strong>Sylow 第一定理</strong></p>
<p>设 <span class="math inline">\(G\)</span> 是一个有限群，<span
class="math inline">\(p\)</span> 为素数，若 <span
class="math inline">\(p^k\mid G\)</span>，则 <span
class="math inline">\(G\)</span> 必有一个 <span
class="math inline">\(p^k\)</span> 阶子群。</p>
<p>于是作为推论，可以把 Cauchy 定理中 <span
class="math inline">\(G\)</span> 为 Abel
群的限制去除得到更强的结论。</p>
<p><strong>Sylow 第二、三定理</strong></p>
<ul>
<li>设 <span class="math inline">\(G\)</span> 是一个有限群，<span
class="math inline">\(p\)</span> 为一个素数，若 <span
class="math inline">\(p^m\mid |G|\)</span> 且 <span
class="math inline">\(p^{m+1}\not \mid |G|\)</span>，则称 <span
class="math inline">\(G\)</span> 的 <span
class="math inline">\(p^m\)</span> 阶子群为 <span
class="math inline">\(p\)</span>-Sylow 子群。</li>
<li>对于 <span class="math inline">\(p\)</span>-Sylow
子群有如下性质成立：
<ul>
<li>任意两个 <span class="math inline">\(p\)</span>-Sylow
子群均共轭；</li>
<li><span class="math inline">\(G\)</span> 的 <span
class="math inline">\(p\)</span>-Sylow 子群的个数 <span
class="math inline">\(r\)</span> 是 <span
class="math inline">\([G:P]\)</span> 的因子，其中 <span
class="math inline">\(P\)</span> 为 <span
class="math inline">\(G\)</span> 的一个 <span
class="math inline">\(p\)</span>-Sylow 子群，且 <span
class="math inline">\(r\equiv 1(\bmod p)\)</span>；</li>
<li><span class="math inline">\(G\)</span> 的任一 <span
class="math inline">\(p^k\)</span> 阶子群均含于某个 <span
class="math inline">\(p\)</span>-Sylow 子群内。</li>
</ul></li>
</ul>
<p><strong>Sylow 定理的推论</strong></p>
<ul>
<li><span class="math inline">\(\Large (!)\)</span>若有限群 <span
class="math inline">\(G\)</span> 只有一个 <span
class="math inline">\(p\)</span>-Sylow 子群，那么这个子群一定正规。</li>
<li>设 <span class="math inline">\(p,q\)</span> 都是素数，则 <span
class="math inline">\(pq\)</span> 阶群最多只有两种。</li>
<li>上面结论的推论：<span class="math inline">\(2p\)</span>
阶非交换群同构于 <span class="math inline">\(D_p\)</span>.</li>
</ul>
<hr />
<h3 id="群的直积与有限生成-abel-群">2.9-10 群的直积与有限生成 Abel
群</h3>
<h4 id="外直积与内直积">外直积与内直积</h4>
<p><strong>外直积</strong></p>
<p>定义两个群 <span class="math inline">\(G_1,G_2\)</span>
的<strong>外直积</strong>为 <span class="math inline">\(G=G_1\times
G_2\)</span>，有 <span
class="math inline">\((g_1,g_2)(h_1,h_2)=(g_1h_1,g_2h_2)\)</span>，可以验证
<span class="math inline">\(G\)</span> 是群。</p>
<p><strong>内直积</strong></p>
<p>若 <span class="math inline">\(G\)</span> 是一个群，<span
class="math inline">\(N_i\)</span> 为若干 <span
class="math inline">\(G\)</span> 的正规子群满足：</p>
<ul>
<li><span class="math inline">\(G=N_1N_2\cdots N_n\)</span>;</li>
<li><span class="math inline">\(\forall i\in 1,2,\dots, n\)</span>，有
<span class="math inline">\(N_i\cap N_1N_2\cdots N_{i-1}N_{i+1}\cdots
N_n=\{e\}\)</span>。</li>
</ul>
<p>则称 <span class="math inline">\(G\)</span> 是 <span
class="math inline">\(N_i\)</span> 的<strong>内直积</strong>。</p>
<p>内直积和外直积在同构的意义下是一致的。</p>
<p>加法群的直积又叫直和。</p>
<p><strong>内直积的判别</strong></p>
<p>内直积的第二个条件可以被替代为如下任意一种：</p>
<ul>
<li><span class="math inline">\(\forall g\in G\)</span>，有若 <span
class="math inline">\(g=g_1\cdots g_n=h_1\cdots h_n\)</span>，其中 <span
class="math inline">\(h_i,g_i\in N_i\)</span>，则 <span
class="math inline">\(h_i=g_i,\forall i\in 1,2,\cdots, n\)</span>.</li>
<li>若 <span class="math inline">\(g_1g_2\cdots g_n=e\)</span>，其中
<span class="math inline">\(g_i\in N_i\)</span>，则 <span
class="math inline">\(g_i=e\)</span>.</li>
</ul>
<h4 id="有限生成-abel-群">有限生成 Abel 群</h4>
<p><strong>有限生成 Abel 群基本定理</strong></p>
<p>设 <span class="math inline">\(G\)</span> 是一个有限生成加法群，则
<span class="math inline">\(G\)</span> 可以被分解为有限个循环群 <span
class="math inline">\(C_i\)</span> 的直和：</p>
<p><span class="math inline">\(G=C_1\oplus C_2\oplus \cdots\oplus
C_k\)</span>.</p>
<p>并且要么所有的 <span class="math inline">\(C_i\)</span>
都是无限循环群，要么存在某个 <span class="math inline">\(j\leq
k\)</span> 满足 <span class="math inline">\(C_1,\cdots,C_j\)</span>
是阶分别为 <span class="math inline">\(m_1,\cdots, m_j\)</span>
的有限群且 <span class="math inline">\(m_1\mid m_2\mid \cdots \mid
m_j\)</span>，其他群均为无限循环群。</p>
<p><strong>推论</strong></p>
<ul>
<li>对任何一个有限生成 Abel 群 <span
class="math inline">\(G\)</span>，有 <span
class="math inline">\(G\)</span> 的分解唯一。</li>
</ul>
<p>于是引入如下定义：</p>
<ul>
<li>称 <span class="math inline">\(G\)</span> 中无限循环群的个数为 <span
class="math inline">\(G\)</span> 的<strong>秩</strong>；</li>
<li>若 <span class="math inline">\(G\)</span>
可以被分解为无限循环群的直和，则称 <span
class="math inline">\(G\)</span> 是一个有限生成的<strong>自由 Abel
群</strong>；</li>
</ul>
<p>考虑 <span class="math inline">\(n\)</span> 阶有限生成 Abel
群的计数：</p>
<ul>
<li>若 <span class="math inline">\(n=p^k\)</span>，则 <span
class="math inline">\(n\)</span> 阶 Abel 群总共有 <span
class="math inline">\(P(k)\)</span> 个，这里 <span
class="math inline">\(P(-)\)</span> 表示分划数。</li>
<li>若 <span class="math inline">\(n=p_1^{f_1}p_2^{f_2}\cdots
p_n^{f_n}\)</span>，则 <span class="math inline">\(n\)</span> 阶 Abel
群总共有 <span class="math inline">\(P(f_1)P(f_2)\cdots P(f_n)\)</span>
个。</li>
</ul>
<hr />
<h3 id="正规群列与可解群">2.11 正规群列与可解群</h3>
<h4 id="正规群列">正规群列</h4>
<p><strong>定义</strong></p>
<p>称 <span class="math inline">\(\{e\}=G_0\vartriangleleft
G_1\vartriangleleft \cdots \vartriangleleft G_r=G\)</span> 为 <span
class="math inline">\(G\)</span> 的一个<strong>正规群列</strong>，商群
<span class="math inline">\(G_1/G_0, G_2/G_1,\cdots\)</span>
称为这个正规群列的<strong>商因子</strong>。</p>
<p>若商因子都是单群，则称该正规群列是一个<strong>合成群列</strong>。</p>
<p><strong>Jordan-Holder 定理</strong></p>
<p>设 <span class="math inline">\(G\)</span> 是一个有限群，若 <span
class="math inline">\(G\)</span> 有两个合成群列 <span
class="math inline">\(G_0,G_1,\cdots, G_r\)</span> 与 <span
class="math inline">\(H_0,H_1,\cdots,H_s\)</span>，则 <span
class="math inline">\(r=s\)</span> 且存在一个置换 <span
class="math inline">\(\sigma\)</span> 使得 <span
class="math inline">\(G_i/G_{i-1}\cong
H_{\sigma(i)}/H_{\sigma(i)-1}\)</span>.</p>
<h4 id="可解群">可解群</h4>
<p><strong>定义</strong></p>
<p>若 <span class="math inline">\(G\)</span>
存在一个正规群列使得每个商因子都是 Abel 群，则称 <span
class="math inline">\(G\)</span> 为一个<strong>可解群</strong>。</p>
<p><strong>部分结论</strong></p>
<ul>
<li><span class="math inline">\(p\)</span> 群必是可解群</li>
</ul>
<p>由于 <span class="math inline">\(p\)</span> 群必有非平凡中心，考察
<span class="math inline">\(G/C\)</span>
并不断进行下去即可得到群列。</p>
<p>由中心的性质可以知道商因子都是 Abel 群。</p>
<p>我们接下来引入<strong>导群</strong>（换位子子群）并用来说明一些可解群结论：</p>
<p>设 <span class="math inline">\(G&#39;\)</span> 表示 <span
class="math inline">\(G\)</span> 的换位子子群（即 <span
class="math inline">\([G,G]\)</span>），递归定义 <span
class="math inline">\(G^{(k)}\)</span> 为 <span
class="math inline">\((G^{(k-1)})&#39;\)</span>，<span
class="math inline">\(G^{(1)}=G&#39;\)</span>.</p>
<ul>
<li><span class="math inline">\(G\)</span> 是可解群当且仅当存在自然数
<span class="math inline">\(k\)</span> 使得 <span
class="math inline">\(G^{(k)}=\{e\}\)</span>.</li>
</ul>
<p>考虑正规群列 <span
class="math inline">\(G^{(k)},\cdots,G^{(1)},G\)</span> 即可。</p>
<ul>
<li>可解群的子群和同态像也是可解群</li>
</ul>
<p>由上面性质易证。</p>
<ul>
<li><span class="math inline">\(S_n(n\geq 5)\)</span> 是不可解群。</li>
</ul>
<p>由于 <span class="math inline">\(A_n\)</span> 是单群，从而 <span
class="math inline">\(A_n\)</span> 不是可解群，进而 <span
class="math inline">\(S_n\)</span> 不是可解群。</p>
<ul>
<li><span class="math inline">\(G\)</span>
是可解群当且仅当存在合成群列，使得商因子均是素数阶循环群。</li>
</ul>
<p>下面我们定义<strong>幂零群</strong>的概念：</p>
<p>如此递归定义 <span class="math inline">\(G\)</span> 的 <span
class="math inline">\(k\)</span> 次中心：</p>
<p><span class="math inline">\(C_0=\{e\}\)</span>；</p>
<p>设 <span class="math inline">\(G/C_k\)</span> 的中心为 <span
class="math inline">\(C&#39;\)</span>，由自然同态有 <span
class="math inline">\(C&#39;\cong C_{k+1}/C_k\)</span>，于是我们定义出了
<span class="math inline">\(C_{k+1}\)</span>.</p>
<p>不难注意到 <span class="math inline">\(C_0,C_1,\cdots\)</span>
是一个正规群列，称这个群列为<strong>上中心列</strong>；</p>
<ul>
<li>若 <span class="math inline">\(\exists n\)</span> 使得 <span
class="math inline">\(C_n=G\)</span>，则称 <span
class="math inline">\(G\)</span>
为一个<strong>幂零群</strong>，称满足条件的最小的 <span
class="math inline">\(n\)</span> 为 <span
class="math inline">\(G\)</span> 的<strong>幂指数</strong>。</li>
</ul>
<p>显然，幂零群都是可解群，Abel 群都是幂零群。</p>
<p>下面来看一些关于幂零群的结论：</p>
<ul>
<li>素数幂阶群都是幂零群</li>
<li>群 <span class="math inline">\(G\)</span>
是幂零群的充要条件为：<span class="math inline">\(G\)</span>
有一个正规群列，使得其商因子 <span
class="math inline">\(G_i/G_{i-1}\subseteq C(G/G_{i-1})\)</span>.</li>
</ul>
<hr />
<h3 id="低阶非-abel-群">2.12 低阶非 Abel 群</h3>
<ul>
<li><span class="math inline">\(n=6\)</span> <span
class="math inline">\(S_3\)</span></li>
<li><span class="math inline">\(n=8\)</span> <span
class="math inline">\(D_4,H\)</span></li>
<li><span class="math inline">\(n=10\)</span> <span
class="math inline">\(D_5\)</span></li>
<li><span class="math inline">\(n=12\)</span> <span
class="math inline">\(A_4, D_6, G=&lt;a,b&gt;\)</span> 且 <span
class="math inline">\(a^4=b^3=e, ba=ab^2\)</span></li>
<li><span class="math inline">\(n=14\)</span> <span
class="math inline">\(D_7\)</span></li>
</ul>
<hr />
<h2 id="环">环</h2>
<h3 id="环的概念">3.1 环的概念</h3>
<blockquote>
<p>“我向你许诺，这里将会有一座灯塔。这座灯塔将照亮你，照亮我，照亮很多很多人……”</p>
</blockquote>
<h4 id="环-1">环</h4>
<p><strong>定义</strong></p>
<p>称 <span class="math inline">\(R\)</span>
为一个<strong>环</strong>，如果在 <span class="math inline">\(R\)</span>
上定义了 <span class="math inline">\(+\)</span> 与 <span
class="math inline">\(\cdot\)</span> 两种运算，且适合：</p>
<ul>
<li><span class="math inline">\((R,+)\)</span>
构成一个加法群，记其中单位元为 <span
class="math inline">\(0\)</span>；</li>
<li><span class="math inline">\(\cdot\)</span> 运算满足结合律与关于
<span class="math inline">\(+\)</span> 的分配律，即 <span
class="math inline">\((a+b)\cdot c=a\cdot c+b\cdot c\)</span>。</li>
</ul>
<p>环上运算的 <span class="math inline">\(\cdot\)</span>
可以省略，因此可以记 <span class="math inline">\(a\cdot b\)</span> 为
<span class="math inline">\(ab\)</span>.</p>
<p><strong>带恒等元的环</strong></p>
<p>若环 <span class="math inline">\(R\)</span> 还满足存在单位元 <span
class="math inline">\(e\)</span> 使得 <span
class="math inline">\(\forall r\in R, er=re=r\)</span>，则称 <span
class="math inline">\(R\)</span> 为<strong>带恒等元的环</strong>，称
<span class="math inline">\(e\)</span> 为恒等元。</p>
<p>我们记恒等元为 <span class="math inline">\(1\)</span>。</p>
<p><strong>环的简单性质</strong></p>
<ul>
<li><span class="math inline">\(a\cdot 0=0\cdot a=0\)</span></li>
<li><span class="math inline">\((-a)\cdot b=a\cdot(-b)=-(a\cdot
b)\)</span></li>
</ul>
<p><strong>各种各样的环</strong></p>
<ul>
<li><p>若环上的 <span class="math inline">\(\cdot\)</span>
运算可交换，则称原环为一个<strong>交换环</strong>；</p></li>
<li><p>我们按如下方法定义<strong>零因子</strong>：</p>
<p>若 <span class="math inline">\(a,b\neq0\)</span>，但 <span
class="math inline">\(ab=0\)</span>，则称 <span
class="math inline">\(a\)</span> 为 <span
class="math inline">\(b\)</span> 的<strong>左零因子</strong>，<span
class="math inline">\(b\)</span> 为 <span
class="math inline">\(a\)</span> 的<strong>右零因子</strong>。</p>
<p>没有零因子的环称为<strong>整环</strong>。</p>
<p>不难注意到，对整环 <span class="math inline">\(R\)</span> 有 <span
class="math inline">\(ab=0\Leftrightarrow a=0\vee b=0\)</span>。</p>
<p>整环满足<strong>消去律</strong>，即若 <span
class="math inline">\(ab=ac\)</span> 且 <span
class="math inline">\(a\neq 0\)</span>，则 <span
class="math inline">\(b=c\)</span>。</p></li>
<li><p>记 <span class="math inline">\(R^*\)</span> 表示 <span
class="math inline">\(R\setminus\{0\}\)</span>，<span
class="math inline">\(R\)</span>
是带有恒等元的环，先来定义几个概念。</p>
<p>若 <span class="math inline">\(a\in R^*\)</span>，<span
class="math inline">\(\exists b\in R^*\)</span> 使得 <span
class="math inline">\(ba=1\)</span>，则称 <span
class="math inline">\(b\)</span> 是 <span
class="math inline">\(a\)</span>
的<strong>左逆元</strong>。同理可以定义<strong>右逆元</strong>。</p>
<p>若 <span class="math inline">\(b\)</span> 既是 <span
class="math inline">\(a\)</span> 的左逆元又是 <span
class="math inline">\(a\)</span> 的右逆元，则称 <span
class="math inline">\(b\)</span> 是 <span
class="math inline">\(a\)</span>
的一个<strong>逆元</strong>，逆元一定唯一。</p>
<p>若 <span class="math inline">\(a\)</span> 拥有逆元，我们称 <span
class="math inline">\(a\)</span>
是一个<strong>单位</strong>或一个<strong>可逆元</strong>。</p>
<p>若 <span class="math inline">\(R^*\)</span> 中元素均为可逆元，则称
<span class="math inline">\(R\)</span> 为一个<strong>除环</strong>。</p>
<p>更多地，若除环 <span class="math inline">\(R\)</span> 中的 <span
class="math inline">\(\cdot\)</span> 运算可交换，则称 <span
class="math inline">\(R\)</span> 为一个<strong>域</strong>。</p></li>
</ul>
<p><strong>环的直积</strong></p>
<p>类似群地，对环我们也可以定义环的直积，这样的定义显然满足其仍然为一个环。</p>
<p><strong>一些性质以及证明</strong></p>
<ul>
<li><p>有限整环必是除环。</p>
<p>考虑 <span class="math inline">\(\forall b\neq 0\in
R\)</span>，一定有 <span class="math inline">\(\forall k\in
\mathbb{N}\)</span>，<span class="math inline">\(b^k\neq
0\)</span>（整环），于是 <span class="math inline">\(\exists m\in
\mathbb{N}\)</span>，<span
class="math inline">\(b^m=b\)</span>（有限），于是 <span
class="math inline">\(b\)</span> 是可逆元，其逆为 <span
class="math inline">\(b^{m-1}\)</span>.</p></li>
<li><p>带恒等元的整环一定没有除了 <span class="math inline">\(0\)</span>
与 <span class="math inline">\(1\)</span> 外的幂等元。</p>
<p>证明是容易的；</p></li>
<li><p>若 <span class="math inline">\(1-ab\)</span> 是一个可逆元，则
<span class="math inline">\(1-ba\)</span> 也是一个可逆元。</p>
<p>这里的证明需要一些小小的构造震撼，这里给出一种解释这个构造的方法。</p>
<p>我们不妨设 <span class="math inline">\(1-ab\)</span> 的逆为 <span
class="math inline">\(c\)</span>，即 <span
class="math inline">\((1-ab)c=1\)</span>，我们想要找到 <span
class="math inline">\(ba\)</span>，考虑给这个式子整体左乘 <span
class="math inline">\(b\)</span>，那么就有 <span
class="math inline">\(ba\)</span> 了：</p>
<p><span class="math inline">\(bc-babc=b\)</span>，于是有 <span
class="math inline">\((1-ba)bc=b\)</span>，再右乘一个 <span
class="math inline">\(a\)</span> 便得到了很讨喜的形式：<span
class="math inline">\((1-ba)bca=ba\)</span>.</p>
<p>构造出了 <span
class="math inline">\(ba\)</span>，剩下的就简单了：<span
class="math inline">\((1-ba)(1+bca)\)</span> 自然就是 <span
class="math inline">\((1-ba)+ba=1\)</span>.</p></li>
</ul>
<hr />
<h3 id="子环理想商环">3.2 子环·理想·商环</h3>
<blockquote>
<p>“我的理想之内并没有一丝污浊。”</p>
<p>“我要纠正你，在这里，子环并不与正规子群等价，理想才是。”</p>
<p>“它甚至不能用来定义等价关系，赞美理想的崇高与圣洁吧。”</p>
</blockquote>
<h4 id="子环">子环</h4>
<p><strong>定义</strong></p>
<p>若 <span class="math inline">\(R\)</span> 是一个环，<span
class="math inline">\(S\)</span> 是 <span
class="math inline">\(R\)</span> 的子集且在环 <span
class="math inline">\(R\)</span> 定义的两种运算下仍为环，则称 <span
class="math inline">\(S\)</span> 为 <span
class="math inline">\(R\)</span> 的<strong>子环</strong>。</p>
<p><strong>判别条件</strong></p>
<p><span class="math inline">\(S\)</span> 是 <span
class="math inline">\(R\)</span> 子环的充分必要条件是 <span
class="math inline">\(S\)</span> 中元素对减法与乘法封闭。即 <span
class="math inline">\(\forall a,b\in S, a-b\in S,ab\in S\)</span>.</p>
<p>证明：减法封闭表明其为加法子群，乘法封闭则自然封闭性、结合律、分配律成立。</p>
<h4 id="理想">理想</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(R\)</span> 是一个环，<span
class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span> 的子集。若：</p>
<ul>
<li><span class="math inline">\(I\)</span> 是环 <span
class="math inline">\(R\)</span> 的加法子群；</li>
<li><span class="math inline">\(\forall r\in R,i\in I\)</span>，有 <span
class="math inline">\(ri\in I, ir\in I\)</span></li>
</ul>
<p>则称 <span class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span> 的一个<strong>理想</strong>。</p>
<p>不难发现，理想是一种特殊的<strong>子环</strong>。</p>
<p><strong>平凡理想</strong></p>
<p>不难注意到，任意一个环 <span class="math inline">\(R\)</span>
总有理想 <span class="math inline">\(\{0\}\)</span> 与 <span
class="math inline">\(R\)</span>，称这两个理想为<strong>平凡理想</strong>。</p>
<p><span
class="math inline">\(\large{(*)}\)</span>除环与域总是只有<strong>平凡理想</strong>。</p>
<p><strong>生成理想</strong></p>
<p>设 <span class="math inline">\(S\)</span> 为环 <span
class="math inline">\(R\)</span> 的子集，设 <span
class="math inline">\((S)\)</span> 为所有包含 <span
class="math inline">\(S\)</span> 的理想的交，它是 <span
class="math inline">\(R\)</span> 包含 <span
class="math inline">\(S\)</span> 的最小理想，也称作 <span
class="math inline">\(S\)</span> 的<strong>生成理想</strong>。</p>
<p>若 <span class="math inline">\(S\)</span> 只有一个元素 <span
class="math inline">\(s\)</span>，则称这样的理想为<strong>主理想</strong>。</p>
<p><strong>理想的运算</strong></p>
<p>任意两个理想 <span class="math inline">\(I,J\)</span>
可定义加法：<span class="math inline">\(I+J=\{i+j\mid i\in I, j\in
J\}\)</span>，这恰好是 <span class="math inline">\(I\cup J\)</span>
的生成理想；</p>
<p>也可定义乘法：<span class="math inline">\(IJ=\{\sum_{i&lt;+\infty}
a_ib_i\mid a_i\in I,b_i\in J\}\)</span>，这恰好是 <span
class="math inline">\(\{ab\mid a\in I,b\in J\}\)</span>
的生成理想。（注意乘法的定义并非 <span
class="math inline">\(I,J\)</span>
中任意两个元素相乘的并构成的集合）</p>
<h4 id="商环">商环</h4>
<p>注意到刚才定义的理想自然是 <span class="math inline">\(R\)</span>
的<strong>正规加法子群</strong>。</p>
<p>考虑像商群那样定义<strong>商环</strong>。</p>
<p>来看这样一种等价关系：</p>
<p><strong>定义</strong></p>
<p>考虑环 <span class="math inline">\(R\)</span> 与其理想 <span
class="math inline">\(I\)</span>，对 <span
class="math inline">\(R\)</span> 中元素 <span
class="math inline">\(a,b\)</span>，定义 <span
class="math inline">\(a\sim b\)</span> 当且仅当 <span
class="math inline">\(a-b\in I\)</span>，此时 <span
class="math inline">\(\sim\)</span> 显然构成了一个等价关系。</p>
<p>我们记 <span class="math inline">\(a\)</span> 的等价类为 <span
class="math inline">\(\bar a\)</span>，容易验证 <span
class="math inline">\(\bar a + \bar b = \overline {a+b}\)</span>.</p>
<p>我们想要它保持环上的运算，因此需要证明 <span
class="math inline">\(\bar a\cdot \bar b=\overline{ab}\)</span>.</p>
<p>考察 <span class="math inline">\(a_1-a\in I, b_1-b\in
I\)</span>，则有 <span
class="math inline">\((a_1+I)(b_1+I)=((a+c)+I)((b+d)+I)=(a+I)(b+I)\)</span>，这样的运算确乎是合理的。</p>
<p>于是有 <span class="math inline">\(R/I\)</span> 为一个环，记作 <span
class="math inline">\(R\)</span> 关于 <span
class="math inline">\(I\)</span> 的<strong>商环</strong>，有时也记作
<span class="math inline">\(R-I\)</span>.</p>
<h4 id="性质及证明">性质及证明</h4>
<ul>
<li><p>带恒等元的交换环 <span class="math inline">\(R\)</span>
是域的充要条件是 <span class="math inline">\(R\)</span>
只有平凡理想。</p>
<p>证明：若 <span class="math inline">\(R\)</span> 是域，任一非 <span
class="math inline">\(0\)</span> 元素可逆，故而 <span
class="math inline">\(R\)</span> 一定只有平凡理想；</p>
<p>反之，若 <span class="math inline">\(R\)</span> 只有平凡理想，考虑
<span class="math inline">\(R\)</span> 中任意非零元素 <span
class="math inline">\(a\)</span>，有 <span
class="math inline">\((a)=R\)</span>.</p>
<p>注意到 <span class="math inline">\(\forall b\in (a)\)</span>， <span
class="math inline">\(\exists r_b\in R\)</span> 使得 <span
class="math inline">\(ar_b=r_ba=b\)</span>，由于 <span
class="math inline">\(1\in (a)\)</span>，故 <span
class="math inline">\(a\)</span> 为可逆元，故 <span
class="math inline">\(R\)</span> 为域。</p></li>
<li><p>引入单环的定义：</p>
<ul>
<li>若带恒等元的环 <span class="math inline">\(R\)</span>
只有平凡理想但不是除环，则称 <span class="math inline">\(R\)</span>
为一个<strong>单环</strong>。（注意这里的单环事实上就是上一条性质中的非交换环情形）</li>
</ul></li>
<li><p>设 <span class="math inline">\(R\)</span> 是一个除环，则基于
<span class="math inline">\(R\)</span> 定义的矩阵环 <span
class="math inline">\(M_n(R)\)</span> 是单环。</p>
<p>证明：只需证明单位矩阵 <span
class="math inline">\(E_{i,i}\)</span>（即只有第 <span
class="math inline">\(i\)</span> 行和第 <span
class="math inline">\(i\)</span> 列为 <span
class="math inline">\(1\)</span>
的矩阵）都属于任意理想即可。这里证明是比较容易的，利用对非零矩阵 <span
class="math inline">\(A\)</span> （不妨设 <span
class="math inline">\(a_{j,k}\neq 0\)</span>）可用 <span
class="math inline">\(E_{i,j}AE_{k,i}=a_{j,k}E_{i,i}\)</span>
提取某位置的元素即可。</p></li>
<li><p>承接上一条定理，我们发现矩阵环没法拥有非平凡的理想，那么它是否能拥有其他意义上的理想呢？</p>
<p>引入<strong>左右理想</strong>的定义：</p>
<ul>
<li><p>设 <span class="math inline">\(R\)</span> 是一个环，<span
class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span> 的子集。若：</p>
<ul>
<li><span class="math inline">\(I\)</span> 是环 <span
class="math inline">\(R\)</span> 的加法子群；</li>
<li><span class="math inline">\(\forall r\in R,i\in I\)</span>，有 <span
class="math inline">\(ri\in I\)</span></li>
</ul>
<p>则称 <span class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span>
的一个<strong>左理想</strong>，右理想的定义类似。</p></li>
</ul>
<p>不难发现左右理想也有生成的概念，且按照上述的理想运算也可以定义理想加法。（左右理想<strong>不能做</strong>乘法运算，也<strong>不能</strong>用来定义商环，想一想，为什么？）</p>
<p>矩阵环是可以拥有非平凡的左右理想的，例如，只有前 <span
class="math inline">\(m\)</span> 列有值的矩阵全体构成 <span
class="math inline">\(M_n(R)\)</span> 的左理想。</p></li>
<li><p>对交换环 <span class="math inline">\(R\)</span> 中子集 <span
class="math inline">\(S=\{a_1,a_2,\cdots,a_n\}\)</span>，有其生成理想为
<span class="math inline">\(\{\sum r_ia_i+\sum n_ia_i\mid r_i\in
R,n_i\in \mathbb{Z}\}\)</span>.若 <span class="math inline">\(R\)</span>
带恒等元，可进一步写作 <span class="math inline">\(\{\sum r_ia_i\mid
r_i\in R\}\)</span>.</p>
<p>证明是容易的。</p></li>
</ul>
<hr />
<h3 id="环的同态">3.3 环的同态</h3>
<blockquote>
<p>“我不是萨拉！我是克拉拉！”</p>
<p>“她才是萨拉！！萨拉才是恶魔！！恶魔不是我！！”</p>
</blockquote>
<h4 id="同态与同构-2">同态与同构</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(R\)</span> 与 <span
class="math inline">\(R&#39;\)</span> 是两个环，<span
class="math inline">\(f\)</span> 是 <span
class="math inline">\(R\)</span> 到 <span
class="math inline">\(R&#39;\)</span> 的映射且保持环的运算，则称 <span
class="math inline">\(f\)</span> 是一个 <span
class="math inline">\(R\)</span> 到 <span
class="math inline">\(R&#39;\)</span> 的<strong>同态</strong>。</p>
<p>若 <span class="math inline">\(f\)</span>
还是单满射，则称之为<strong>同构</strong>。</p>
<p><strong>像与核</strong></p>
<p>记 <span class="math inline">\(\Im f=\{r&#39;\mid r&#39;=f(r),r\in
R\}\)</span>, <span class="math inline">\(\text{Ker} f=\{r\mid
f(r)=0,r\in R\}\)</span>.</p>
<p>可以验证 <span class="math inline">\(\text{Ker} f\)</span> 是 <span
class="math inline">\(R\)</span> 的<strong>理想</strong>。</p>
<p><strong>同态基本定理及其推论</strong></p>
<p>接下来，我们都假设 <span class="math inline">\(f\)</span>
是<strong>映上</strong>的，从 <span class="math inline">\(R\)</span> 到
<span class="math inline">\(R&#39;\)</span> 的<strong>同态</strong>，即
<span class="math inline">\(\Im f=R&#39;\)</span>.</p>
<ul>
<li><p>（<strong>同态基本定理</strong>）若 <span
class="math inline">\(f\)</span> 是一个同态，则其诱导了同构 <span
class="math inline">\(R/I\cong R&#39;\)</span>，设同构映射为 <span
class="math inline">\(\bar f\)</span>，有 <span
class="math inline">\(f=\bar f\nu\)</span>，<span
class="math inline">\(\nu\)</span> 为 <span class="math inline">\(r\to
r+\text{Ker} f\)</span> 的自然同态。</p>
<p>这里的证明与群的情形一致。</p></li>
<li><p>环 <span class="math inline">\(R\)</span> 的任一同态像同构于
<span class="math inline">\(R\)</span> 关于同态核的商环。</p>
<p>由上立得。</p></li>
<li><p>设 <span class="math inline">\(f\)</span> 是一个同态，<span
class="math inline">\(K=\text{Ker} f\)</span>，则 <span
class="math inline">\(R\)</span> 包含 <span
class="math inline">\(K\)</span> 的所有子环与 <span
class="math inline">\(R&#39;\)</span> 的子环间存在一一对应关系：<span
class="math inline">\(H\to f(H)\)</span>。更多地，<span
class="math inline">\(H\)</span> 是 <span
class="math inline">\(R\)</span> 的理想当且仅当 <span
class="math inline">\(f(H)\)</span> 是 <span
class="math inline">\(R&#39;\)</span> 的理想。</p>
<p>证明与群论类似。</p></li>
<li><p><span class="math inline">\(g\)</span> 是一个 <span
class="math inline">\(R\)</span> 到 <span
class="math inline">\(R&#39;\)</span>
的保持加法运算的<strong>对应</strong>（不是<strong>映射</strong>，即不保证不出现一对多的情况），<span
class="math inline">\(g\)</span> 是映射的条件为 <span
class="math inline">\(g(0)=0\)</span>.</p>
<p>证明：当 <span class="math inline">\(g(0)=0\)</span>，则 <span
class="math inline">\(r=r&#39;\)</span>，有 <span
class="math inline">\(g(r-r&#39;)=0\)</span>，于是 <span
class="math inline">\(g(r)=g(r&#39;)\)</span>，这是一个映射。</p></li>
<li><p>（<strong>同构第一定理</strong>）<span
class="math inline">\(R\)</span> 是一个环，<span
class="math inline">\(S\)</span> 是 <span
class="math inline">\(R\)</span> 的子环，<span
class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span> 的理想，则 <span
class="math inline">\(S+I=\{s+i\mid s\in S,i \in I\}\)</span> 是 <span
class="math inline">\(R\)</span> 的一个含有 <span
class="math inline">\(I\)</span> 作为理想的子环。另外，有 <span
class="math inline">\(S\cap I\)</span> 是 <span
class="math inline">\(S\)</span> 的理想且：<span
class="math inline">\(s+I\to s+(S\cap I)\)</span> 是一个 <span
class="math inline">\((S+I)/I\)</span> 至 <span
class="math inline">\(S/(S\cap I)\)</span> 的同构。</p>
<p>证明：构造映射 <span class="math inline">\(r+I\to r+(S\cap
I)\)</span>，由同态基本定理即得。</p></li>
<li><p>（<strong>同构第二定理</strong>）<span
class="math inline">\(R\)</span> 是一个环，<span
class="math inline">\(I,J\)</span> 是其理想且 <span
class="math inline">\(I\subseteq J\)</span>，则 <span
class="math inline">\(R/J\cong (R/I)/(J/I)\)</span>.</p>
<p>证明：构造映射 <span class="math inline">\(r+I\to
r+J\)</span>，由同态基本定理即得。</p></li>
<li><p>同态的复合仍是同态。</p>
<p>证明很容易。</p></li>
<li><p>除环的非零自同态总是单同态。</p>
<p>因为同态核是理想，但是除环只有平凡理想，因此要么是零同态，要么是单同态。</p></li>
</ul>
<hr />
<h3 id="整环分式域">3.4 整环·分式域</h3>
<blockquote>
<p>“我很羡慕那些特征非零的环——它们总能及时归零。”</p>
</blockquote>
<h4 id="整环的特征">整环的特征</h4>
<p><strong>周期元与周期</strong></p>
<p>对<strong>整环</strong>（回顾：不存在零因子的环称为整环） <span
class="math inline">\(R\)</span> 中的元素 <span
class="math inline">\(a\neq 0\)</span>，若有 <span
class="math inline">\(ma=0\)</span>，其中 <span
class="math inline">\(m\in \mathbb{N}\)</span>，则称 <span
class="math inline">\(a\)</span> 为一个<strong>周期元</strong>，称 <span
class="math inline">\(m\)</span> 为 <span
class="math inline">\(a\)</span> 的<strong>周期</strong>。</p>
<p><strong>特征</strong></p>
<p>对整环 <span
class="math inline">\(R\)</span>，若其存在周期元，则必然存在素数 <span
class="math inline">\(p\)</span>，使得 <span
class="math inline">\(\forall x\in R\)</span>，有 <span
class="math inline">\(px=0\)</span>，素数 <span
class="math inline">\(p\)</span> 称为 <span
class="math inline">\(R\)</span> 的<strong>特征</strong>。</p>
<p>证明：事实上，若对 <span class="math inline">\(a\neq 0\)</span>，
<span class="math inline">\(pa\neq 0\)</span>，那么 <span
class="math inline">\(\forall b\neq 0\in R\)</span>，有 <span
class="math inline">\(pb\neq 0\)</span>，否则由 <span
class="math inline">\(a(pb)=0\)</span>，有 <span
class="math inline">\((pa)b= 0\)</span>，这与整环条件矛盾。</p>
<p>因此，若对 <span class="math inline">\(a\)</span> 有 <span
class="math inline">\(pa=0\)</span>，总有 <span
class="math inline">\(\forall b\in R\)</span>， <span
class="math inline">\(pb=0\)</span>.</p>
<p>于是只需要说明任意元素的最小正周期一定为素数，这是显然的。</p>
<p>若整环没有周期元，则记该整环的特征为 <span
class="math inline">\(0\)</span>。</p>
<p><strong>素域</strong></p>
<p>特征为 <span class="math inline">\(p\neq 0\)</span>
的<strong>域</strong>（回顾：交换除环称为域）<span
class="math inline">\(F\)</span> 一定含有最小子域，这个最小子域同构于
<span class="math inline">\(Z_p\)</span>，我们称这个域为 <span
class="math inline">\(F\)</span> 的<strong>素域</strong>。</p>
<p>若 <span class="math inline">\(F\)</span> 的特征为 <span
class="math inline">\(0\)</span>，它也有最小子域，为 <span
class="math inline">\((\bar1)\)</span>（由单位元生成的子域），可以证明它与
<span class="math inline">\(\mathbb{Q}\)</span> 同构。</p>
<h4 id="分式域">分式域</h4>
<p><strong>整区</strong></p>
<p>我们称一个带恒等元的交换整环为<strong>整区</strong>。</p>
<p><strong>定义</strong></p>
<p>回忆有理数的定义：定义积集合 <span
class="math inline">\(\mathbb{Z}\times\mathbb{Z}^*\)</span>，然后在上面定义等价关系。那么我们是否能把这种定义推广到整区呢？</p>
<p>不妨设 <span class="math inline">\(R\)</span> 为一个整区，<span
class="math inline">\(R^*\)</span> 表示 <span
class="math inline">\(R\)</span> 中的非零元全体。</p>
<p>我们在 <span class="math inline">\(R\times R^*\)</span>
上定义等价关系 <span class="math inline">\((a,b)\sim (c,d)\)</span>
当且仅当 <span class="math inline">\(ad=bc\)</span>.</p>
<p>记 <span class="math inline">\((a,b)\)</span> 的等价类为 <span
class="math inline">\(\cfrac{a}{b}\)</span>，<span
class="math inline">\(F\)</span> 为这些等价类的集合。</p>
<p>可以验证，<span class="math inline">\(F\)</span>
在如下的加法、乘法定义下构成环：</p>
<ul>
<li><span
class="math inline">\(\cfrac{a}{b}+\cfrac{c}{d}=\cfrac{ab+bc}{bd}\)</span></li>
<li><span
class="math inline">\(\cfrac{a}{b}\cdot\cfrac{c}{d}=\cfrac{ac}{bd}\)</span></li>
</ul>
<p><span class="math inline">\(F\)</span> 中的零元为 <span
class="math inline">\(\cfrac{0}{1}\)</span>，恒等元为 <span
class="math inline">\(\cfrac{1}{1}\)</span>，且对任意非零元 <span
class="math inline">\(\cfrac{a}{b}\)</span> 总有逆元 <span
class="math inline">\(\cfrac{b}{a}\)</span>，可以验证 <span
class="math inline">\(F\)</span> 是域。我们称 <span
class="math inline">\(F\)</span> 为 <span
class="math inline">\(R\)</span> 的<strong>分式域</strong>。</p>
<p>自然可以构造出 <span class="math inline">\(R\)</span> 到 <span
class="math inline">\(F\)</span> 的嵌入映射 <span
class="math inline">\(f: r\to
\cfrac{r}{1}\)</span>，这是一个单同态。</p>
<p><strong>性质</strong></p>
<ul>
<li><p>设 <span class="math inline">\(R\)</span> 是一个整区，<span
class="math inline">\(F\)</span> 是它的分式域，<span
class="math inline">\(f\)</span> 是嵌入映射。若 <span
class="math inline">\(g\)</span> 为一个 <span
class="math inline">\(R\)</span> 至 <span
class="math inline">\(F&#39;\)</span> 的单同态，则 <span
class="math inline">\(g\)</span> 可被唯一扩张成 <span
class="math inline">\(F\)</span> 到 <span
class="math inline">\(F&#39;\)</span> 的同态。其中 <span
class="math inline">\(g(\cfrac{a}{b})=g(a)(g(b))^{-1}\)</span>.</p>
<p>证明：容易说明这是一个同态。我们只需要验证唯一性。假设有另一同态
<span class="math inline">\(g&#39;\)</span>，则由于 <span
class="math inline">\(g&#39;(\cfrac{a}{b})=g&#39;(\cfrac{a}{1})g&#39;(\cfrac{1}{b})=g(a)(g(b))^{-1}=g(\cfrac{a}{b})\)</span>，故
<span class="math inline">\(g&#39;=g\)</span>，故唯一。</p></li>
<li><p>特征为 <span class="math inline">\(0\)</span> 的域 <span
class="math inline">\(F\)</span> 必有同构于有理数域的最小子域。</p>
<p>证明：考虑任何子域必含单位元 <span
class="math inline">\(\bar1\)</span>，因此考察 <span
class="math inline">\(\bar 1\)</span>
生成的子环，由于没有周期元，因此这个子环必同构于 <span
class="math inline">\(\mathbb{Z}\)</span>。于是考察其分式域 <span
class="math inline">\(F_0\)</span>，它同构于 <span
class="math inline">\(\mathbb{Q}\)</span>，因此有 <span
class="math inline">\(\mathbb{Q}\)</span> 至 <span
class="math inline">\(F\)</span> 的单同态 <span
class="math inline">\(h\)</span>，其像即为 <span
class="math inline">\(F\)</span> 的最小子域，同构于 <span
class="math inline">\(\mathbb{Q}\)</span>。</p></li>
</ul>
<h4 id="作业题结论">作业题结论</h4>
<ul>
<li><p>任意一个不带恒等元的环都可以嵌入一个带恒等元的环。</p>
<p>证明：设不带恒等元的环为 <span
class="math inline">\(R\)</span>，考虑乘积集合 <span
class="math inline">\(\mathbb{Z}\times R\)</span>，其中 <span
class="math inline">\(\mathbb{Z}\)</span> 为整数集。我们定义加法 <span
class="math inline">\((m,a)+(n,b)=(m+n,a+b)\)</span>，乘法 <span
class="math inline">\((m,a)(n,b)=(mn, mb+na+ab)\)</span>，则 <span
class="math inline">\(\mathbb{Z}\times R\)</span> 构成一环，且它有恒等元
<span class="math inline">\((1,0)\)</span>，于是从 <span
class="math inline">\(R\)</span> 至 <span
class="math inline">\(\mathbb{Z}\times R\)</span> 的嵌入 <span
class="math inline">\(r\to (0,r)\)</span> 即为所求嵌入。</p></li>
<li><p>同构的整区拥有同构的分式域。</p>
<p>证明：易于验证。</p></li>
</ul>
<hr />
<h3 id="唯一分解环ufd">3.5 唯一分解环（UFD）</h3>
<blockquote>
<p>“十口心思，思君思国思社稷”</p>
<p>“八刀分元，高斯整区PID”</p>
</blockquote>
<h4 id="因子">因子</h4>
<p>在本节中，所有的乘法运算都假定为<strong>可交换</strong>的，即所有讨论的环均为<strong>交换环</strong>。</p>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(a\)</span> 是整区 <span
class="math inline">\(R\)</span> 中一个元素，若 <span
class="math inline">\(a=bc\)</span>，则称 <span
class="math inline">\(b\)</span> 与 <span
class="math inline">\(c\)</span> 是 <span
class="math inline">\(a\)</span> 的<strong>因子</strong>，记作 <span
class="math inline">\(b\mid a, c\mid a\)</span>。</p>
<p>反之，若 <span class="math inline">\(b\)</span> 不可能是 <span
class="math inline">\(a\)</span> 的因子，则记作 <span
class="math inline">\(b \not\mid a\)</span>.</p>
<p><strong>真因子</strong></p>
<p>注意到对 <span class="math inline">\(R\)</span>
中的<strong>单位</strong>（回忆：单位即可逆元） <span
class="math inline">\(u\)</span>，<span class="math inline">\(u \mid
r,\forall r\in R\)</span>，这样的因子是平凡的。</p>
<p>对于 <span class="math inline">\(a=bc\)</span>，若 <span
class="math inline">\(b,c\)</span> 均不是单位，那么一定有 <span
class="math inline">\(a\not\mid b\)</span>，否则有 <span
class="math inline">\(b=ad=bcd\)</span> 得知 <span
class="math inline">\(cd=1\)</span> 即 <span
class="math inline">\(c\)</span> 为单位。同理 <span
class="math inline">\(a\not\mid c\)</span>。</p>
<p>像 <span class="math inline">\(b,c\)</span>
这样的因子我们称为<strong>真因子</strong>，换言之，满足 <span
class="math inline">\(b\mid a\)</span> 但 <span
class="math inline">\(a\not \mid b\)</span> 的 <span
class="math inline">\(a\)</span> 的因子为<strong>真因子</strong>。</p>
<p><strong>相伴元</strong></p>
<p>若两个元素 <span class="math inline">\(a,b\)</span>
互为因子，那么它们间一定相差一个单位 <span
class="math inline">\(c\)</span>，即 <span class="math inline">\(a=bc,
b=ac^{-1}\)</span>，这样的两个元我们称之为<strong>相伴元</strong>。</p>
<p>相伴关系记作 <span class="math inline">\(a\sim
b\)</span>，这显然为等价关系。</p>
<p><strong>不可约元</strong></p>
<p>若 <span class="math inline">\(a\)</span>
不是单位且<strong>不</strong>可写成两个真因子的乘积，则称 <span
class="math inline">\(a\)</span> 为<strong>不可约元</strong>。</p>
<h4 id="唯一分解环">唯一分解环</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(R\)</span> 是一个整区，若 <span
class="math inline">\(R\)</span> 中任意非 <span
class="math inline">\(0\)</span> 且不是单位的元素 <span
class="math inline">\(a\)</span>
都可被写成有限个不可约元的乘积，且这种分解在如下意义下是唯一的：</p>
<ul>
<li>若 <span class="math inline">\(a=p_1p_2\cdots
p_r=p&#39;_1p&#39;_2\cdots p&#39;_s\)</span>，则 <span
class="math inline">\(r=s\)</span>；</li>
<li>存在置换 <span class="math inline">\(\sigma\)</span>，使得 <span
class="math inline">\(p_i\sim p&#39;_{\sigma(i)}\)</span>。</li>
</ul>
<p>则我们称 <span class="math inline">\(R\)</span>
是一个<strong>唯一分解环</strong>，也称作<strong>Gauss
整区</strong>。</p>
<p>例如，<span
class="math inline">\(\mathbb{Z}\)</span>、数域上的多项式环是Gauss
整区。</p>
<p><strong>判别</strong></p>
<p>先来引入两个条件：</p>
<ul>
<li><p>因子链条件</p>
<p>若 <span class="math inline">\(R\)</span> 是一个整区且不存在无限序列
<span class="math inline">\(\{a_i\}\)</span> 使得 <span
class="math inline">\(a_{i+1}\)</span> 是 <span
class="math inline">\(a_{i}\)</span> 的真因子，则称 <span
class="math inline">\(R\)</span>
适合<strong>因子链条件</strong>。</p></li>
<li><p>素性条件</p>
<p>先来定义 <span class="math inline">\(R\)</span> 中素元：若 <span
class="math inline">\(p\)</span> 不是 <span
class="math inline">\(R\)</span> 的一个单位且若 <span
class="math inline">\(p\mid ab\)</span>，必有 <span
class="math inline">\(p\mid a\)</span> 或 <span
class="math inline">\(p\mid b\)</span>，则称 <span
class="math inline">\(p\)</span> 为一个<strong>素元</strong>。</p>
<p>若 <span class="math inline">\(R\)</span>
中所有的不可约元都是素元，则称 <span class="math inline">\(R\)</span>
满足<strong>素性条件</strong>。</p></li>
</ul>
<p><span class="math inline">\(\large{(*)}\)</span>结论 1：<span
class="math inline">\(R\)</span> 是唯一分解环当且仅当 <span
class="math inline">\(R\)</span> 满足因子链条件和素性条件。</p>
<p>证明：</p>
<p>(<span
class="math inline">\(\Rightarrow\)</span>)：先来看因子链条件。我们设序列
<span class="math inline">\(a_1,a_2,\cdots\)</span>，其中 <span
class="math inline">\(a_i\)</span> 是 <span
class="math inline">\(a_{i+1}\)</span>
的真因子，若要满足因子链条件，则序列有穷。</p>
<p>我们反证，假设序列无穷：现在看 <span
class="math inline">\(a_1\)</span>，设其分解为 <span
class="math inline">\(p_1p_2\cdots p_s\)</span>，由于 <span
class="math inline">\(a_2\)</span> 是 <span
class="math inline">\(a_1\)</span> 的真因子，设 <span
class="math inline">\(a_2\)</span> 的分解为 <span
class="math inline">\(q_1 q_2\cdots q_r\)</span>，且 <span
class="math inline">\(a_1=qa_2\)</span>，那么由于 <span
class="math inline">\(q\)</span> 不是单位，不妨把 <span
class="math inline">\(q\)</span> 写作 <span
class="math inline">\(q_{r+1}\cdots q_s\)</span> 的形式，有 <span
class="math inline">\(a_1=q_1\cdots q_s=p_1\cdots p_s\)</span>，于是
<span
class="math inline">\(r&lt;s\)</span>，于是该序列不可约元的分解长度是递降的，这与序列长度无穷矛盾。</p>
<p>然后是素性条件：设 <span class="math inline">\(p\)</span>
是不可约元且 <span class="math inline">\(p\mid ab\)</span>，那么若 <span
class="math inline">\(a,b\)</span> 中存在单位，不妨设 <span
class="math inline">\(a\)</span> 是单位，由于 <span
class="math inline">\(ab=pq\)</span>，则有 <span
class="math inline">\(b=a^{-1}pq\)</span>，于是 <span
class="math inline">\(p\mid b\)</span>。</p>
<p>若 <span class="math inline">\(a,b\)</span> 均不是单位，设 <span
class="math inline">\(ab=pq\)</span>，利用唯一分解将 <span
class="math inline">\(ab,q\)</span> 拆分得到 <span
class="math inline">\(p_1p_2\cdots p_r=p q_1q_2\cdots
q_{r-1}\)</span>.</p>
<p>利用唯一性，知道 <span class="math inline">\(p\)</span> 与左侧一
<span class="math inline">\(p_i\)</span> 相伴，故定有 <span
class="math inline">\(p\mid a\)</span> 或 <span
class="math inline">\(p\mid b\)</span>。</p>
<p>(<span
class="math inline">\(\Leftarrow\)</span>)：先来看分解的存在性。对任意非单位
<span
class="math inline">\(a\)</span>，设它是因子链的第一项，由于任意因子链都是有限的，因此
<span class="math inline">\(a\)</span>
一定可以写成有限个不可约元的乘积。</p>
<p>只需说明唯一性。这里，我们需要用到素性条件：设 <span
class="math inline">\(a=p_1p_2\cdots p_s=p&#39;_1p&#39;_2\cdots
p&#39;_t\)</span> 是两个 <span class="math inline">\(a\)</span>
的不可约分解。由素性条件，我们知道 <span
class="math inline">\(p_i\)</span> 与 <span
class="math inline">\(p_i&#39;\)</span> 都是素元。</p>
<p>又因为 <span class="math inline">\(p_i\mid p_1&#39;p_2&#39;\cdots
p_t&#39;\)</span>，总有 <span class="math inline">\(j\)</span> 使得
<span class="math inline">\(p_i\mid p_j&#39;\)</span>，由于 <span
class="math inline">\(p_j&#39;\)</span> 是不可约元定有 <span
class="math inline">\(p_i\sim p_j&#39;\)</span>。在两边式子删去 <span
class="math inline">\(p_i\)</span> 与 <span
class="math inline">\(p_j&#39;\)</span>，我们发现仍有 <span
class="math inline">\(p_1p_2\cdots p_{i-1}p_{i+1}\cdots \sim
p_1&#39;p_2&#39;\cdots p_{j-1}&#39;p_{j+1}&#39;\cdots\)</span>
成立，因而可以继续进行操作，这自然导出了 <span
class="math inline">\(s=t\)</span>，否则定有 <span
class="math inline">\(p_{i_1}\cdots p_{i_k}\sim
1\)</span>，这与它们不是单位矛盾。又由在这过程中，我们构造了一个置换，此时分解的唯一性成立。</p>
<p><span class="math inline">\(\square\)</span></p>
<ul>
<li><p>最大公因子条件</p>
<p>首先定义最大公因子。若 <span class="math inline">\(d\mid a,d\mid
b\)</span>，且 <span class="math inline">\(\forall c, c\mid a,c\mid
b\)</span> 有 <span class="math inline">\(c\mid d\)</span>，则称 <span
class="math inline">\(d\)</span> 是 <span
class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 的<strong>最大公因子</strong>。</p>
<p>记作 <span class="math inline">\(d=(a,b)\)</span>.
同理可以定义<strong>最小公倍子</strong>，记作 <span
class="math inline">\(m=[a,b]\)</span>.</p>
<p>若 <span class="math inline">\((a,b)=1\)</span>，则称 <span
class="math inline">\(a,b\)</span> 为<strong>互素</strong>的，<span
class="math inline">\(a,b\)</span> 互素的充要条件为 <span
class="math inline">\(a,b\)</span>
有一个为单位或其中一个的所有不可约因子都不是另一个的因子。</p>
<p>若 <span class="math inline">\(R\)</span>
中任意两个元素都有最大公因子，则称 <span
class="math inline">\(R\)</span>
满足<strong>最大公因子条件</strong>。</p>
<p>事实上，任意一个唯一分解环都满足最大公因子条件，且两个元素的最大公因子就是将它们的不可约分解相同部分合并后得到的元素。类似地，也可以求任意一个唯一分解环的最小公倍子。</p></li>
</ul>
<p>来看下列几个关于最大公因子的性质：</p>
<ul>
<li>若整区 <span class="math inline">\(R\)</span>
中任意两个元素有最大公因子，则任意多个元素也有最大公因子。</li>
<li><span class="math inline">\((a,(b,c))\sim((a,b),c)\)</span>。</li>
<li><span class="math inline">\(c(a,b)\sim(ca,cb)\)</span>。</li>
<li>若 <span class="math inline">\((a,b)=1,(a,c)=1\)</span>，则 <span
class="math inline">\((a,bc)=1\)</span>。</li>
</ul>
<p>上面的性质证明起来都是容易的。</p>
<ul>
<li>最大公因子条件蕴含素性条件。</li>
</ul>
<p>证明：来看不可约元 <span class="math inline">\(p\)</span>，若 <span
class="math inline">\(p\not \mid a, p\not \mid b\)</span>，要证明 <span
class="math inline">\(p\not \mid ab\)</span>，因为 <span
class="math inline">\(p\)</span> 不可约，<span
class="math inline">\((p,a)\sim 1\)</span>，<span
class="math inline">\((p,b)\sim 1\)</span>，由最大公因子的性质知 <span
class="math inline">\((p,ab)\sim 1\)</span>，于是 <span
class="math inline">\(p\not \mid ab\)</span>。</p>
<p><span class="math inline">\(\large(*)\)</span> 结论 2：<span
class="math inline">\(R\)</span> 是唯一分解环当且仅当 <span
class="math inline">\(R\)</span> 适合因子链条件与最大公因子条件。</p>
<p><strong>范数</strong></p>
<p>在证明一个整区不是 Gauss 整区时，有时会用到范数的概念。</p>
<p>来看这样一个例子：</p>
<ul>
<li><p>试证明：<span
class="math inline">\(\mathbb{Z}(\sqrt{-5})=\{m+n\sqrt{-5}\mid m,n\in
\mathbb{Z}\}\)</span> 满足因子链条件，但不是 Gauss 整区。</p>
<p>证明：对 <span
class="math inline">\(a=m+n\sqrt{-5}\)</span>，定义范数 <span
class="math inline">\(N(a)=m^2+5n^2\)</span>，该范数显然适合下列性质：</p>
<ul>
<li><span class="math inline">\(N(a)\geq 0\)</span>, <span
class="math inline">\(N(a)\in \mathbb{Z}\)</span> 且 <span
class="math inline">\(a=0\Leftrightarrow N(a)=0\)</span>；</li>
<li><span class="math inline">\(N(ab)=N(a)N(b)\)</span>.</li>
</ul>
<p>来看因子链条件：若 <span class="math inline">\(a\)</span> 是 <span
class="math inline">\(b\)</span> 的真因子，有 <span
class="math inline">\(b=ac\)</span>，于是 <span
class="math inline">\(N(b)=N(a)N(c)\)</span>，若 <span
class="math inline">\(N(c)=1\)</span>，则 <span
class="math inline">\(c=\pm1\)</span> 为单位，故而 <span
class="math inline">\(N(c)&gt;1\)</span>，故 <span
class="math inline">\(N(a)&lt;N(b)\)</span>，因子链条件满足。</p>
<p>不是 Gauss 整区：首先由范数，若 <span
class="math inline">\(a\)</span> 为单位，则 <span
class="math inline">\(N(a)=1\)</span>，进而有 <span
class="math inline">\(a=\pm 1\)</span>。我们来看唯一分解不成立：<span
class="math inline">\(9=3\cdot
3=(2+\sqrt{-5})(2-\sqrt{-5})\)</span>，然而这两个分解都是不可约分解且显然不等价，于是唯一分解不成立，它不是
Gauss 整区。</p></li>
</ul>
<p>另一个例子：</p>
<ul>
<li><p>试证明 <span class="math inline">\(\mathbb{Z}(\sqrt{10})\)</span>
不是 Gauss 整区。</p>
<p>证明：设 <span
class="math inline">\(a=m+n\sqrt{10}\)</span>，定义范数 <span
class="math inline">\(N(a)=m^2-10n^2\)</span>。</p>
<p>显然范数满足 <span
class="math inline">\(N(ab)=N(a)N(b)\)</span>，此时若 <span
class="math inline">\(a\)</span> 是单位则 <span
class="math inline">\(N(a)=1\)</span>，对 <span
class="math inline">\(-9=(1+\sqrt{10})(1-\sqrt{10})=3\cdot(-3)\)</span>
做类似上例分析即可。</p></li>
</ul>
<hr />
<h3 id="pid欧氏整区">3.6 PID·欧氏整区</h3>
<blockquote>
<p>“这是一个欧几里得，这是另一个欧几里得，辗转相除，啊，还是一个欧几里得！”</p>
<p>“这孩子已经疯了，埋了吧。”</p>
</blockquote>
<h4 id="主理想整区">主理想整区</h4>
<p>让我们从另一个角度理解整除的概念。有如下结论：设 <span
class="math inline">\((a)\)</span> 为 <span
class="math inline">\(a\)</span> 生成的主理想，则 <span
class="math inline">\(a\mid b\Leftrightarrow (b)\subset
(a)\Leftrightarrow b\in (a)\)</span>；</p>
<p><span class="math inline">\(a\)</span> 是 <span
class="math inline">\(b\)</span> 的真因子当且仅当 <span
class="math inline">\((b)\subsetneqq(a)\)</span>；自然，<span
class="math inline">\((a)=(b)\Leftrightarrow a\sim b\)</span>.</p>
<p>于是，因子链条件等价于如下条件：</p>
<p>环 <span class="math inline">\(R\)</span> 中不存在无限的主理想真升链
<span class="math inline">\((a_1)\subsetneqq
(a_2)\subsetneqq\cdots\)</span>.</p>
<p><strong>定义</strong></p>
<p>若交换整区 <span class="math inline">\(R\)</span>
中的理想都可以由一个元生成，则称 <span class="math inline">\(R\)</span>
是一个<strong>主理想整区</strong>，简写为 PID。</p>
<p>任意主理想整区都是高斯整区。</p>
<p>证明：因子链条件：反证。假设存在无限主理想真升链 <span
class="math inline">\(\{(a_i)\}\)</span>，记 <span
class="math inline">\((a)=\cup (a_i)\)</span>，于是有 <span
class="math inline">\(a\in \cup(a_i)\)</span>，于是 <span
class="math inline">\(\exists m\)</span> 使得 <span
class="math inline">\(a\in (a_m)\)</span>，那么 <span
class="math inline">\((a)\subset
(a_m)\)</span>，于是真包含关系必不成立，矛盾。</p>
<p>最大公因子条件：考虑由 <span class="math inline">\(a,b\)</span>
生成的理想 <span class="math inline">\((a,b)=(d)\)</span>，定有对任意
<span class="math inline">\(c\)</span> 满足 <span
class="math inline">\(c\mid a, c\mid b\)</span>，有 <span
class="math inline">\((a)\subset (c), (b)\subset (c)\)</span>，于是
<span class="math inline">\((d)\subset (c)\)</span>（由于 <span
class="math inline">\((d)\)</span> 是最小的生成理想），由定义知道 <span
class="math inline">\(d\)</span> 是 <span
class="math inline">\(a,b\)</span>
的最大公因子，因此对任意两个元素都存在最大公因子，条件成立。</p>
<p><strong>额外性质</strong></p>
<ul>
<li><p>对主理想整区，<strong>裴蜀定理</strong>成立，即对 <span
class="math inline">\(a,b\)</span>，设 <span
class="math inline">\(d=(a,b)\)</span>，存在 <span
class="math inline">\(s,t\)</span> 使得 <span
class="math inline">\(as+bt=d\)</span></p>
<p>证明：利用 <span class="math inline">\((d)=(a,b)=(a)+(b)\)</span>
即得。</p></li>
</ul>
<h4 id="欧氏整区">欧氏整区</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(R\)</span> 是一个交换整区，若存在从
<span class="math inline">\(R^*\)</span> 至非负整数集合的映射 <span
class="math inline">\(\delta\)</span> 满足如下条件，则称 <span
class="math inline">\(R\)</span> 是一个<strong>欧氏整区</strong>，称
<span class="math inline">\(\delta\)</span>
为一个<strong>欧氏赋值</strong>：</p>
<ul>
<li>若 <span class="math inline">\(a,b\in R\)</span> 且 <span
class="math inline">\(b\neq 0\)</span>，则存在 <span
class="math inline">\(q, r\)</span> 使得 <span
class="math inline">\(a=bq+r\)</span>，且要么 <span
class="math inline">\(r=0\)</span>，要么 <span
class="math inline">\(\delta(r)&lt;\delta(b)\)</span>；</li>
<li>对任意非零元 <span class="math inline">\(a,b\)</span>，总有 <span
class="math inline">\(\delta(a)\leq \delta(ab)\)</span>.</li>
</ul>
<p>一个直观的理解方法是考虑多项式环，其欧氏赋值就是多项式次数，故其为一个欧氏整区。</p>
<ul>
<li><p><span class="math inline">\(\mathbb{Z}[-1]=\{m+n\sqrt{-1}\mid
m,n\in \mathbb{Z}\}\)</span> 是欧氏整区。</p>
<p>证明：定义 <span
class="math inline">\(\delta(m+n\sqrt{-1})=m^2+n^2\)</span>，显然有
<span class="math inline">\(\delta(ab)=\delta(a)\delta(b)\)</span>，由于
<span class="math inline">\(\delta\)</span>
的值域为非负整数，于是第二个条件成立。</p>
<p>现在验证第一个条件：在复数域上总有 <span
class="math inline">\(ab^{-1}=u+v\sqrt{-1}\)</span>，现在取 <span
class="math inline">\(\mu,\nu\)</span> 为距离 <span
class="math inline">\(u,v\)</span>
最近的整数，我们来验证第一个条件成立：</p>
<p>设 <span class="math inline">\(\epsilon=u-\mu,\tau=v-\nu\)</span>，则
<span
class="math inline">\(a=b((\mu+\epsilon)+(\nu+\tau)\sqrt{-1})=b(\mu+\nu\sqrt{-1})+b(\epsilon+\tau\sqrt{-1})\)</span>.</p>
<p>由于 <span class="math inline">\(\epsilon,\tau\leq
\cfrac{1}{2}\)</span>，故 <span
class="math inline">\(\delta(b(\epsilon+\tau\sqrt{-1}))\leq
\cfrac{1}{2}\delta(b)\leq \delta(b)\)</span>.</p>
<p>故 <span class="math inline">\(\mathbb{Z}[-1]\)</span>
是欧氏整区。</p></li>
<li><p>欧氏整区是 PID。</p>
<p>证明：对欧氏整区 <span class="math inline">\(R\)</span> 的任一理想
<span class="math inline">\(I\)</span>，考虑其中使得 <span
class="math inline">\(\delta\)</span> 取得最小值的 <span
class="math inline">\(b\)</span>，现在我们考虑 <span
class="math inline">\((b)\)</span>。</p>
<p>若 <span class="math inline">\((b)\neq I\)</span>，取任意 <span
class="math inline">\(a\in I\)</span> 且 <span
class="math inline">\(a\not \in (b)\)</span>，那么 <span
class="math inline">\(a\)</span> 一定不能写成 <span
class="math inline">\(qb\)</span> 的形式，故 <span
class="math inline">\(a=qb+r\)</span>。</p>
<p>然而由于假设，<span class="math inline">\(\delta(r)\geq
\delta(b)\)</span>，矛盾。</p></li>
</ul>
<p>由此，我们在这两章定义出了一串关系：欧氏整区 <span
class="math inline">\(\to\)</span> PID <span
class="math inline">\(\to\)</span> Gauss 整区。</p>
<p><strong>额外性质</strong></p>
<p>对欧氏赋值 <span
class="math inline">\(\delta\)</span>，我们还有下列的额外性质：</p>
<ul>
<li><span class="math inline">\(\delta(1)\leq\delta(a)\)</span> 对一切
<span class="math inline">\(a\neq 0\)</span> 成立；</li>
<li>若 <span class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 相伴，则 <span
class="math inline">\(\delta(a)=\delta(b)\)</span>；</li>
<li>若 <span class="math inline">\(a\mid b\)</span> 且 <span
class="math inline">\(\delta(a)=\delta(b)\)</span>，则 <span
class="math inline">\(a\sim b\)</span>；</li>
<li>若 <span class="math inline">\(a,b\neq 0\)</span> 且 <span
class="math inline">\(b\)</span> 不是单位，则 <span
class="math inline">\(\delta(a)&lt;\delta(ab)\)</span>；</li>
<li>若 <span class="math inline">\(a\)</span> 是单位，则 <span
class="math inline">\(\delta(a)=\delta(1)\)</span>.</li>
</ul>
<p>只证明第三条，其余几条是容易的：</p>
<p>设 <span class="math inline">\(a=bq+r\)</span>，若 <span
class="math inline">\(r=0\)</span>，那么直接得到结论；</p>
<p>若 <span class="math inline">\(r\neq 0\)</span>，那么 <span
class="math inline">\(\delta(r)&lt;\delta(b)=\delta(a)\)</span>，由
<span class="math inline">\(a\mid b\)</span> 有 <span
class="math inline">\(b=au\)</span>，故 <span
class="math inline">\(a=auq+r\)</span>，于是 <span
class="math inline">\(r=(1-uq)a\)</span>，于是 <span
class="math inline">\(\delta(r)\geq \delta(a)\)</span>，矛盾。</p>
<p>对欧氏整区，我们有如下性质：</p>
<ul>
<li><p>在欧氏整区中，<strong>辗转相除法</strong>成立。</p>
<p>利用欧氏整区的 <span class="math inline">\(\delta\)</span>
递减构造即可。</p></li>
</ul>
<hr />
<h3 id="多项式环">3.7&amp;8 多项式环</h3>
<blockquote>
<p>“我学到 多项式环”</p>
<p>“复习着高代的内容”</p>
<p>“想象着 曾经学高代”</p>
<p>“为什么摆得这么狠”</p>
<p>——《好久不见》</p>
</blockquote>
<h4 id="域上的一元多项式环">域上的一元多项式环</h4>
<p>我们定义一个多项式 <span class="math inline">\(f\)</span> 的 <span
class="math inline">\(\deg f\)</span>
为其<strong>最高次项的次数</strong>。约定 <span
class="math inline">\(\deg 0=-\infty\)</span>。</p>
<p>显然，<span class="math inline">\(\deg\)</span> 具有性质：<span
class="math inline">\(\deg f(x)g(x)=\deg f(x)+\deg g(x)\)</span>.</p>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(F\)</span> 是一个域，记 <span
class="math inline">\(F[x]\)</span> 为以 <span
class="math inline">\(F\)</span>
中元素为系数的一元多项式全体，称为<strong>一元多项式环</strong>。</p>
<p><strong>性质</strong></p>
<ul>
<li><p><span class="math inline">\(F[x]\)</span> 是一个欧氏整区。</p>
<p>证明：设 <span class="math inline">\(\delta(f(x))=\deg
f\)</span>，则容易验证这是一个欧氏赋值。</p></li>
</ul>
<p>显然有推论：</p>
<ul>
<li><span class="math inline">\(F[x]\)</span>
中的任一多项式都可以写成有限个不可约多项式的乘积。</li>
</ul>
<p>怎样的多项式是不可约的呢？回忆整除的理想诠释，有：</p>
<ul>
<li><p><span class="math inline">\(f(x)\)</span>
是不可约多项式的充要条件是 <span class="math inline">\((f(x))\)</span>
是一个<strong>极大理想</strong>，即不存在真理想 <span
class="math inline">\(I\)</span>，使得该理想是 <span
class="math inline">\(I\)</span> 的真子集。</p>
<p>证明是容易的。</p></li>
</ul>
<p>极大理想这一条件是抽象的，我们来让它具象化：怎样的理想才是极大理想呢？</p>
<ul>
<li><p>设 <span class="math inline">\(R\)</span>
是带恒等元的交换环，<span class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span> 的理想且 <span
class="math inline">\(I\neq R\)</span>，则 <span
class="math inline">\(I\)</span> 是 <span
class="math inline">\(R\)</span> 极大理想的充要条件是 <span
class="math inline">\(R/I\)</span> 是一个域。</p>
<p>证明：若 <span class="math inline">\(I\)</span>
是极大理想，由同态基本定理，从 <span class="math inline">\(I\)</span> 到
<span class="math inline">\(R/I\)</span> 的自然同态诱导了 <span
class="math inline">\(R\)</span> 中包含 <span
class="math inline">\(I\)</span> 的理想到 <span
class="math inline">\(R/I\)</span> 的同构。由于 <span
class="math inline">\(I\)</span> 是极大理想，故 <span
class="math inline">\(R/I\)</span> 只有平凡理想。又因为 <span
class="math inline">\(R/I\)</span> 显然是带恒等元的交换环，故而 <span
class="math inline">\(R/I\)</span> 是域；反之，若 <span
class="math inline">\(R/I\)</span> 是域，则 <span
class="math inline">\(R/I\)</span> 只有平凡理想，因此 <span
class="math inline">\(I\)</span> 是极大理想。</p></li>
<li><p><span class="math inline">\(f(x)\)</span>
是不可约多项式的充要条件是 <span
class="math inline">\(F[x]/(f(x))\)</span> 是域。</p></li>
</ul>
<p><strong>代数元与超越元</strong></p>
<p>考虑域 <span class="math inline">\(S\)</span> 是 <span
class="math inline">\(F\)</span> 的域扩张，即 <span
class="math inline">\(F\)</span> 是 <span
class="math inline">\(S\)</span> 的一个子环，来看 <span
class="math inline">\(S\)</span> 中的元素 <span
class="math inline">\(u\)</span>，现在我们定义代数元与超越元的概念：</p>
<p>设 <span class="math inline">\(F[u]=\{a_0+a_1u+\cdots+a_nu^n\mid
a_i\in F\}\)</span>，自然有 <span class="math inline">\(F[x]\)</span> 到
<span class="math inline">\(F[u]\)</span> 的满同态 <span
class="math inline">\(\eta:f(x)\to f(u)\)</span>.</p>
<p><span class="math inline">\(F[u]\)</span> 显然是 <span
class="math inline">\(S\)</span> 的一个子环。此时，若 <span
class="math inline">\(\eta\)</span> 是同构，则称 <span
class="math inline">\(u\)</span> 是一个<strong>超越元</strong>；</p>
<p>否则，一定有 <span class="math inline">\(\text{Ker} \eta\neq
0\)</span>，此时称 <span class="math inline">\(u\)</span>
为一个<strong>代数元</strong>。</p>
<p>当 <span class="math inline">\(\text{Ker}\eta \neq 0\)</span>，则
<span class="math inline">\(\text{Ker}\eta\)</span>
可以由一个多项式生成（PID），设这个多项式为 <span
class="math inline">\(f\)</span>，于是 <span
class="math inline">\(F[u]\cong F[x]/(f(x))\)</span>，且 <span
class="math inline">\(f(u)=0\)</span>，这也是<strong>代数元</strong>名称的由来。若
<span class="math inline">\(f\)</span> 是一个不可约多项式，则 <span
class="math inline">\(F[u]\)</span> 是 <span
class="math inline">\(F\)</span> 的一个<strong>扩域</strong>。</p>
<p><strong>多项式的根</strong></p>
<p>设 <span class="math inline">\(f(x)\in F[x]\)</span>，若 <span
class="math inline">\(S\)</span> 中的元 <span
class="math inline">\(u\)</span> 适合 <span
class="math inline">\(f(u)=0\)</span>，则称其为 <span
class="math inline">\(f(x)\)</span> 的根。若 <span
class="math inline">\(u\)</span> 为 <span
class="math inline">\(F\)</span>
上代数元，必然有一个次数最小的首一多项式使得 <span
class="math inline">\(f(u)=0\)</span>，称之为 <span
class="math inline">\(u\)</span> 的最小多项式。</p>
<p>对多项式的根我们有<strong>余数定理</strong>：</p>
<ul>
<li><p>若 <span class="math inline">\(f(x)\in F[x],a\in
F\)</span>，则存在唯一 <span class="math inline">\(q(x)\)</span> 使得
<span class="math inline">\(f(x)=(x-a)q(x)+f(a)\)</span>.</p>
<p>证明是容易的。</p></li>
</ul>
<p>由定理有根的<strong>判别条件</strong>：<span
class="math inline">\((x-a)\mid f(x)\Leftrightarrow a\)</span> 是 <span
class="math inline">\(f\)</span> 的根。</p>
<p>由此，我们也有：</p>
<ul>
<li><p><span class="math inline">\(F[x]\)</span> 上的 <span
class="math inline">\(n\)</span> 次多项式在 <span
class="math inline">\(F\)</span> 中至多只有 <span
class="math inline">\(n\)</span> 个不同的根。</p>
<p>证明利用上述判别条件是容易的。</p></li>
</ul>
<p><strong>一些其他性质</strong></p>
<ul>
<li><p>任何域的有限乘法子群是循环群。</p>
<p>考虑子群 <span class="math inline">\(G\)</span>，设其阶为 <span
class="math inline">\(n\)</span>，显然每个元的阶都是 <span
class="math inline">\(n\)</span> 的因子。若 <span
class="math inline">\(G\)</span> 不是循环群，那么存在 <span
class="math inline">\(g\mid n,g&lt;n\)</span>，使得 <span
class="math inline">\(\forall x\in G,x^g=1\)</span>.</p>
<p>然而，对方程 <span class="math inline">\(x^g-1=0\)</span>，其至多有
<span class="math inline">\(g\)</span> 个不同的根，这与 <span
class="math inline">\(G\)</span> 中有 <span
class="math inline">\(n\)</span> 个元素矛盾。因此 <span
class="math inline">\(G\)</span> 中必然存在周期为 <span
class="math inline">\(n\)</span> 的元素，<span
class="math inline">\(G\)</span> 为循环群。</p></li>
<li><p>任意有限域关于乘法是循环群。例如 <span
class="math inline">\(\mathbb{Z}_p\)</span>（<span
class="math inline">\(p\)</span> 为素数）是循环群。</p>
<p>这是上面结论的自然推论。</p></li>
<li><p>构造具备指定元素数目的域的方法：</p>
<p>例如，欲构造具备 <span class="math inline">\(25\)</span>
个元素的域，利用 <span class="math inline">\(25=5\times
5\)</span>，只需在 <span class="math inline">\(\mathbb{Z}_5\)</span>
中找一个不可约的二次多项式即可，这样 <span
class="math inline">\(\mathbb{Z}_5[x]/(f(x))\)</span> 自然是一个有 <span
class="math inline">\(25\)</span> 个元素的域。</p></li>
</ul>
<h4 id="交换环上的多元多项式环">交换环上的多元多项式环</h4>
<p>方才我们研究了域上的一元多项式环，现在我们来将一元多项式环推广至多元多项式环，并将多项式环的定义推广至交换环上。</p>
<p><strong>多元多项式环</strong></p>
<p>现在我们假设 <span class="math inline">\(R\)</span>
为一个含恒等元的交换环，现在归纳定义 <span
class="math inline">\(R\)</span> 上的多元多项式：</p>
<p><span
class="math inline">\(R[x_1,x_2,\cdots,x_r]=R[x_1,x_2,\cdots,x_{r-1}][x_r]\)</span>.</p>
<p>不难证明如下性质：</p>
<ul>
<li>若 <span class="math inline">\(D\)</span> 为整区，则 <span
class="math inline">\(D[x]\)</span> 为整区；</li>
<li>若 <span class="math inline">\(D\)</span> 为整区，则 <span
class="math inline">\(D[x_1,x_2,\cdots,x_r]\)</span> 为整区</li>
</ul>
<p><strong>泛性</strong></p>
<p>设 <span class="math inline">\(R\)</span>
是一个带恒等元的交换环，<span class="math inline">\(r\)</span>
是一个正整数，则 <span class="math inline">\(R[x_1,\cdots,x_r]\)</span>
（下面简记为 <span
class="math inline">\(R[x_i]\)</span>）满足如下性质：</p>
<p>若 <span class="math inline">\(S\)</span>
是另一个带恒等元的交换环，<span class="math inline">\(\varphi\)</span>
是一个 <span class="math inline">\(R\)</span> 到 <span
class="math inline">\(S\)</span> 的环同态，<span
class="math inline">\(u_1,\cdots,u_r\)</span> 是 <span
class="math inline">\(S\)</span> 中的 <span
class="math inline">\(r\)</span> 个元素，则必存在 <span
class="math inline">\(R[x_1,\cdots,x_r]\)</span> 到 <span
class="math inline">\(S\)</span> 的唯一环同态 <span
class="math inline">\(\tilde\varphi\)</span>，满足 <span
class="math inline">\(\forall a\in
R,\tilde\varphi(a)=\varphi(a)\)</span>，且 <span
class="math inline">\(\tilde\varphi(x_i)=u_i\)</span>.</p>
<p>证明：利用归纳法。对 <span
class="math inline">\(r=1\)</span>，我们构造映射 <span
class="math inline">\(\tilde\varphi(a_0+a_1x+\cdots+a_nx^n)=\varphi(a_0)+\varphi(a_1)u+\cdots+\varphi(a_n)u^n\)</span>
即可，容易验证这满足题设且由于 <span class="math inline">\(R[x]\)</span>
由 <span class="math inline">\(R\)</span> 与 <span
class="math inline">\(x\)</span> 生成故唯一；</p>
<p>对 <span class="math inline">\(r&gt;1\)</span>，只需要利用 <span
class="math inline">\(r=1\)</span>
的证明方法利用多元多项式环的归纳定义证明即可。</p>
<p><strong>泛性的推论</strong></p>
<ul>
<li><p>同一个环 <span class="math inline">\(R\)</span> 上的两个 <span
class="math inline">\(r\)</span> 元多项式环必同构。</p>
<p>证明：设两个环为 <span class="math inline">\(R[x_i]\)</span> 与 <span
class="math inline">\(R[y_i]\)</span>。利用泛性，我们可以构造出映射
<span class="math inline">\(\varphi\)</span> 使得 <span
class="math inline">\(\varphi(a)=a,\forall a\in R\)</span> 且 <span
class="math inline">\(\varphi(x_i)=y_i\)</span>；同理可以构造出 <span
class="math inline">\(\psi\)</span> 使得 <span
class="math inline">\(\psi(a)=a\)</span> 且 <span
class="math inline">\(\psi(y_i)=x_i\)</span>。可以验证它们的复合为恒等映射，即它们互为逆映射，于是是同构映射，于是
<span class="math inline">\(R[x_i]\cong R[y_i]\)</span>.</p></li>
</ul>
<p>有自然推论：</p>
<ul>
<li>对多元多项式环 <span class="math inline">\(R[x_i]\)</span>，<span
class="math inline">\(\pi\)</span> 是 <span
class="math inline">\(\{1,2,\cdots,r\}\)</span> 的一个置换，则存在唯一
<span class="math inline">\(R[x_i]\)</span> 的自同构 <span
class="math inline">\(\varphi\)</span>，使得 <span
class="math inline">\(\varphi(x_i)=x_{\pi(i)}\)</span>.</li>
</ul>
<p>接下来我们引入代数无关的概念，它是超越元的自然推广：</p>
<p><span class="math inline">\(R[x_i]\)</span> 中元 <span
class="math inline">\(a_{i_1,\cdots,i_r}x_1^{i_1}x_2^{i_2}\cdots
x_r^{i_r}\)</span> 通常被称为单项式，<span
class="math inline">\(R[x_i]\)</span>
中的元素都可以写成单项式的有限和。<span
class="math inline">\(R[x_i]\)</span>
中两个多项式相等当且仅当它们的每个单项式前系数相等。</p>
<p>现在引入<strong>代数无关</strong>的定义：</p>
<p>设 <span class="math inline">\(R\)</span> 是 <span
class="math inline">\(S\)</span> 的子环，<span
class="math inline">\(u_1,\cdots,u_r\in S\)</span>，可以导出同态映射
<span class="math inline">\(\varphi:R[x_1,x_2,\cdots,x_r]\to
R[u_1,u_2,\cdots,u_r]\)</span>，这其中 <span
class="math inline">\(\varphi(f)=f(u_1,u_2,\cdots,u_r)\)</span>.</p>
<p>若 <span class="math inline">\(\varphi\)</span> 是一个同构，我们则称
<span class="math inline">\(u_1,\cdots,u_r\)</span>
是<strong>代数无关</strong>的，反之则是<strong>代数相关</strong>的。显然
<span class="math inline">\(r\)</span> 个元代数无关的充要条件是不存在
<span class="math inline">\(R[x_i]\)</span> 中多项式使得这 <span
class="math inline">\(r\)</span> 个元代入后为 <span
class="math inline">\(0\)</span>。</p>
<p><strong>多项式的分解·本原多项式·Gauss 引理</strong></p>
<p>对域 <span class="math inline">\(F\)</span>，有如下重要定理：</p>
<ul>
<li><p>若 <span class="math inline">\(F\)</span> 是无限域，则对 <span
class="math inline">\(F\)</span> 上任一 <span
class="math inline">\(r\)</span> 元非零多项式 <span
class="math inline">\(f(x_1,\cdots,x_r)\)</span>，总能找到一组元 <span
class="math inline">\((a_1,\cdots,a_r),a_i\in F\)</span>，使得 <span
class="math inline">\(f(a_1,\cdots,a_r)\neq 0\)</span>.</p>
<p>证明：归纳。对 <span class="math inline">\(r=1\)</span>
显然成立；</p>
<p>利用归纳假设，并利用多元多项式的归纳定义，可以较为简单地证明对任意
<span class="math inline">\(r\)</span> 成立。</p></li>
</ul>
<p>我们先前已经证明了在数域上的多项式环是唯一分解环，它进一步还是欧氏整区。那么，定义在一般交换环上的多项式环有这样的性质吗？我们来研究这一点。</p>
<p>为此，我们引入<strong>本原多项式</strong>的概念。</p>
<p>设 <span class="math inline">\(R\)</span> 是 Gauss 整区，那么 <span
class="math inline">\(R\)</span> 中任意有限多个元素都有最大公因子。设
<span class="math inline">\(f(x)=a_0+\cdots+a_nx^n\)</span>，若 <span
class="math inline">\((a_0,a_1,\cdots,a_n)=1\)</span>，则称 <span
class="math inline">\(f(x)\)</span> 是<strong>本原多项式</strong>。</p>
<p>有如下引理：</p>
<ul>
<li><p>若 <span class="math inline">\(R\)</span> 是 Gauss 整区，<span
class="math inline">\(F\)</span> 是 <span
class="math inline">\(R\)</span> 的分式域且 <span
class="math inline">\(f(x)\)</span> 是 <span
class="math inline">\(F\)</span> 中非零多项式，则 <span
class="math inline">\(f(x)=rf_1(x)\)</span>，其中 <span
class="math inline">\(r\in F\)</span> 且 <span
class="math inline">\(f_1(x)\)</span> 是 <span
class="math inline">\(R[x]\)</span>
中的本原多项式。另外，上述分解在相差一个单位的意义下是唯一的。</p>
<p>证明：利用分式域的定义进行证明虽然较为繁琐，但是是容易的，这里略去。</p></li>
</ul>
<p>于是有：</p>
<ul>
<li><p><span class="math inline">\(R\)</span> 是 Gauss 整区，设 <span
class="math inline">\(f(x)\)</span> 与 <span
class="math inline">\(g(x)\)</span> 是本原多项式，若它们在 <span
class="math inline">\(F[x]\)</span> 中相伴，则它们也在 <span
class="math inline">\(R[x]\)</span> 中相伴。</p>
<p>证明：直接利用上述引理即可说明。</p></li>
</ul>
<p>进一步引入 Gauss 引理：</p>
<ul>
<li><p>本原多项式之积仍是本原多项式。</p>
<p>证明：反证法。假设 <span class="math inline">\(f,g\)</span>
是本原多项式，但 <span class="math inline">\(h=f\cdot g\)</span>
不是本原多项式，那么有 <span class="math inline">\(R\)</span> 中的素元
<span class="math inline">\(p\)</span> 使得 <span
class="math inline">\(p\mid h\)</span> 而 <span
class="math inline">\(p\not \mid f,p\not \mid g\)</span>.</p>
<p>因为 <span class="math inline">\(p\)</span> 是素元，<span
class="math inline">\(p\)</span> 不可分解，于是 <span
class="math inline">\(\bar R=R/(p)\)</span> 为整区。考虑 <span
class="math inline">\(\bar R[x]\)</span>，有 <span
class="math inline">\(\bar f\neq 0,\bar g\neq 0\)</span>，然而 <span
class="math inline">\(\bar f\cdot \bar g=\bar
h=0\)</span>，这与整区矛盾。</p></li>
</ul>
<p>有如下推论：</p>
<ul>
<li><p>设 <span class="math inline">\(f(x)\in R[x], \deg
f(x)&gt;0\)</span>，则若 <span class="math inline">\(f(x)\)</span> 在
<span class="math inline">\(R[x]\)</span> 中不可约，则它在 <span
class="math inline">\(F[x]\)</span> 中也不可约，这里 <span
class="math inline">\(F\)</span> 是 <span
class="math inline">\(R\)</span> 的分式域。</p>
<p>证明：显然 <span class="math inline">\(f(x)\)</span>
是本原多项式，否则，设 <span
class="math inline">\(f(x)=cf_1(x)\)</span>，其中 <span
class="math inline">\(c\)</span> 为 <span
class="math inline">\(R\)</span> 中元素，<span
class="math inline">\(f_1\)</span> 为本原多项式，于是有 <span
class="math inline">\(f(x)\)</span> 可约，矛盾。</p>
<p>自然可以推出 <span class="math inline">\(f(x)\)</span> 也是 <span
class="math inline">\(F[x]\)</span> 中本原多项式。</p>
<p>假设 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(F[x]\)</span> 中可以被分解为 <span
class="math inline">\(\varphi_1(x)\varphi_2(x)\)</span>，显然 <span
class="math inline">\(\deg \varphi_i&gt;0\)</span>，则由上面引理，有
<span class="math inline">\(\varphi_i=a_if_i\)</span>，其中 <span
class="math inline">\(f_i\)</span> 为 <span
class="math inline">\(R[x]\)</span> 中本原多项式， <span
class="math inline">\(a_i\in F\)</span>。</p>
<p>故而 <span class="math inline">\(f(x)=a_1a_2f_1(x)f_2(x)\)</span>，由
Gauss 引理知道 <span class="math inline">\(f_1(x)f_2(x)\)</span>
也是本原多项式，因此它们在 <span class="math inline">\(R\)</span>
中只相差一个单位，这与不可约矛盾。</p></li>
</ul>
<p>综合上述定理，我们得出最后的推论：</p>
<ul>
<li><p>若 <span class="math inline">\(R\)</span> 是唯一分解环，则 <span
class="math inline">\(R[x]\)</span> 也是唯一分解环。</p>
<p>证明：设 <span class="math inline">\(f(x)\neq 0\in R[x]\)</span> 且
<span class="math inline">\(f(x)\)</span> 不是单位，则 <span
class="math inline">\(f(x)=d_1f_1(x)\)</span>，其中 <span
class="math inline">\(f_1(x)\)</span>
为本原多项式。我们首先来看对任意本原多项式 <span
class="math inline">\(f_1(x)\)</span> 分解的唯一性：</p>
<p>设 <span class="math inline">\(f_1=q_1\cdots q_r=q_1&#39;\cdots
q_s&#39;\)</span>，其中 <span class="math inline">\(q_i\)</span> 与
<span class="math inline">\(q_i&#39;\)</span> 在 <span
class="math inline">\(R[x]\)</span> 上不可约。由上面的推论我们知道 <span
class="math inline">\(q_i\)</span> 与 <span
class="math inline">\(q_i&#39;\)</span> 在 <span
class="math inline">\(F[x]\)</span> 中不可约。而 <span
class="math inline">\(F[x]\)</span> 是唯一分解环，因而 <span
class="math inline">\(q_1\cdots q_r\)</span> 与 <span
class="math inline">\(q_1&#39;\cdots q_s&#39;\)</span> 是等价的，从而
<span class="math inline">\(f_1(x)\)</span> 的分解是唯一的。</p>
<p>对 <span class="math inline">\(d_1\)</span>，由于 <span
class="math inline">\(R\)</span> 是唯一分解环，因此对 <span
class="math inline">\(d_1\)</span> 的分解是唯一的。综上对 <span
class="math inline">\(f(x)\)</span> 的分解是唯一的。</p></li>
<li><p>若 <span class="math inline">\(R\)</span> 是唯一分解环，则 <span
class="math inline">\(R[x_i]\)</span> 也是唯一分解环。</p>
<p>这是上述结论的直接推论。</p></li>
</ul>
<p><strong>其他性质</strong></p>
<ul>
<li><p><span class="math inline">\(R\)</span> 是含恒等元的交换环，<span
class="math inline">\(R[x]\)</span> 中 <span
class="math inline">\(f(x)\)</span>
是可逆元当且仅当其零次项系数是可逆元且高次项系数为幂零元。</p>
<p>证明：必要性是显然的。我们来证充分性：设 <span
class="math inline">\(f(x)^{-1}=g(x)\)</span>，而 <span
class="math inline">\(f(x)=a_0+\cdots+a_n x^n,
g(x)=b_0+\cdots+b_mx^m\)</span>. 显然，因为 <span
class="math inline">\(f\cdot g=1\)</span>，因此 <span
class="math inline">\(a_0b_0=1\)</span>，因此 <span
class="math inline">\(a_0\)</span> 是可逆元。接下来我们来证明 <span
class="math inline">\(a_n\)</span> 是幂零元：</p>
<p>显然 <span
class="math inline">\(a_nb_m=0=a_nb_{m-1}+a_{n-1}b_m\)</span>，将右式同乘
<span class="math inline">\(a_n\)</span>，得到 <span
class="math inline">\(a_n^2b_{m-1}+(a_{n-1}a_nb_m)=a_n^2b_{m-1}=0\)</span>。以此类推，最后得到
<span class="math inline">\(a_{n}^{m+1} b_{0}=0\)</span>，由于 <span
class="math inline">\(b_0\)</span> 是可逆元，故 <span
class="math inline">\(a_n^{m+1}=0\)</span>，<span
class="math inline">\(a_n\)</span> 是幂零元。</p>
<p>注意到 <span class="math inline">\(a_nx^n\)</span> 是幂零元，故 <span
class="math inline">\(f(x)-a_nx^n\)</span>
仍是可逆元，因此反复操作即可证明 <span
class="math inline">\(a_i(i&gt;0)\)</span> 幂零。</p></li>
</ul>
<hr />
<h3 id="素理想">3.9 素理想</h3>
<blockquote>
<p>“我现在，是一个伟大的人吗？”</p>
</blockquote>
<p>这里涉及的环均为含恒等元的交换环。</p>
<h4 id="素理想-1">素理想</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(P\)</span> 是环 <span
class="math inline">\(R\)</span> 的理想且 <span
class="math inline">\(\forall a,b\in R\)</span>，若 <span
class="math inline">\(ab\in P\)</span>，则必有 <span
class="math inline">\(a\in P\)</span> 或 <span
class="math inline">\(b\in P\)</span>。此时称 <span
class="math inline">\(P\)</span> 是 <span
class="math inline">\(R\)</span> 的一个<strong>素理想</strong>。</p>
<p><strong>判别</strong></p>
<ul>
<li><p><span class="math inline">\(P\)</span> 是 <span
class="math inline">\(R\)</span> 的素理想当且仅当 <span
class="math inline">\(R/P\)</span> 为整区。</p>
<p>证明是容易的。</p></li>
<li><p>极大理想必是素理想。</p>
<p>由于环商极大理想为域，因此显然为素理想。</p></li>
</ul>
<p><strong>存在性</strong></p>
<ul>
<li><p>设 <span class="math inline">\(R\)</span>
是一个含恒等元的交换环，<span class="math inline">\(I\)</span>
是它的一个理想且 <span class="math inline">\(I\neq R\)</span>，则 <span
class="math inline">\(I\)</span> 一定含于某个极大理想中。</p>
<p>证明：考虑所有不含恒等元 <span class="math inline">\(1\)</span>
的理想集合间由子集关系定义的偏序关系，由 Zorn 引理即得。</p></li>
</ul>
<p>于是有推论：</p>
<ul>
<li><p>任意一个含有恒等元的环都有极大理想。</p></li>
<li><p><span class="math inline">\(R\)</span>
中的任意不可逆元一定含于一个极大理想中。</p>
<p>证明：设 <span class="math inline">\(r\)</span> 不可逆，一定有 <span
class="math inline">\((r)\neq R\)</span>.</p></li>
</ul>
<h4 id="小根与大根">小根与大根</h4>
<p><strong>定义</strong></p>
<p>交换环 <span class="math inline">\(R\)</span>
的所有素理想的交仍是理想，记作 <span
class="math inline">\(I\)</span>，这一理想称之为 <span
class="math inline">\(R\)</span> 的<strong>小根</strong>。</p>
<p>交换环 <span class="math inline">\(R\)</span>
的所有极大理想的交仍是理想，记作 <span
class="math inline">\(J\)</span>，这一理想称之为 <span
class="math inline">\(R\)</span>
的<strong>大根</strong>或<strong>Jacobson根</strong>。</p>
<p>显然，因为极大理想必是素理想，因此 <span
class="math inline">\(I\subseteq J\)</span>。</p>
<p><strong>定理与性质</strong></p>
<ul>
<li><p><span class="math inline">\(R\)</span> 的小根等于 <span
class="math inline">\(R\)</span>
的所有幂零元素与零元素组成的理想。零元素和幂零元素有时也称为<strong>诣零根</strong>。我们可以从某种程度上推广诣零根，见下。</p>
<p>证明：不妨记诣零根构成的理想为 <span
class="math inline">\(N\)</span>，现在说明 <span
class="math inline">\(N\subseteq I\)</span>：由于任何理想都包含 <span
class="math inline">\(0\)</span> 元素，设 <span
class="math inline">\(a\)</span> 为幂零元，而 <span
class="math inline">\(a^k=0=a^{k-1}a\)</span>，故而 <span
class="math inline">\(a\)</span> 属于任何素理想。</p>
<p>接下来说明 <span class="math inline">\(I\subseteq N\)</span>：假设
<span class="math inline">\(a\in I\)</span> 不是幂零元，构造集合 <span
class="math inline">\(S=\{a,a^2,\cdots\}\)</span>，考虑集合 <span
class="math inline">\(\Sigma\)</span> 为所有与 <span
class="math inline">\(S\)</span>
不交的理想构成的集合，显然有零理想，不为空集。于是由 Zorn 引理，<span
class="math inline">\(\Sigma\)</span> 有极大元，不妨设为 <span
class="math inline">\(M\)</span>，下面证明 <span
class="math inline">\(M\)</span> 是素理想。</p>
<p>设 <span class="math inline">\(bc\in M\)</span> 但是 <span
class="math inline">\(b,c\not\in M\)</span>，此时 <span
class="math inline">\(M+(b)\)</span> 与 <span
class="math inline">\(M+(c)\)</span> 都是严格包含 <span
class="math inline">\(M\)</span> 的理想，因此与 <span
class="math inline">\(S\)</span> 都相交。不妨设 <span
class="math inline">\(a^m\in M+(b),a^n\in M+(c)\)</span>，则 <span
class="math inline">\(a^{m+n}\in M+(bc)\)</span>. 这表明 <span
class="math inline">\(M+(bc)\)</span> 不是 <span
class="math inline">\(\Sigma\)</span> 中元素，然而 <span
class="math inline">\((bc)\subseteq M\)</span>，这与假设矛盾，因而 <span
class="math inline">\(M\)</span> 是素理想但 <span
class="math inline">\(a\not\in M\)</span>，故而与 <span
class="math inline">\(a\not\in I\)</span>，故与前提矛盾，故 <span
class="math inline">\(a\)</span> 为幂零元。</p></li>
<li><p>考虑理想 <span class="math inline">\(I&#39;\)</span>，定义 <span
class="math inline">\(\text{Rad}(I&#39;)=\{a\mid a\in R,\exists k\in
\mathbb{N},a^k\in I&#39;\}\)</span>. 我们知道 <span
class="math inline">\(\text{Rad}(0)=I\)</span>，即诣零根，小根。更多地，有
<span class="math inline">\(\text{Rad}(I&#39;)\)</span> 为所有 <span
class="math inline">\(R\)</span> 中包含 <span
class="math inline">\(I&#39;\)</span> 的素理想的交。</p>
<p>证明：考虑 <span
class="math inline">\(R/I&#39;\)</span>，其诣零根为所有素理想的交，故
<span class="math inline">\(\text{Rad}(I&#39;)\)</span> 为所有 <span
class="math inline">\(R\)</span> 中包含 <span
class="math inline">\(I&#39;\)</span> 的素理想的交。</p></li>
<li><p><span class="math inline">\(a\in J\)</span> 的充要条件是 <span
class="math inline">\(\forall r\in R, 1-ar\)</span> 是可逆元。</p>
<p>证明：</p>
<p>（<span class="math inline">\(\Rightarrow\)</span>）：<span
class="math inline">\(a\in J\)</span>，自然 <span
class="math inline">\(a\)</span> 属于所有极大理想。现在假设存在 <span
class="math inline">\(r\)</span>， <span
class="math inline">\(1-ar\)</span>
不可逆。此时由上面性质，它一定含于一个极大理想中。由于 <span
class="math inline">\(a\)</span> 也属于这个极大理想，因而 <span
class="math inline">\(1-ar+ar=1\)</span>
属于这个极大理想，这与其为真理想矛盾。</p>
<p>（<span
class="math inline">\(\Leftarrow\)</span>）：来证明逆否命题，即若 <span
class="math inline">\(a\not\in J\)</span>，则 <span
class="math inline">\(\exists r\)</span> 使得 <span
class="math inline">\(1-ar\)</span> 是不可逆元。由于 <span
class="math inline">\(a\not\in J\)</span>，那么存在极大理想 <span
class="math inline">\(M\)</span>，使得 <span
class="math inline">\(a\not\in M\)</span>，故 <span
class="math inline">\(M+(a)=R\)</span>，故 <span
class="math inline">\(1=ar+b\)</span>，其中 <span
class="math inline">\(r\in R,b\in M\)</span>. 因为 <span
class="math inline">\(b\)</span> 在极大理想中，<span
class="math inline">\(b\)</span> 一定不可逆，从而存在 <span
class="math inline">\(r\)</span> 使得 <span
class="math inline">\(b=1-ar\)</span> 是不可逆元。</p></li>
</ul>
<p><strong>其他性质&amp;作业题举例</strong></p>
<ul>
<li><p>常见环的素理想与极大理想举例：</p>
<ul>
<li><span class="math inline">\(\mathbb{Z}\)</span> 中的素理想是 <span
class="math inline">\((m)\)</span>，<span
class="math inline">\(m\)</span> 为素数，此时 <span
class="math inline">\((m)\)</span> 也为极大理想。</li>
<li><span class="math inline">\(F\)</span> 是域，<span
class="math inline">\(F[x]\)</span> 中 <span
class="math inline">\((f(x))\)</span> 是素理想当且仅当 <span
class="math inline">\(f(x)\)</span> 不可约，此时 <span
class="math inline">\((f(x))\)</span> 也是极大理想。</li>
<li><span class="math inline">\(R\)</span> 是 PID，<span
class="math inline">\((a)\)</span> 是素理想当且仅当 <span
class="math inline">\(a\)</span> 是素元，此时 <span
class="math inline">\((a)\)</span> 也是极大理想。</li>
<li><span class="math inline">\(\mathbb{Z}[x]\)</span> 中 <span
class="math inline">\((x)\)</span>
是素理想而不是极大理想，有一个更大的理想 <span
class="math inline">\((2,x)\)</span> 包含它。</li>
</ul></li>
<li><p>设 <span class="math inline">\(P_1,\cdots,P_n\)</span> 是环 <span
class="math inline">\(R\)</span> 中的 <span
class="math inline">\(n\)</span> 个素理想，<span
class="math inline">\(I\)</span> 是理想且 <span
class="math inline">\(I\subseteq\cup_{i=1}^nP_i\)</span>，则 <span
class="math inline">\(\exists P_i\)</span> 使得 <span
class="math inline">\(I\subseteq P_i\)</span>。</p>
<p>证明：归纳。对 <span class="math inline">\(n=1\)</span>
显然成立。</p>
<p>设结论对 <span class="math inline">\(n-1\)</span>
成立，现在反证结论不成立，则对每个 <span
class="math inline">\(i\)</span>，<span class="math inline">\(\exists
a_i\in I\)</span>，使得 <span class="math inline">\(a_i\)</span> 只属于
<span class="math inline">\(P_i\)</span> 而不属于其他任意 <span
class="math inline">\(P_j\)</span>。于是令 <span
class="math inline">\(b=\sum_{i=1}^na_1\cdots a_{i-1}a_{i+1}\cdots
a_n\)</span>，由假设，它一定不属于每个 <span
class="math inline">\(P_i\)</span>，这与 <span
class="math inline">\(I\subseteq \cup_{i=1}^n P_i\)</span>
矛盾。</p></li>
<li><p>设 <span class="math inline">\(P_1,\cdots,P_n\)</span> 是环 <span
class="math inline">\(R\)</span> 中的 <span
class="math inline">\(n\)</span> 个素理想，<span
class="math inline">\(I\)</span> 是<strong>素</strong>理想且 <span
class="math inline">\(\cap_{i=1}^n P_i\subseteq I\)</span>，则 <span
class="math inline">\(\exists P_i\)</span> 使得 <span
class="math inline">\(P_i\subseteq I\)</span>. 进一步地，若 <span
class="math inline">\(I=\cap_{i=1}^n P_i\)</span>，则 <span
class="math inline">\(\exists P_i\)</span> 使得 <span
class="math inline">\(I=P_i\)</span>.</p>
<p>证明：对前者证明后，后者是显然的。来看前者。假设结论不成立，则对每个
<span class="math inline">\(P_i\)</span>，有 <span
class="math inline">\(a_i\in P_i\)</span> 且 <span
class="math inline">\(a_i\not\in I\)</span>. 那因为素理想的性质，有
<span class="math inline">\(\prod a_i\not\in I\)</span>，然而显然 <span
class="math inline">\(\prod a_i\in \cap P_i\)</span>，矛盾。</p></li>
<li><p>对含恒等元的交换环 <span class="math inline">\(R\)</span>，有
<span class="math inline">\(I\)</span> 为其理想，<span
class="math inline">\(P\)</span> 为包含 <span
class="math inline">\(I\)</span> 的理想，则： <span
class="math inline">\(P\)</span> 为素理想 <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(P/I\)</span> 为 <span
class="math inline">\(R/I\)</span> 的素理想。</p>
<p>证明：利用同构第二定理即得。</p></li>
<li><p><span class="math inline">\(R\)</span> 是含恒等元的交换环，则
<span class="math inline">\(R[x]\)</span> 的大根和小根相同。</p>
<p>证明：我们证明任意大根中元素属于小根。即证明它是幂零元。考虑 <span
class="math inline">\(f(x)\in J\)</span>，则 <span
class="math inline">\(1-xf(x)\)</span>
可逆，由上一节证明的多项式可逆条件，则 <span
class="math inline">\(f(x)\)</span> 是幂零元，则 <span
class="math inline">\(f(x)\in I\)</span>.</p></li>
</ul>
<hr />
<h2 id="域">域</h2>
<h3 id="域的扩张">4.1 域的扩张</h3>
<p>在先前的环论中，我们已经知道，任何域都包含最小子域，该子域由域特征决定。当域特征为
<span class="math inline">\(p\neq 0\)</span>，该子域同构于 <span
class="math inline">\(\mathbb{Z}_p\)</span>，否则子域同构于 <span
class="math inline">\(\mathbb{Z}\)</span>.
回忆，我们将这个最小子域称为<strong>素域</strong>。</p>
<h4 id="扩域">扩域</h4>
<p><strong>定义</strong></p>
<p>我们假设 <span class="math inline">\(E\)</span> 是一个域，<span
class="math inline">\(F\)</span> 是 <span
class="math inline">\(E\)</span> 的子域，则称 <span
class="math inline">\(E\)</span> 为 <span
class="math inline">\(F\)</span>
的一个<strong>域扩张</strong>或称为<strong>扩域</strong>。</p>
<p><strong>表示</strong></p>
<p>假定 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，<span
class="math inline">\(S\)</span> 是 <span
class="math inline">\(E\)</span> 的子集，我们定义 <span
class="math inline">\(F(S)\)</span> 为 <span
class="math inline">\(E\)</span> 的由 <span
class="math inline">\(F\)</span> 及 <span
class="math inline">\(S\)</span> 生成的子域。即：<span
class="math inline">\(E\)</span> 的所有包含 <span
class="math inline">\(S\)</span> 也包含 <span
class="math inline">\(F\)</span> 的子域的交。若 <span
class="math inline">\(T\)</span> 是另一个 <span
class="math inline">\(E\)</span> 的子集，容易得到 <span
class="math inline">\(F(S)(T)=F(S\cup T)\)</span>.</p>
<p>因此，当 <span class="math inline">\(S\)</span>
是有限集的时候，可以递归表示这个扩张，即 <span
class="math inline">\(F(a_1,a_2,\cdots,a_n)=F(a_1,a_2,\cdots,a_{n-1})(a_n)\)</span>.</p>
<p>最简单的扩张自然是 <span class="math inline">\(S\)</span>
是单点集的情形。若 <span
class="math inline">\(S=\{u\}\)</span>，我们称此时的扩张为<strong>单扩张</strong>，称
<span class="math inline">\(u\)</span> 为<strong>本原元</strong>。</p>
<h4 id="单扩张">单扩张</h4>
<p><strong>性质</strong></p>
<p>我们在环论定义过 <span
class="math inline">\(F[u]=\{a_0+a_1u+\cdots+a_nu^n\mid a_i\in
F\}\)</span>. 我们知道有同态映射 <span
class="math inline">\(\varphi:F[x]\to F[u]\)</span>，并讨论过 <span
class="math inline">\(u\)</span> 是否是超越元。</p>
<p>当 <span class="math inline">\(u\)</span>
是<strong>代数元</strong>，因为 PID，有 <span
class="math inline">\(\text{Ker}\varphi=(g(x))\)</span>，且 <span
class="math inline">\(F[x]/(g(x))\cong F[u]\)</span>. <span
class="math inline">\(F[u]\)</span> 自然是一个包含 <span
class="math inline">\(F\)</span> 的域，因而为 <span
class="math inline">\(E\)</span>
的子域，并且可以说明不存在更小的同时包含 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(F\)</span> 的扩域。因此此时有 <span
class="math inline">\(F[u]=F(u)\)</span>；</p>
<p>反之，当 <span class="math inline">\(u\)</span>
是<strong>超越元</strong>，因为 <span class="math inline">\(F[x]\cong
F[u]\)</span>，此时 <span class="math inline">\(F[u]\)</span>
仅仅是欧氏整环，不是域。此时有 <span class="math inline">\(F(u)\)</span>
是 <span class="math inline">\(F[u]\)</span> 的分式域。</p>
<h4 id="域扩张的分类">域扩张的分类</h4>
<p>上面的单扩张可以被分成两种类型，域扩张是否也可以呢？事实上，根据扩域中是否存在超越元，域扩张可以被分为<strong>代数扩张</strong>和<strong>超越扩张</strong>。</p>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，若 <span
class="math inline">\(E\)</span> 中元素均为 <span
class="math inline">\(F\)</span> 中代数元，则称其为 <span
class="math inline">\(F\)</span>
的<strong>代数扩张</strong>，反之则称为<strong>超越扩张</strong>。</p>
<p><strong>例子</strong></p>
<ul>
<li><span class="math inline">\(\mathbb{Q}(\sqrt{-1})\)</span> 是 <span
class="math inline">\(\mathbb{Q}\)</span> 的代数扩张；</li>
<li><span class="math inline">\(\mathbb{Q}(\pi)\)</span> 是 <span
class="math inline">\(\mathbb{Q}\)</span> 的超越扩张。</li>
</ul>
<h4 id="扩域的维数">扩域的维数</h4>
<p><strong>定义</strong></p>
<p>若 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，我们将 <span
class="math inline">\(E\)</span> 看作 <span
class="math inline">\(F\)</span> 的线性空间，<span
class="math inline">\(E\)</span> 中元素看作 <span
class="math inline">\(F\)</span> 的向量，那么例如对 <span
class="math inline">\(\mathbb{Q}(-1)\)</span>，可以将其看成形如 <span
class="math inline">\((a,b)\)</span> 的二维向量，对应 <span
class="math inline">\(a+bi\)</span>.</p>
<p>此时，<span class="math inline">\(E\)</span> 关于 <span
class="math inline">\(F\)</span> 必有一个维数，记 <span
class="math inline">\([E:F]\)</span> 为 <span
class="math inline">\(E\)</span> 作为 <span
class="math inline">\(F\)</span> 的线性空间关于 <span
class="math inline">\(F\)</span> 的<strong>维数</strong>。</p>
<p>若 <span class="math inline">\([E:F]&lt;\infty\)</span>，称 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span>
的一个<strong>有限扩张</strong>，反之称为<strong>无限扩张</strong>。</p>
<p><strong>维度公式</strong></p>
<p>对扩域的维数，<strong>维度公式</strong>成立：</p>
<ul>
<li><p>（维度公式）若 <span class="math inline">\(K\)</span> 是 <span
class="math inline">\(E\)</span> 的扩域，<span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，则 <span
class="math inline">\([K:F]=[K:E][E:F]\)</span>.</p>
<p>证明：考察 <span class="math inline">\(K\)</span> 关于 <span
class="math inline">\(E\)</span> 的一组基 <span
class="math inline">\(\{e_i\}\)</span>，<span
class="math inline">\(E\)</span> 关于 <span
class="math inline">\(F\)</span> 的一组基 <span
class="math inline">\(\{f_i\}\)</span>，证明 <span
class="math inline">\(\{e_if_j\}\)</span> 是 <span
class="math inline">\(K\)</span> 关于 <span
class="math inline">\(F\)</span> 的一组基即可。</p></li>
</ul>
<p>在这里，我们有时也记 <span class="math inline">\(K/E\)</span> 表示
<span class="math inline">\(K\)</span> 作为 <span
class="math inline">\(E\)</span> 的线性空间。注意，很显然 <span
class="math inline">\(E\)</span> <strong>不一定是</strong>一个 <span
class="math inline">\(K\)</span>
的理想，<strong>不要与商环混淆</strong>。</p>
<p>对维度公式有推论：</p>
<ul>
<li>若 <span class="math inline">\(F\subseteq E\subseteq K\)</span>，且
<span class="math inline">\([K:F]&lt;+\infty\)</span>，则 <span
class="math inline">\([E:F]\)</span> 与 <span
class="math inline">\([K:E]\)</span> 也 <span
class="math inline">\(&lt;\infty\)</span>. 更多地，若 <span
class="math inline">\([K:F]\)</span> 为素数，则在 <span
class="math inline">\(K\)</span> 与 <span
class="math inline">\(F\)</span> 之间没有其他子域。</li>
</ul>
<p>我们来重新审视单代数扩张。对本原元 <span
class="math inline">\(u\)</span>，它必定适合一个首一多项式 <span
class="math inline">\(g(x)\)</span>，现在我们来证明这个多项式是不可约的。</p>
<p>证明：实际上，设 <span class="math inline">\(g\)</span>
为这个多项式，由假设它是所有适合 <span
class="math inline">\(g(u)=0\)</span>
的多项式中次数最低的。假设它可约，那么设 <span
class="math inline">\(q(x)\)</span> 是它的因式，有 <span
class="math inline">\(\deg q&lt;\deg g\)</span>，于是 <span
class="math inline">\(g(x)=q(x)r(x)\)</span>，故 <span
class="math inline">\(q(u)r(u)=0\)</span>，因为 <span
class="math inline">\(F\)</span> 是域，必有 <span
class="math inline">\(q(u)=0\)</span> 或 <span
class="math inline">\(r(u)=0\)</span>，矛盾。</p>
<p>于是有如下定理：</p>
<ul>
<li><p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，若 <span
class="math inline">\(u\)</span> 是 <span
class="math inline">\(E\)</span> 上元素且是 <span
class="math inline">\(F\)</span> 上代数元，则 <span
class="math inline">\([F(u):F]\)</span> 有限且恰好是 <span
class="math inline">\(\deg g(x)\)</span>，其中 <span
class="math inline">\(g(x)\)</span> 是 <span
class="math inline">\(u\)</span> 的极小多项式。另一方面，若 <span
class="math inline">\([F(u):F]\)</span> 有限，则 <span
class="math inline">\(u\)</span> 必为 <span
class="math inline">\(F\)</span> 上代数元。</p>
<p>证明：只证前半，后半是自然的。对前半，设 <span
class="math inline">\(\deg g(x)=n\)</span>，有 <span
class="math inline">\(1,u,u^2,\cdots,u^{n-1}\)</span> 线性无关且任意
<span class="math inline">\(F(u)\)</span>
中元素可写成它们的线性组合，故而 <span
class="math inline">\([F(u):F]=n\)</span>.</p></li>
<li><p>有限扩张必为代数扩张。</p></li>
<li><p>若 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域且 <span
class="math inline">\([E:F]&lt;+\infty\)</span>，则 <span
class="math inline">\(E=F(u)\)</span> 的充要条件是 <span
class="math inline">\(E\)</span> 与 <span
class="math inline">\(F\)</span> 之间只有有限个中间域。</p>
<p>证明：</p>
<p>(<span class="math inline">\(\Rightarrow\)</span>): 设 <span
class="math inline">\(K\)</span> 是中间域，设 <span
class="math inline">\(u\)</span> 在 <span
class="math inline">\(F\)</span> 中极小多项式为 <span
class="math inline">\(g(x)\)</span>，在 <span
class="math inline">\(K\)</span> 中极小多项式为 <span
class="math inline">\(f(x)\)</span>. 在 <span
class="math inline">\(K[x]\)</span> 中做除法得 <span
class="math inline">\(f(x)=g(x)q(x)+r(x)\)</span>，显然此时有 <span
class="math inline">\(r(u)=0\)</span> 而 <span
class="math inline">\(\deg r&lt;\deg g\)</span> 故 <span
class="math inline">\(r=0\)</span>，故 <span
class="math inline">\(g(x)\mid f(x)\)</span>.</p>
<p>此时若设 <span class="math inline">\(K&#39;\)</span> 为 <span
class="math inline">\(F\)</span> 与 <span
class="math inline">\(g(x)\)</span> 中各项系数生成的子域，显然有 <span
class="math inline">\(K&#39;\subseteq K\)</span>，且 <span
class="math inline">\(u\)</span> 在 <span
class="math inline">\(K&#39;\)</span> 中的极小多项式也是 <span
class="math inline">\(g(x)\)</span>，可以说明 <span
class="math inline">\(K&#39;\)</span> 是使得 <span
class="math inline">\(u\)</span> 在其中极小多项式是 <span
class="math inline">\(g(x)\)</span> 的最小子域。</p>
<p>我们来说明 <span
class="math inline">\(K&#39;=K\)</span>，如此自然有任一个极小多项式是
<span class="math inline">\(g(x)\)</span> 的子域都是 <span
class="math inline">\(K&#39;\)</span>，由于 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(E\)</span>
中的首一因式数目有限，中间域的数目也有限。（请注意，这里得到的 <span
class="math inline">\(g(x)\mid f(x)\)</span> 并不与 <span
class="math inline">\(f(x)\)</span> 不可约矛盾，因为域进行了扩张）</p>
<p>由于 <span class="math inline">\(E=K(u)=K&#39;(u)\)</span>，有 <span
class="math inline">\([E:K&#39;]=[E:K][K:K&#39;]\)</span> 故而 <span
class="math inline">\([K:K&#39;]=1\)</span>，故 <span
class="math inline">\(K=K&#39;\)</span>.</p>
<p>(<span class="math inline">\(\Leftarrow\)</span>): 若 <span
class="math inline">\(F\)</span> 是有限域，则 <span
class="math inline">\(E\)</span> 也是有限域。于是 <span
class="math inline">\(E^*\)</span> 是一个乘法循环群，设 <span
class="math inline">\(E\)</span> 的生成元为 <span
class="math inline">\(u\)</span>，显然有 <span
class="math inline">\(E=F(u)\)</span>；</p>
<p>若 <span class="math inline">\(F\)</span> 是无限域，我们来证明 <span
class="math inline">\(F(u,v)\)</span> 一定有本原元，其中 <span
class="math inline">\(u,v\)</span> 是任意两个 <span
class="math inline">\(E\)</span> 中元素。此时考察 <span
class="math inline">\(F(u+av)\)</span>，其中 <span
class="math inline">\(a\in F\)</span>.</p>
<p>因为 <span class="math inline">\(E\)</span> 与 <span
class="math inline">\(F\)</span> 间中间域只有有限个，故定存在 <span
class="math inline">\(a,b\)</span> 使得 <span
class="math inline">\(F(u+av)=F(u+bv)\)</span>.</p>
<p>此时有 <span class="math inline">\(u+av-av=u\in F(u+av)\)</span>,
<span class="math inline">\(v=(a-b)^{-1}(u+av-u-bv)\in
F(u+av)\)</span>，于是 <span
class="math inline">\(F(u+av)=F(u,v)\)</span>.</p>
<p>于是 <span class="math inline">\(E\)</span> 一定可写成 <span
class="math inline">\(F(u)\)</span> 的形式。</p></li>
</ul>
<hr />
<h3 id="代数扩域">4.2 代数扩域</h3>
<h4 id="代数元组成的域">代数元组成的域</h4>
<p><strong>定义</strong></p>
<ul>
<li><p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，<span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(E\)</span> 上所有 <span
class="math inline">\(F\)</span> 中的代数元全体组成的集合，则 <span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(E\)</span> 的子域。</p>
<p>证明：只需证明关于加法、乘法、逆封闭。利用维度说明并非无限扩张即可。</p></li>
</ul>
<p>于是有自然推论：</p>
<ul>
<li>两个代数数的和、差、积、商都是代数数。</li>
</ul>
<h4 id="代数扩域-1">代数扩域</h4>
<p><strong>性质</strong></p>
<p>虽然单代数扩域一定不是无限扩张，但代数扩域可以是无限扩张，例如 $$
代数数集合 的扩域，它是一个无限维的扩张.</p>
<p>那有限扩张是不是代数扩张呢？事实上我们在上一节已经研究过了。不过来看下面的定理：</p>
<ul>
<li><p>若 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，则如下两条等价：</p>
<ul>
<li><span class="math inline">\([E:F]&lt;\infty\)</span>；</li>
<li>存在有限个代数元 <span
class="math inline">\(u_1,\cdots,u_n\)</span>，使得 <span
class="math inline">\(E=F(u_1,\cdots,u_n)\)</span>，此时 <span
class="math inline">\(E\)</span> 必然是 <span
class="math inline">\(F\)</span> 的代数扩域。</li>
</ul>
<p>证明：从第一条至第二条，直接取基即可；从第二条至第一条，考虑维度公式即可。</p></li>
</ul>
<p>代数扩张具有<strong>传递性</strong>：</p>
<ul>
<li><p>若 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的代数扩张，<span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(E\)</span> 的代数扩张，则 <span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(F\)</span> 的代数扩张。</p>
<p>证明：只需证明 <span class="math inline">\(K\)</span> 上任意元素也是
<span class="math inline">\(F\)</span>
上代数元。证明是容易的，从略。</p></li>
</ul>
<p>于是有推论：</p>
<ul>
<li>若 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，<span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(E\)</span> 中 <span
class="math inline">\(F\)</span> 的全体代数元构成的子域，则任意 <span
class="math inline">\(E\)</span> 中 <span
class="math inline">\(K\)</span> 上的代数元仍属于 <span
class="math inline">\(K\)</span>。</li>
</ul>
<p><strong>代数闭包</strong></p>
<p>若 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，<span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(E\)</span> 的子域同时是 <span
class="math inline">\(F\)</span> 的扩域，若 <span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(F\)</span> 的代数扩域且任何 <span
class="math inline">\(K\)</span> 在 <span
class="math inline">\(E\)</span> 中的代数扩张均与 <span
class="math inline">\(K\)</span> 重合，即 <span
class="math inline">\(K\)</span> 在 <span
class="math inline">\(E\)</span> 中无真代数扩张，则称 <span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(F\)</span> 在 <span
class="math inline">\(E\)</span> 中的<strong>代数闭包</strong>。称 <span
class="math inline">\(K\)</span> 在 <span
class="math inline">\(E\)</span> 中<strong>代数封闭</strong>。</p>
<p>可以看出，代数元组成的域就是 <span class="math inline">\(F\)</span>
在 <span class="math inline">\(E\)</span>
中的代数闭包。注意到这里定义的代数闭包是一个<strong>相对</strong>的概念，即，一定是关于
<span class="math inline">\(E\)</span> 的代数闭包。</p>
<p><strong>代数闭域</strong></p>
<p>设 <span class="math inline">\(K\)</span> 是一个域，若 <span
class="math inline">\(K\)</span> 无真代数扩张，则称 <span
class="math inline">\(K\)</span> 是一个<strong>代数闭域</strong>。</p>
<p>设 <span class="math inline">\(K\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，若 <span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(F\)</span> 的代数扩域且 <span
class="math inline">\(K\)</span> 是一个代数闭域，则称 <span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(F\)</span> 的代数闭包。</p>
<p>这里对代数闭包的定义<strong>无相对性</strong>。</p>
<p>关于代数闭域有如下结论：</p>
<ul>
<li><p>设 <span class="math inline">\(K\)</span>
是一个域，则下列命题等价：</p>
<ul>
<li><span class="math inline">\(K\)</span> 是代数闭域；</li>
<li><span class="math inline">\(K[x]\)</span> 中任何不可约多项式次数为
<span class="math inline">\(1\)</span>；</li>
<li><span class="math inline">\(K[x]\)</span>
中任意大于零次的多项式可以被分解为一次因子的乘积；</li>
<li><span class="math inline">\(K[x]\)</span> 中任意大于零次的多项式都在
<span class="math inline">\(K\)</span> 中至少有一个根</li>
</ul>
<p>证明：第三四条与第二条的等价性是显然的，现在我们考虑第一二条的等价性。</p>
<p><span class="math inline">\((1)\to(2)\)</span>: 设 <span
class="math inline">\(g(x)\)</span> 是一个不可约多项式，则 <span
class="math inline">\(g(x)\)</span> 决定了一个 <span
class="math inline">\(K\)</span> 的代数扩域 <span
class="math inline">\(E\)</span>，其中 <span
class="math inline">\([E:K]=\deg g\)</span>，由于 <span
class="math inline">\(K\)</span> 无真代数扩张故 <span
class="math inline">\(\deg g = 1\)</span>；</p>
<p><span class="math inline">\((2)\to (1)\)</span>:
由于极小多项式一定是不可约多项式，因此任意 <span
class="math inline">\(K\)</span> 的代数扩张都是 <span
class="math inline">\(K\)</span> 自身。</p></li>
</ul>
<p>容易看出 <span class="math inline">\(\mathbb{C}\)</span>
是一个代数闭域。</p>
<ul>
<li><p>若 <span class="math inline">\(K\)</span> 是代数闭域，<span
class="math inline">\(F\)</span> 是 <span
class="math inline">\(K\)</span> 的子域，则 <span
class="math inline">\(F\)</span> 在 <span
class="math inline">\(K\)</span> 中的代数闭包 <span
class="math inline">\(\bar F\)</span> 一定也是代数闭域。</p>
<p>证明：考虑 <span class="math inline">\(\bar F\)</span> 在 <span
class="math inline">\(K\)</span> 中的代数元，它们一定都属于 <span
class="math inline">\(\bar F\)</span>. 考察 <span
class="math inline">\(\bar F[x]\)</span> 上多项式 <span
class="math inline">\(f(x)\)</span>，它在 <span
class="math inline">\(K\)</span> 中一定有根，这个根一定是 <span
class="math inline">\(\bar F\)</span> 的代数元，因此在 <span
class="math inline">\(\bar F\)</span> 中，因此 <span
class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(\bar
F\)</span> 中有根，因此 <span class="math inline">\(\bar F\)</span>
是代数闭域。</p></li>
</ul>
<p>最后我们考察代数闭包的存在性与唯一性，有如下命题：</p>
<ul>
<li>任何一个域都存在一个代数闭域作为其扩域，从而代数闭包一定存在；</li>
<li>任何一个域的代数闭包在同构意义下唯一，且对 <span
class="math inline">\(E\)</span> 的两个代数闭包 <span
class="math inline">\(F_1\)</span> 与 <span
class="math inline">\(F_2\)</span>，同构映射 <span
class="math inline">\(\varphi\)</span> 一定满足 <span
class="math inline">\(\varphi(a)=a,\forall a\in E\)</span>.</li>
</ul>
<h4 id="作业题结论-1">作业题结论</h4>
<ul>
<li><p>相对于 <span class="math inline">\(E\)</span>
的代数闭包不一定是代数闭域。</p>
<p>例如令 <span
class="math inline">\(E=\mathbb{R},F=\mathbb{Q}\)</span>，则 <span
class="math inline">\(F\)</span> 关于 <span
class="math inline">\(E\)</span>
的代数闭包就是实代数数全体，这不是代数闭域。</p></li>
<li><p>代数闭域一定为无限域。</p>
<p>证明：否则，则存在多项式 <span
class="math inline">\(x^{q}-x-1\)</span>，其中 <span
class="math inline">\(q\)</span> 为域大小，使得其在域中无根。</p></li>
<li><p><span class="math inline">\(\mathbb{R}\)</span> 的有限扩域关于
<span class="math inline">\(\mathbb{R}\)</span> 的维数一定为 <span
class="math inline">\(2\)</span>.</p>
<p>证明：由于 <span class="math inline">\(\mathbb{C}\)</span> 是 <span
class="math inline">\(\mathbb{R}\)</span>
代数闭包，有限扩域一定是代数扩域，立得。</p></li>
</ul>
<hr />
<h3 id="分裂域">4.4 分裂域</h3>
<p>在先前我们研究了极小多项式 <span class="math inline">\(g(x)\)</span>
决定的扩域（单代数扩域），我们将在本节中研究某个多项式 <span
class="math inline">\(f(x)\)</span> 决定的扩域。</p>
<p>首先有结论：</p>
<ul>
<li><p>若 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(F\)</span> 中不可约，则一定存在 <span
class="math inline">\(F\)</span> 的扩域 <span
class="math inline">\(E\)</span> 使得 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(E\)</span> 中至少有一个根。</p>
<p>证明：考察 <span class="math inline">\(F[x]/(f(x))\)</span>，因为
<span class="math inline">\(f(x)\)</span> 不可约，它一定为一个域。记
<span class="math inline">\(E=F[x]/(f(x))\)</span>.</p>
<p>考虑嵌入映射 <span class="math inline">\(\varphi:a\to \bar
a\)</span>，因为 <span class="math inline">\(\varphi\)</span>
一定不是零同态，否则有 <span
class="math inline">\((f(x))=F[x]\)</span>，<span
class="math inline">\(f(x)\)</span> 一定是常值多项式。因此，<span
class="math inline">\(\varphi\)</span> 是单同态从而是嵌入。 于是 <span
class="math inline">\(F\)</span> 是 <span
class="math inline">\(E\)</span> 的子域。</p>
<p>显然 <span class="math inline">\(\bar x\)</span> 是 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(E\)</span> 中的根。</p></li>
</ul>
<p>可以做如下推论：</p>
<ul>
<li>对任意 <span class="math inline">\(\deg f&gt;0\)</span> 和域 <span
class="math inline">\(F\)</span>，总能找到域 <span
class="math inline">\(E\)</span> 使得 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(E\)</span> 中有根且 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域。</li>
</ul>
<h4 id="分裂域-1">分裂域</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(f(x)\)</span> 是域 <span
class="math inline">\(F\)</span> 上的首一多项式，<span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，满足：</p>
<ul>
<li><span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(E[x]\)</span> 中可以被分解为一次因子的乘积，即存在
<span class="math inline">\(r_1,r_2,\cdots,r_n\in E\)</span>，使得 <span
class="math inline">\(f(x)=(x-r_1)(x-r_2)\cdots(x-r_n)\)</span>；</li>
<li><span class="math inline">\(E=F(r_1,r_2,\cdots,r_n)\)</span>.</li>
</ul>
<p>此时称 <span class="math inline">\(E\)</span> 为 <span
class="math inline">\(F\)</span> 关于多项式 <span
class="math inline">\(f(x)\)</span> 的<strong>分裂域</strong>。</p>
<p>事实上，<span class="math inline">\(E\)</span> 就是使得 <span
class="math inline">\(f(x)\)</span>
可以被分解为一次因子之积的最小扩域。</p>
<p><strong>存在性</strong></p>
<p>对任意 <span class="math inline">\(f(x)\)</span> 与 <span
class="math inline">\(F\)</span>，分裂域 <span
class="math inline">\(E\)</span> 必然存在。</p>
<p>证明：利用归纳。由于 <span class="math inline">\(F[x]\)</span> 是
UFD，我们唯一分解 <span class="math inline">\(f\)</span>.</p>
<p>将 <span class="math inline">\(f(x)\)</span> 展开为 <span
class="math inline">\(\prod f_i(x)\)</span> 的形式，设后者的数量为 <span
class="math inline">\(k\)</span>，<span class="math inline">\(\deg
f=n\)</span>，现在对 <span class="math inline">\(n-k\)</span> 归纳：</p>
<p>若 <span class="math inline">\(n-k=0\)</span>，则 <span
class="math inline">\(f(x)\)</span>
已经被写成了一次因子的乘积，此时分裂域就是 <span
class="math inline">\(F\)</span>；</p>
<p>否则，此时至少有一个 <span class="math inline">\(f_i(x)\)</span>
是次数大于 <span class="math inline">\(1\)</span> 的不可约多项式，考虑
<span class="math inline">\(F\)</span> 的扩域 <span
class="math inline">\(K\)</span>，有该多项式在 <span
class="math inline">\(K\)</span> 中有根。</p>
<p>此时，设根为 <span class="math inline">\(r\)</span>，则 <span
class="math inline">\(f_i(x)=(x-r)h(x)\)</span>。在 <span
class="math inline">\(K\)</span> 中对 <span
class="math inline">\(f(x)\)</span> 做不可约分解，设因子数量为 <span
class="math inline">\(l\)</span>，则 <span class="math inline">\(l\geq
k+1\)</span>，故 <span
class="math inline">\(n-l&lt;n-k\)</span>，可以用归纳条件继续归纳，最终总能将
<span class="math inline">\(f\)</span> 拆分为一次因子形式。</p>
<p>于是，我们只需要证明这样归纳出的域有 <span
class="math inline">\(E=F(r_1,r_2,\cdots,r_n)\)</span>.</p>
<p>我们同样归纳进行证明。考虑对 <span class="math inline">\(n-k&lt;
n-l\)</span> 均成立，对 <span class="math inline">\(n-l\)</span>，有
<span class="math inline">\(E=K(r_1,r_2,\cdots,r_n)\)</span>，又知道
<span class="math inline">\(K=F(r)\)</span>，额外有 <span
class="math inline">\(r=r_i\)</span>，故 <span
class="math inline">\(E=K(r_1,r_2,\cdots,r_n)=E(r_i)(r_1,\cdots,r_n)=E(r_1,\cdots,r_n)\)</span>.</p>
<p><strong>唯一性</strong></p>
<p>分裂域在同构的意义下是唯一的。</p>
<p>为了证明这个命题，我们引入如下引理：</p>
<ul>
<li><p>若 <span class="math inline">\(\eta\)</span> 是 <span
class="math inline">\(F\)</span> 到 <span class="math inline">\(\bar
F\)</span> 的同构，则其被唯一扩张成 <span
class="math inline">\(F[x]\)</span> 到 <span class="math inline">\(\bar
F[x]\)</span> 上的同构 <span class="math inline">\(\tilde{\eta}\)</span>
且满足： <span class="math inline">\(\tilde{\eta}(a)=\eta(a)\)</span>,
<span class="math inline">\(\tilde{\eta}(x)=x\)</span>.</p>
<p>证明：存在性显然；唯一性由 <span class="math inline">\(F[x]\)</span>
由 <span class="math inline">\(F\)</span> 和 <span
class="math inline">\(x\)</span> 生成亦显然。</p></li>
<li><p>接上述命题，若 <span class="math inline">\(g(x)\)</span>
是多项式且记 <span class="math inline">\(\bar
g(x)=\tilde\eta(g(x))\)</span>，则存在 <span
class="math inline">\(F[x]/(g(x))\to\bar F[x]/(\bar g(x))\)</span>
的同构 <span class="math inline">\(\bar \eta\)</span>，且 <span
class="math inline">\(\bar \eta\)</span> 可看作 <span
class="math inline">\(\eta\)</span> 的扩张。</p>
<p>证明：类似上面，是容易的。</p></li>
<li><p>设 <span class="math inline">\(\eta\)</span> 是 <span
class="math inline">\(F\)</span> 至 <span class="math inline">\(\bar
F\)</span> 的同构，<span class="math inline">\(E\)</span> 与 <span
class="math inline">\(\bar E\)</span> 分别是 <span
class="math inline">\(F\)</span> 与 <span class="math inline">\(\bar
F\)</span> 的扩域，设 <span class="math inline">\(u\in E\)</span> 是
<span class="math inline">\(F\)</span> 上代数元且极小多项式为 <span
class="math inline">\(g(x)\)</span>，则 <span
class="math inline">\(\eta\)</span> 可被扩张为 <span
class="math inline">\(F(u)\)</span> 至 <span class="math inline">\(\bar
E\)</span> 中的单同态的充要条件为 <span class="math inline">\(\bar
g(x)\)</span> 在 <span class="math inline">\(\bar E\)</span>
中有一个根，且这种扩张的个数等于 <span class="math inline">\(\bar
g\)</span> 在 <span class="math inline">\(\bar E\)</span>
中不同根的个数。</p>
<p>证明：必要性是显然的。</p>
<p>来看充分性。考虑 <span class="math inline">\(\bar E\)</span> 中的根
<span class="math inline">\(\bar u\)</span>，考虑域 <span
class="math inline">\(\bar F[x]/(\bar g(x))\)</span>，有域同构 <span
class="math inline">\(\bar F(\bar u)\cong \bar F[x]/(\bar
g(x))\)</span>，从而利用上面的两个引理就能构造出扩张。</p>
<p>另外，显然每个 <span class="math inline">\(\bar E\)</span> 中不同的根
<span class="math inline">\(\bar u\)</span>
可以诱导出唯一的扩张，所以不同的扩张数等于 <span
class="math inline">\(\bar g\)</span> 在 <span
class="math inline">\(\bar E\)</span> 中的根数。</p></li>
</ul>
<p>从而就有如下重要定理：</p>
<ul>
<li><p>若 <span class="math inline">\(\eta\)</span> 是 <span
class="math inline">\(F\)</span> 到 <span class="math inline">\(\bar
F\)</span> 的域同构，<span class="math inline">\(f(x)\)</span> 是 <span
class="math inline">\(F[x]\)</span> 中首一多项式，<span
class="math inline">\(\bar f\)</span> 是 <span
class="math inline">\(\bar F[x]\)</span> 中对应多项式，<span
class="math inline">\(E\)</span> 和 <span class="math inline">\(\bar
E\)</span> 分别是对应的分裂域，则 <span
class="math inline">\(\eta\)</span> 可以被扩张为 <span
class="math inline">\(E\)</span> 至 <span class="math inline">\(\bar
E\)</span> 的域同构，且这种扩张的数目不超过 <span
class="math inline">\([E:F]\)</span>. 当 <span
class="math inline">\(\bar f(x)\)</span> 在 <span
class="math inline">\(\bar E\)</span> 中无重根时，正好等于 <span
class="math inline">\([E:F]\)</span>.</p>
<p>证明：对维数用归纳法。若 <span
class="math inline">\([E:F]=1\)</span>，有 <span
class="math inline">\(\bar E=\bar F\)</span>，<span
class="math inline">\(E=F\)</span>，于是扩张肯定唯一。</p>
<p>若 <span class="math inline">\([E:F]&gt;1\)</span>，任取 <span
class="math inline">\(f(x)\)</span> 的一不可约因子 <span
class="math inline">\(g(x)\)</span>，有 <span class="math inline">\(\bar
g(x)\)</span> 也是 <span class="math inline">\(\bar f(x)\)</span>
的不可约因子。考察 <span class="math inline">\(g\)</span> 的任一根 <span
class="math inline">\(u\)</span>，设 <span
class="math inline">\(K=F(u)\)</span>，有 <span
class="math inline">\([K:F]=\deg g\)</span>，于是由上面定理存在 <span
class="math inline">\(k\)</span> 个从 <span
class="math inline">\(K\)</span> 到 <span class="math inline">\(\bar
E\)</span> 中的单同态，其中 <span class="math inline">\(k\)</span> 为
<span class="math inline">\(\bar g\)</span> 在 <span
class="math inline">\(\bar E\)</span> 中根的数目，此时当且仅当 <span
class="math inline">\(g\)</span> 全是单根有 <span
class="math inline">\(k=\deg g\)</span>.</p>
<p>此时 <span class="math inline">\(E\)</span> 可以看成是 <span
class="math inline">\(K\)</span> 关于 <span
class="math inline">\(f\)</span> 的分裂域，因此可以应用归纳假设。于是有
<span class="math inline">\(E\)</span> 至 <span
class="math inline">\(\bar E\)</span> 中的域同构个数不超过 <span
class="math inline">\(\deg
g[E:K]=[E:K][K:F]=[E:F]\)</span>，结论成立。</p></li>
</ul>
<p>将其简单推广就有：</p>
<ul>
<li><span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 关于 <span
class="math inline">\(f(x)\)</span> 的分裂域，则 <span
class="math inline">\(E/F\)</span> 的自同构个数不超过 <span
class="math inline">\([E:F]\)</span>，且当 <span
class="math inline">\(f\)</span> 无重根时恰好等于 <span
class="math inline">\([E:F]\)</span>.</li>
</ul>
<hr />
<h3 id="可分扩域">4.5 可分扩域</h3>
<h4 id="预备知识">预备知识</h4>
<p>对 <span class="math inline">\(F\)</span> 关于 <span
class="math inline">\(f(x)\)</span> 的分裂域 <span
class="math inline">\(E\)</span>，若 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(E\)</span> 中有重根，<span
class="math inline">\(E/F\)</span> 的自同构个数是否仍可能是 <span
class="math inline">\([E:F]\)</span> 呢？本节我们来探讨这个问题。</p>
<p>考察 <span class="math inline">\(f(x)\)</span> 若有两个分裂域 <span
class="math inline">\(E\)</span> 与 <span class="math inline">\(\bar
E\)</span>，若 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\(E[x]\)</span> 中被分解为 <span
class="math inline">\((x-r_1)^{k_1}(x-r_2)^{k_2}\cdots(x-r_m)^{k_m}\)</span>，那么自然有从
<span class="math inline">\(E\)</span> 至 <span
class="math inline">\(\bar E\)</span> 的同构 <span
class="math inline">\(\xi\)</span>，使得 <span
class="math inline">\(f\)</span> 在 <span class="math inline">\(\bar
E[x]\)</span> 中被分解为 <span
class="math inline">\(\prod_i(x-\xi(r_i))^{k_i}\)</span>.</p>
<p>若 <span class="math inline">\(r_i\)</span> 项次数为 <span
class="math inline">\(k_i\)</span>，我们就称它为 <span
class="math inline">\(f\)</span> 的 <span
class="math inline">\(k_i\)</span> 重根。</p>
<p>注意到若设 <span
class="math inline">\(f(x)=f_1^{l_1}(x)f_2^{l_2}(x)\cdots
f_k^{l_k}(x)\)</span> 是 <span class="math inline">\(f\)</span>
的一个不可约分解，且当 <span class="math inline">\(i\neq
j\)</span>，<span class="math inline">\(f_i(x)\)</span> 与 <span
class="math inline">\(f_j(x)\)</span> 互素，则令 <span
class="math inline">\(f_0(x)=f_1(x)f_2(x)\cdots f_k(x)\)</span>，显然
<span class="math inline">\(f(x)\)</span> 与 <span
class="math inline">\(f_0(x)\)</span> 有相同的分裂域。</p>
<p>不仅如此，考察 <span class="math inline">\(i\neq j\)</span>，一定存在
<span class="math inline">\(s(x)\)</span> 和 <span
class="math inline">\(t(x)\)</span> 使得 <span
class="math inline">\(f_i(x)s(x)+f_j(x)t(x)=1\)</span>（PID，裴蜀定理）
，于是显然有 <span class="math inline">\(f_i(x)\)</span> 与 <span
class="math inline">\(f_j(x)\)</span> 无公共根。</p>
<p>于是，若 <span class="math inline">\(f(x)\)</span>
的不可约因子无重根，一定有 <span class="math inline">\(E/F\)</span>
的自同构个数就是 <span class="math inline">\([E:F]\)</span>.</p>
<h4 id="可分多项式可分元可分扩域">可分多项式·可分元·可分扩域</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(f(x)\)</span> 是 <span
class="math inline">\(F[x]\)</span> 中多项式，若 <span
class="math inline">\(f(x)\)</span> 的每个不可约多项式因子在 <span
class="math inline">\(F\)</span> 的分裂域 <span
class="math inline">\(E\)</span> 中无重根，则称 <span
class="math inline">\(f(x)\)</span>
是一个<strong>可分多项式</strong>。</p>
<p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 扩域，若 <span
class="math inline">\(u\in E\)</span> 且 <span
class="math inline">\(u\)</span> 在 <span
class="math inline">\(F\)</span> 中的的极小多项式是可分多项式，则称
<span class="math inline">\(u\)</span> 是 <span
class="math inline">\(F\)</span> 上的一个<strong>可分元</strong>。</p>
<p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的代数扩域，若 <span
class="math inline">\(E\)</span> 中每个元都是 <span
class="math inline">\(F\)</span> 上的可分元，则称 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span>
的一个<strong>可分扩张</strong>或<strong>可分扩域</strong>。</p>
<p>注意，可分元并不依赖于扩域 <span class="math inline">\(E\)</span>
的选择，它只依赖于 <span class="math inline">\(F\)</span>
与极小多项式。</p>
<p><strong>一些性质</strong></p>
<ul>
<li>设 <span class="math inline">\(f(x)\)</span> 是域 <span
class="math inline">\(F\)</span> 上的多项式，若 <span
class="math inline">\(f(x)\)</span> 可分，<span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(f(x)\)</span> 的分裂域，则 <span
class="math inline">\(E/F\)</span> 的自同构数等于 <span
class="math inline">\([E:F]\)</span>.</li>
</ul>
<p>回顾：导数与多项式无重根的判别条件。</p>
<ul>
<li><p>设 <span
class="math inline">\(f(x)=a_0+a_1x+\cdots+a_nx^n\)</span>，则 <span
class="math inline">\(f&#39;(x)=a_1+2a_2x+\cdots+na_nx^{n-1}\)</span>
称为其<strong>导数</strong>，显然满足如下性质：</p>
<ul>
<li><span class="math inline">\((f+g)&#39;=f&#39;+g&#39;\)</span></li>
<li><span class="math inline">\((af)&#39;=af&#39;\)</span></li>
<li><span class="math inline">\((fg)&#39;=f&#39;g+fg&#39;\)</span></li>
</ul>
<p>更多地，若 <span class="math inline">\(F\)</span> 是特征为 <span
class="math inline">\(0\)</span> 的域，则 <span
class="math inline">\(f&#39;(x)=0\Leftrightarrow f(x)=a\in
F\)</span>，然而若特征非 <span class="math inline">\(0\)</span>
则并不等价。对特征为 <span class="math inline">\(p\)</span> 的域，有
<span class="math inline">\((x^p)&#39;=0\)</span>。</p></li>
<li><p>若 <span class="math inline">\((f(x),f&#39;(x))=1\)</span>，则
<span class="math inline">\(f(x)\)</span>
无重根，且该条件是充要条件。</p>
<p>证明在高等线性代数中。</p></li>
</ul>
<p>注意到导数的次数一定低于原多项式，利用不可约多项式的性质，可以进一步推出性质：</p>
<ul>
<li><p>若 <span class="math inline">\(F\)</span> 是特征为 <span
class="math inline">\(0\)</span> 的域，则 <span
class="math inline">\(F[x]\)</span>
上的任一不可约多项式都是可分多项式。</p>
<p>证明：由于 <span class="math inline">\(F\)</span> 特征为 <span
class="math inline">\(0\)</span>，因此任意非常数多项式的导数非 <span
class="math inline">\(0\)</span>，因此有重根将与不可约矛盾。</p></li>
<li><p>若 <span class="math inline">\(F\)</span> 是特征为 <span
class="math inline">\(p\neq 0\)</span> 的域，则 <span
class="math inline">\(F[x]\)</span> 上的不可约多项式 <span
class="math inline">\(g\)</span> 为不可分多项式的充要条件为 <span
class="math inline">\(g&#39;(x)=0\)</span>.</p>
<p>证明：显然；</p></li>
<li><p>若 <span class="math inline">\(F\)</span> 是特征为 <span
class="math inline">\(p\neq 0\)</span> 的域，则 <span
class="math inline">\(F[x]\)</span> 上的不可约多项式 <span
class="math inline">\(f(x)\)</span> 为不可分多项式的充要条件为 <span
class="math inline">\(f(x)\)</span> 具有形状：</p>
<p><span
class="math inline">\(f(x)=a_0+a_1x^p+\cdots+a_nx^{np}\)</span>.</p></li>
</ul>
<p><strong>Frobenius 同态</strong></p>
<p>考察特征为 <span class="math inline">\(p\)</span> 的域 <span
class="math inline">\(F\)</span> 上的映射 $:aa^p <span
class="math inline">\(，我们验证其为同态：\)</span>(a+b)=(a+b)<sup>p=a</sup>p+b^p$，这是因为由二项式定理，中间项都被消除。</p>
<p>从而 <span class="math inline">\(\varphi\)</span>
是一个单同态，其同态像记作 <span
class="math inline">\(F^p\)</span>，这是一个 <span
class="math inline">\(F\)</span> 的子域，这个同态被称为
<strong>Frobenius 同态</strong>。</p>
<p>利用它可以证明这样的引理：</p>
<ul>
<li><p>设 <span class="math inline">\(F\)</span> 是特征 <span
class="math inline">\(p\)</span> 的域，<span class="math inline">\(a\in
F\)</span>，则多项式 <span class="math inline">\(x^p-a\)</span> 要么在
<span class="math inline">\(F\)</span> 上不可约，要么等于 <span
class="math inline">\((x-b)^p\)</span>，其中 <span
class="math inline">\(b\in F\)</span>.</p>
<p>证明：不可约略去，来看可约的情况。此时设 <span
class="math inline">\(E\)</span> 是其分裂域， <span
class="math inline">\(b\)</span> 是分裂域上的一个根，则有 <span
class="math inline">\(a=b^p\)</span>，于是 <span
class="math inline">\(x^p-a=x^p-b^p=(x-b)^p\)</span>. 我们来说明 <span
class="math inline">\(b\)</span> 属于 <span
class="math inline">\(F\)</span>。</p>
<p>不妨设 <span class="math inline">\(f(x)=g(x)h(x)\)</span>，于是 <span
class="math inline">\(g(x)=(x-b)^k\)</span>，即有 <span
class="math inline">\(b^k\in F\)</span>，然而又有 <span
class="math inline">\((k,p)=1\)</span>，故而有整数 <span
class="math inline">\(s,t\)</span> 使得 <span
class="math inline">\(ks+pt=1\)</span>，于是 <span
class="math inline">\(b^1=b\in F\)</span>.</p></li>
</ul>
<p>该引理可以用以证明某些特定形状多项式是不可约的，例如对 <span
class="math inline">\(\mathbb{Z}_p(t)\)</span> 中的多项式 <span
class="math inline">\(f(x)=x^p-t\)</span>.</p>
<p><strong>完全域</strong></p>
<p>若域 <span class="math inline">\(F\)</span>
上的任意多项式都是可分多项式，则称 <span
class="math inline">\(F\)</span> 为<strong>完全域</strong>。</p>
<ul>
<li><p>设 <span class="math inline">\(F\)</span> 为特征为 <span
class="math inline">\(p\)</span> 的域，则 <span
class="math inline">\(F\)</span> 是完全域的充要条件是 <span
class="math inline">\(F^p=F\)</span>.</p>
<p>证明：若 <span class="math inline">\(F^p\neq F\)</span>，那么存在元素
<span class="math inline">\(a\)</span>，使得 <span
class="math inline">\(a\)</span> 不是某个元的 <span
class="math inline">\(p\)</span> 次幂，于是 <span
class="math inline">\(x^p-a\)</span> 不可约，从而不可分；</p>
<p>若 <span class="math inline">\(F\)</span>
不是完全域，则存在不可约多项式，它一定有形状 <span
class="math inline">\(f(x)=a_0+a_1x^p+\cdots+a_nx^{np}\)</span>，此时若每个
<span class="math inline">\(a_i\)</span> 都是 <span
class="math inline">\(F\)</span> 中某个元素的 <span
class="math inline">\(p\)</span> 次幂，则 <span
class="math inline">\(f(x)=(b_0+b_1x+\cdots+b_nx^n)^p\)</span>，这与不可约矛盾，因此一定存在一个
<span class="math inline">\(a_i\)</span> 使得 <span
class="math inline">\(a_i\)</span> 没有 <span
class="math inline">\(p\)</span> 次方根，于是 <span
class="math inline">\(F^p\neq F\)</span>.</p></li>
<li><p>有限域 <span class="math inline">\(F\)</span>
必是完全域。</p></li>
</ul>
<hr />
<h3 id="正规扩域">4.6 正规扩域</h3>
<p>来看分裂域的一个性质：</p>
<ul>
<li><p>若 <span class="math inline">\(f(x)\)</span> 是域 <span
class="math inline">\(F\)</span> 上的多项式，<span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的分裂域。若 <span
class="math inline">\(u\in E\)</span>，其在 <span
class="math inline">\(F\)</span> 上的极小多项式为 <span
class="math inline">\(g(x)\)</span>，则 <span
class="math inline">\(g(x)\)</span> 在 <span
class="math inline">\(E\)</span> 中必分裂，即 <span
class="math inline">\(g(x)\)</span> 一定可以在 <span
class="math inline">\(E\)</span> 中写成一次多项式的乘积。换言之，<span
class="math inline">\(g(x)\)</span> 的根一定在 <span
class="math inline">\(E\)</span> 中。</p>
<p>证明：将 <span class="math inline">\(g(x)\)</span> 看成 <span
class="math inline">\(E\)</span> 上多项式，我们证明 <span
class="math inline">\(E\)</span> 关于这个多项式的分裂域 <span
class="math inline">\(K=E\)</span>.</p>
<p>考虑 <span class="math inline">\(r\in K\)</span> 是 <span
class="math inline">\(g\)</span> 的一个根，我们可以得到同构 <span
class="math inline">\(\sigma\)</span> 使得 <span
class="math inline">\(F(u)\cong F(r)\)</span>，将 <span
class="math inline">\(\sigma\)</span> 限制在 <span
class="math inline">\(F\)</span> 上是恒等映射，将其扩张为 <span
class="math inline">\(F(u)[x]\)</span> 与 <span
class="math inline">\(F(r)[x]\)</span> 的同构，于是有 <span
class="math inline">\(\sigma(f(x))=f(x)\)</span>. 又因为 <span
class="math inline">\(E\)</span> 与 <span
class="math inline">\(E(r)\)</span> 分别是 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(F(u)\)</span> 与 <span
class="math inline">\(F(r)\)</span> 的分裂域，于是可以将 <span
class="math inline">\(\sigma\)</span> 扩张为 <span
class="math inline">\(E\)</span> 至 <span
class="math inline">\(E(r)\)</span> 的同构。</p>
<p>于是 <span
class="math inline">\([E:F]=[E:F(u)][F(u):F]=[E(r):F(r)][F(r):F]=[E(r):F]\)</span>，由于
<span class="math inline">\(E\subseteq E(r)\)</span>，于是 <span
class="math inline">\(E=E(r)\)</span>.</p></li>
</ul>
<p>这个性质可以归结为：</p>
<ul>
<li>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 关于 <span
class="math inline">\(f(x)\)</span> 的分裂域，若 <span
class="math inline">\(F\)</span> 中的不可约多项式 <span
class="math inline">\(g(x)\)</span> 在 <span
class="math inline">\(E\)</span> 中有根，则它所有的根都在 <span
class="math inline">\(E\)</span> 中。</li>
</ul>
<h4 id="正规扩域-1">正规扩域</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的代数扩域，若 <span
class="math inline">\(F\)</span> 上的任意不可约多项式 <span
class="math inline">\(g(x)\)</span> 满足要么在 <span
class="math inline">\(E\)</span> 中无根，要么所有的根都在 <span
class="math inline">\(E\)</span> 中，则称 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span>
的<strong>正规扩域</strong>或<strong>正规扩张</strong>。</p>
<p><strong>性质</strong></p>
<ul>
<li><p>若 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的有限扩张，则 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的正规扩张的充要条件是 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 关于某个多项式的分裂域。</p>
<p>证明：只需证明必要性。事实上，取 <span
class="math inline">\(E\)</span> 视作关于 <span
class="math inline">\(F\)</span>
的线性空间的一组基，再取这组基的极小多项式的乘积 <span
class="math inline">\(g(x)\)</span>，一定有 <span
class="math inline">\(F\)</span> 关于 <span
class="math inline">\(g(x)\)</span> 的分裂域就是 <span
class="math inline">\(E\)</span>.</p></li>
<li><p><span class="math inline">\(F\)</span> 的任一有限扩张 <span
class="math inline">\(E\)</span> 必含于 <span
class="math inline">\(F\)</span> 的某个正规扩张中。</p>
<p>证明：取 <span class="math inline">\(E\)</span> 视作关于 <span
class="math inline">\(F\)</span> 的线性空间的一组基，然后如上面所述取
<span class="math inline">\(g(x)\)</span>，一定有 <span
class="math inline">\(F\)</span> 关于 <span
class="math inline">\(g(x)\)</span> 的分裂域（也是正规扩域）包含 <span
class="math inline">\(E\)</span>.</p></li>
</ul>
<h4 id="正规闭包">正规闭包</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的代数扩域，若 <span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(F\)</span> 的正规扩域且包含 <span
class="math inline">\(E\)</span>，又若 <span
class="math inline">\(E\subseteq M\subseteq K\)</span>，其中 <span
class="math inline">\(M\)</span> 是 <span
class="math inline">\(F\)</span> 的正规扩域，则必有 <span
class="math inline">\(K=M\)</span>，此时就称 <span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(E/F\)</span> 的<strong>正规闭包</strong>。</p>
<p>通俗来说，正规闭包就是包含 <span class="math inline">\(E\)</span>
的最小的 <span class="math inline">\(F\)</span> 的正规扩域。</p>
<p><strong>存在性</strong></p>
<p>根据上面的性质，正规闭包一定存在。</p>
<p><strong>唯一性</strong></p>
<p>同样根据上面的性质，正规闭包在同构意义下是唯一的。</p>
<h4 id="正规扩张的性质">正规扩张的性质</h4>
<p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的有限维正规扩张，<span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(E\)</span> 与 <span
class="math inline">\(F\)</span> 的中间域，那么以下等价：</p>
<ul>
<li><span class="math inline">\(K\)</span> 是 <span
class="math inline">\(F\)</span> 的正规扩域；</li>
<li>若 <span class="math inline">\(\sigma\)</span> 是 <span
class="math inline">\(E/F\)</span> 的自同构，即 <span
class="math inline">\(E\)</span> 的保持 <span
class="math inline">\(F\)</span> 中元素不动的自同构，则 <span
class="math inline">\(\sigma(K)\subseteq K\)</span>；</li>
<li>若 <span class="math inline">\(\sigma\)</span> 是 <span
class="math inline">\(E/F\)</span> 的自同构，则 <span
class="math inline">\(\sigma(K)=K\)</span>.</li>
</ul>
<p>证明：(<span class="math inline">\(1\to2\)</span>)：若 <span
class="math inline">\(u\in K\)</span>，设 <span
class="math inline">\(u\)</span> 在 <span
class="math inline">\(F\)</span> 上的极小多项式为 <span
class="math inline">\(g(x)\)</span>，则由于 <span
class="math inline">\(g(\sigma(u))=\sigma(g(u))\)</span>，且 <span
class="math inline">\(g(u)=0\)</span>，于是 <span
class="math inline">\(\sigma(u)\)</span> 是 <span
class="math inline">\(g(x)\)</span> 的根，因此在 <span
class="math inline">\(K\)</span> 中。</p>
<p>(<span class="math inline">\(2\to 3\)</span>)：因为 <span
class="math inline">\([K:F]=[\sigma(K):\sigma(F)]=[\sigma(K):F]\)</span>，而
<span class="math inline">\(\sigma(K)\subseteq K\)</span>，因此 <span
class="math inline">\(\sigma(K)=K\)</span>.</p>
<p>(<span class="math inline">\(3\to 1\)</span>)：设 <span
class="math inline">\(u\in K\)</span>，<span
class="math inline">\(u\)</span> 在 <span
class="math inline">\(F\)</span> 上的极小多项式为 <span
class="math inline">\(g(x)\)</span>，需要证明其所有根都在 <span
class="math inline">\(K\)</span> 中。我们想要利用 3
的性质，于是考虑构造一个 <span class="math inline">\(E/F\)</span>
的自同构，像这样构造：考虑 <span class="math inline">\(g(x)\)</span>
的另一根 <span class="math inline">\(r\)</span>，考察 <span
class="math inline">\(F(u)\)</span> 与 <span
class="math inline">\(F(r)\)</span>，它们间存在同构 <span
class="math inline">\(\varphi\)</span> 使得 <span
class="math inline">\(\varphi(F)=F\)</span> 且 <span
class="math inline">\(\varphi(u)=r\)</span>；接着考虑若 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 关于 <span
class="math inline">\(f(x)\)</span> 的分裂域，则 <span
class="math inline">\(E\)</span> 也必然是 <span
class="math inline">\(F(u)\)</span> 与 <span
class="math inline">\(F(r)\)</span> 关于 <span
class="math inline">\(f(x)\)</span> 的分裂域，这是因为 <span
class="math inline">\(r\in E\)</span>；利用分裂域那一节的扩张，可以将
<span class="math inline">\(\varphi\)</span> 扩张为 <span
class="math inline">\(E/F\)</span> 的自同构，故由于 <span
class="math inline">\(\varphi(K)=K\)</span>，有 <span
class="math inline">\(\varphi(u)=r\in K\)</span>.</p>
<p>正规扩域和可分扩域又有怎样的关系呢？我们来看下面的命题：</p>
<ul>
<li><p>若 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 上可分多项式 <span
class="math inline">\(f(x)\)</span> 的分裂域，则 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的可分扩域。</p>
<p>证明：我们来证明 <span class="math inline">\(E\)</span>
中元都是可分元。因为 <span class="math inline">\(E\)</span>
是正规扩域，因此 <span class="math inline">\(E\)</span> 中元 <span
class="math inline">\(u\)</span> 对应的极小多项式 <span
class="math inline">\(g(x)\)</span> 的根都在 <span
class="math inline">\(E\)</span> 中。</p>
<p>设 <span class="math inline">\(\deg
g(x)=m\)</span>，现在命题转换为证明不同根个数为 <span
class="math inline">\(m\)</span>.</p>
<p>不妨设 <span class="math inline">\(g(x)\)</span> 在 <span
class="math inline">\(E\)</span> 中有 <span
class="math inline">\(k\)</span> 个不同根，设 <span
class="math inline">\([E:F]=n\)</span>，由于 <span
class="math inline">\(f(x)\)</span> 是可分多项式，因此 <span
class="math inline">\(E/F\)</span> 的自同构就恰有 <span
class="math inline">\(n\)</span> 个。</p>
<p>另外，<span class="math inline">\([F(u):F]=m\)</span>，我们知道 <span
class="math inline">\(F\to F\)</span> 的恒等同态可扩张为 <span
class="math inline">\(F(u)\to E\)</span> 的单同态的数目恰好为 <span
class="math inline">\(k\)</span>，设它们为 <span
class="math inline">\(\eta_1,\cdots,\eta_k\)</span>.</p>
<p>因为 <span class="math inline">\(E\)</span> 也可以看成是 <span
class="math inline">\(\eta_i(F(u))\)</span> 与 <span
class="math inline">\(F(u)\)</span> 上多项式 <span
class="math inline">\(f(x)\)</span> 的分裂域，于是 <span
class="math inline">\(\eta_i\)</span> 可以扩张为 <span
class="math inline">\(E\)</span> 的自同构，这样的扩张恰有 <span
class="math inline">\([E:F(u)]\)</span> 个.</p>
<p>于是，按这种方法一共恰好构造出 <span class="math inline">\(k
[E:F(u)]\)</span> 个 <span class="math inline">\(E/F\)</span>
的自同构。又因为任何一个 <span class="math inline">\(E/F\)</span>
的自同构限制到 <span class="math inline">\(F(u)\)</span> 上就是 <span
class="math inline">\(F(u)/F\to E/F\)</span> 的单同态，因此一定是某个
<span class="math inline">\(\eta_i\)</span>，因此 <span
class="math inline">\(n=k[E:F(u)]=[E:F(u)][F(u):F]\)</span>，于是 <span
class="math inline">\(k=m\)</span>.</p></li>
</ul>
<hr />
<h3 id="galois-扩域galois-对应">4.7 Galois 扩域·Galois 对应</h3>
<p>本节引理的证明非常冗长，这里不作展示，详情可参考抽代教材 p151.</p>
<h4 id="galois-扩域galois-群">Galois 扩域·Galois 群</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，若 <span
class="math inline">\([E:F]&lt;\infty\)</span>，<span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的可分正规扩域，则称 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的<strong>Galois扩域</strong>。</p>
<p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，则 <span
class="math inline">\(E\)</span> 中所有保持 <span
class="math inline">\(F\)</span>
元素不动的自同构构成一群（关于映射的合成），称为 <span
class="math inline">\(E/F\)</span> 的 <strong>Galois群</strong>，记作
<span class="math inline">\(\text{Gal} E/F\)</span>。</p>
<p>Galois 群中的恒等元就是恒等映射，若 <span
class="math inline">\(F\)</span> 上的一个可分多项式的分裂域为 <span
class="math inline">\(E\)</span>，则 <span
class="math inline">\(|\text{Gal} E/F|=[E:F]\)</span>.</p>
<p>设 <span class="math inline">\(E\)</span> 是一个域，<span
class="math inline">\(\text{Aut} E\)</span> 是它的一个自同构群，又设
<span class="math inline">\(G\)</span> 是 <span
class="math inline">\(\text{Aut} E\)</span> 的子群，令 <span
class="math inline">\(\text{Inv}G=\{a\in E|\eta(a)=a,\forall \eta \in
G\}\)</span>，那么对任意的 <span class="math inline">\(\eta \in
G\)</span> 以及 <span class="math inline">\(a,b\in \text{Inv}
G\)</span>，有 <span
class="math inline">\(\eta(a+b)=\eta(a)+\eta(b)=a+b\)</span>，<span
class="math inline">\(\eta(ab)=\eta(a)\eta(b)=ab\)</span>，<span
class="math inline">\(\eta(1)=1\)</span>，<span
class="math inline">\(\eta(a^{-1})=\eta(a)^{-1}=a^{-1}\)</span>，于是
<span class="math inline">\(\text{Inv} G\)</span> 是 <span
class="math inline">\(E\)</span> 的一个子域，称之为 <span
class="math inline">\(E\)</span> 关于 <span
class="math inline">\(G\)</span> 的<strong>不变子域</strong>。</p>
<p><strong>Artin 引理</strong></p>
<p>设 <span class="math inline">\(G\)</span> 是域 <span
class="math inline">\(E\)</span> 上自同构群的有限子群，<span
class="math inline">\(F=\text{Inv} G\)</span>，则 <span
class="math inline">\([E:F]\leq|G|\)</span>.</p>
<p><strong>性质</strong></p>
<p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，下面三个命题等价：</p>
<ul>
<li><span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的 Galois 扩域；</li>
<li><span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 上某个可分多项式的分裂域；</li>
<li><span class="math inline">\(F=\text{Inv} G\)</span>，其中 <span
class="math inline">\(G\subseteq \text{Aut} E\)</span>
且是有限子群.</li>
</ul>
<p>从上面的命题自然有如下推论：</p>
<ul>
<li><p><span class="math inline">\(\text{Gal} (E/\text{Inv
G})=G\)</span>, <span class="math inline">\(\text{Inv} \text{Gal}
E/F=F\)</span>.</p>
<p>注意这看起来很像一个<strong>对应关系</strong>，这启发了 Galois
对应的定义。</p></li>
</ul>
<p>事实上，还有对任意一个域 <span
class="math inline">\(F\)</span>，其素子域在任何自同构下都是不变的。</p>
<h4 id="galois-对应">Galois 对应</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，<span
class="math inline">\(G=\text{Gal}E/F\)</span>。</p>
<p>令集合 <span class="math inline">\(\Sigma=\{H|H \leq
G\}\)</span>（回忆：这里 <span class="math inline">\(\leq\)</span>
是<strong>子群</strong>）</p>
<p><span class="math inline">\(\Omega=\{K\text{ 为域}|F\subseteq
K\subseteq E\}\)</span>，即所有 <span class="math inline">\(E\)</span>
与 <span class="math inline">\(F\)</span>
的<strong>中间域</strong>构成的集合。</p>
<p>定义 <span class="math inline">\(\Sigma\)</span> 至 <span
class="math inline">\(\Omega\)</span> 的映射 <span
class="math inline">\(\varphi\)</span>：<span class="math inline">\(H\to
\text{Inv} H\)</span>.</p>
<p>定义 <span class="math inline">\(\Omega\)</span> 至 <span
class="math inline">\(\Sigma\)</span> 的映射 <span
class="math inline">\(\psi\)</span>：<span
class="math inline">\(K\to\text{Gal}E/K\)</span>.</p>
<p>显然，<span class="math inline">\(\text{Inv} H\)</span> 一定是 <span
class="math inline">\(E\)</span> 与 <span
class="math inline">\(F\)</span> 的中间域；任意 <span
class="math inline">\(E/K\)</span> 的自同构群中元素也一定是 <span
class="math inline">\(E/F\)</span> 的自同构，因而为 <span
class="math inline">\(G\)</span> 之子群。</p>
<p>我们称 <span class="math inline">\(\varphi,\psi\)</span>
是<strong>Galois 对应</strong>，它的性质会在接下来详细阐述。</p>
<p><strong>简单性质</strong></p>
<ul>
<li><span class="math inline">\(H_1\subseteq H_2\to \text{Inv}
H_2\subseteq \text{Inv} H_1\)</span>；</li>
<li><span class="math inline">\(K_1\subseteq K_2\to \text{Gal}
E/K_2\subseteq \text{Gal} E/K_1\)</span>；</li>
<li><span class="math inline">\(H\subseteq
\text{Gal}(E/\text{Inv}H)\)</span>；</li>
<li><span class="math inline">\(K\subseteq
\text{Inv}(\text{Gal}(E/K))\)</span>.</li>
</ul>
<p><strong>基本定理</strong></p>
<p>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的 Galois 扩域，则以下几条成立：</p>
<ul>
<li><span class="math inline">\(\varphi\)</span> 与 <span
class="math inline">\(\psi\)</span> 是一一对应且是互逆的，即 <span
class="math inline">\(\varphi\psi=\psi\varphi=1\)</span>.</li>
<li><span class="math inline">\(H_1\subseteq H_2\Leftrightarrow
\text{Inv} H_2\subseteq \text{Inv} H_1\)</span>.</li>
<li><span class="math inline">\(|H|=[E:\text{Inv}H], [G:H]=[\text{Inv}
H:F]\)</span>.</li>
<li><span class="math inline">\(H\vartriangleleft
G\Leftrightarrow\)</span> <span class="math inline">\(\text{Inv}
H\)</span> 是 <span class="math inline">\(F\)</span>
的正规扩域。此时还有 <span class="math inline">\(\text{Gal}(\text{Inv}
H/F)\cong G/H\)</span>.</li>
</ul>
<hr />
<h3 id="有限域">4.8 有限域</h3>
<p>有限域又称 Galois 域（注意不是 Galois
<strong>扩域</strong>），本节我们来看一些它的性质。</p>
<h4 id="有限域-1">有限域</h4>
<ul>
<li><p>任意特征为 <span class="math inline">\(p\)</span>
的有限域的元素个数可以写成为 <span
class="math inline">\(p^k\)</span>；同时，对任意自然数 <span
class="math inline">\(n\)</span> 总有大小为 <span
class="math inline">\(p^n\)</span> 的有限域，其特征为 <span
class="math inline">\(p\)</span>。不仅如此，元素个数相同的有限域在同构意义下唯一。</p>
<p>证明：任意特征为 <span class="math inline">\(p\)</span> 的域有素域
<span class="math inline">\(\mathbb{Z}_p\)</span>
作为子域，故元素个数一定可以写成 <span
class="math inline">\(p^{[F:\mathbb{Z}_p]}\)</span> 形式 。</p>
<p>反过来，记 <span class="math inline">\(q=p^n\)</span>，考虑多项式
<span class="math inline">\(f(x)=x^q-x\)</span>，<span
class="math inline">\(\mathbb{Z}_p\)</span> 关于它的分裂域记作 <span
class="math inline">\(F\)</span>. 因为 <span
class="math inline">\(f&#39;(x)=-1\)</span>，因此 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(F\)</span> 中无重根，且 <span
class="math inline">\(f(x)\)</span> 的根全在 <span
class="math inline">\(F\)</span> 中（正规扩域）。</p>
<p>由于 <span class="math inline">\(\deg f=p^n\)</span>，有 <span
class="math inline">\(f\)</span> 的 <span
class="math inline">\(p^n\)</span> 个根都在 <span
class="math inline">\(F\)</span> 中。设这 <span
class="math inline">\(p^n\)</span> 个根构成的集合为 <span
class="math inline">\(K\)</span>，设 <span
class="math inline">\(\varphi\)</span> 为 <span
class="math inline">\(F\)</span> 上的 Frobenius 映射，则有 <span
class="math inline">\(\varphi^{n}(k)=k,\forall k\in
K\)</span>，这里的次幂表示映射的复合。另一方面，若 <span
class="math inline">\(\varphi^n(a)=a\)</span>，则 <span
class="math inline">\(a^{p^n}-a=0\)</span>，则 <span
class="math inline">\(a\in K\)</span>. 由于 <span
class="math inline">\(\varphi^n\)</span> 是 <span
class="math inline">\(F\)</span> 的自同构，且 <span
class="math inline">\(\text{Inv} \varphi^n\)</span> 是一个子域，因而
<span class="math inline">\(K\)</span> 为一个子域。另一方面，<span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(K\)</span> 上分裂，由于 <span
class="math inline">\(F\)</span> 又是分裂域，因此 <span
class="math inline">\(F=K\)</span>.</p>
<p>最后，根据上面的构造，我们知道 <span class="math inline">\(F\)</span>
一定是 <span class="math inline">\(\mathbb{Z}_p\)</span> 对多项式 <span
class="math inline">\(x^q-x\)</span> 的分裂域，因而同构。</p></li>
</ul>
<p>于是有推论：</p>
<ul>
<li><p>若 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域且是有限域，那么 <span
class="math inline">\(E\)</span> 一定是 <span
class="math inline">\(F\)</span> 的 Galois 扩域。</p>
<p>证明：设 <span class="math inline">\(F\)</span> 的素子域为 <span
class="math inline">\(\mathbb{Z}_p\)</span>，我们知道 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(\mathbb{Z}_p\)</span> 上某个多项式的分裂域，于是
<span class="math inline">\(E\)</span> 是 <span
class="math inline">\(\mathbb{Z}_p\)</span> 的有限正规扩域，自然就是
<span class="math inline">\(F\)</span>
的分裂域从而是有限正规扩域。又因为有限域都是完全域，从而 <span
class="math inline">\(E\)</span> 是可分扩域。</p></li>
</ul>
<p>对 Galois 理论在有限域上的情形，有如下定理：</p>
<ul>
<li><p>若 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，<span
class="math inline">\(E,F\)</span> 都有限且 <span
class="math inline">\([E:F]=m\)</span>，则 <span
class="math inline">\(\text{Gal} E/F\)</span> 是一个 <span
class="math inline">\(m\)</span> 阶循环群，其生成元为 <span
class="math inline">\(E\)</span> 的自同构 <span
class="math inline">\(\eta:a\to a^q\)</span>，<span
class="math inline">\(q=|F|\)</span>.</p>
<p>证明：从略。可以参考抽象代数学教材。</p></li>
<li><p>设 <span class="math inline">\(E\)</span> 是元素个数为 <span
class="math inline">\(p^n\)</span> 的域且 <span
class="math inline">\(m\mid n\)</span>，则 <span
class="math inline">\(E\)</span> 有且只有一个元素个数为 <span
class="math inline">\(p^m\)</span> 的子域 <span
class="math inline">\(F\)</span>。</p>
<p>证明：考察 Galois 对应。因为 <span class="math inline">\(F\)</span>
为 <span class="math inline">\(\mathbb{Z}_p\)</span> 与 <span
class="math inline">\(E\)</span> 的中间域，它恰对应于 <span
class="math inline">\(\text{Gal} E/F\)</span>，这是一个 <span
class="math inline">\(m\)</span> 阶循环群，而 <span
class="math inline">\(n\)</span> 阶循环群只有一个 <span
class="math inline">\(m\)</span>
阶循环群作为子群，于是只有一个这样的中间域。</p></li>
</ul>
<hr />
<h3 id="分圆域">4.9 分圆域</h3>
<p>因为我再熬夜就熬死了，最后两节只列出定理和定义，详细的证明明天再来补充。</p>
<h4 id="分圆域-1">分圆域</h4>
<p><strong>定义</strong></p>
<p>设 <span class="math inline">\(F\)</span> 为一个特征为 <span
class="math inline">\(0\)</span> 的域，称 <span
class="math inline">\(F\)</span> 关于 <span
class="math inline">\(x^n-1\)</span> 的分裂域为 <span
class="math inline">\(F\)</span> 的 <span
class="math inline">\(n\)</span> 阶<strong>分圆域</strong>。</p>
<p>特别地，<span class="math inline">\(x^n-1\)</span> 在其分裂域上有
<span class="math inline">\(n\)</span> 个不同的根，设这 <span
class="math inline">\(n\)</span> 个根组成的集合为 <span
class="math inline">\(R\)</span>，于是 <span
class="math inline">\(R\)</span> 是乘法循环群。其生成元称为 <span
class="math inline">\(1\)</span> 的 <span
class="math inline">\(n\)</span>
次<strong>本原根</strong>。回忆（群论，循环群的自同构）：<span
class="math inline">\(R\)</span> 的自同构群为一个 <span
class="math inline">\(\varphi(n)\)</span> 阶 Abel 群。</p>
<p><strong>性质</strong></p>
<ul>
<li>设 <span class="math inline">\(F\)</span> 是特征为 <span
class="math inline">\(0\)</span> 的域，<span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 上 <span
class="math inline">\(n\)</span> 阶分圆域，则 <span
class="math inline">\(\text{Gal} E/F\)</span> 是一个 Abel 群。</li>
</ul>
<p>现在我们引入 Abel 扩张 与 循环扩张 的概念：</p>
<ul>
<li>设 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 关于 <span
class="math inline">\(d\)</span> 的 Galois 扩域，若 <span
class="math inline">\(\text{Gal} E/F\)</span> 是一个 Abel 群，则称 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的 <strong>Abel 扩域</strong> 或
<strong>Abel 扩张</strong>。</li>
<li><span class="math inline">\(E,F\)</span> 定义同上，若 <span
class="math inline">\(\text{Gal} E/F\)</span> 是一个循环群，则称 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的 <strong>循环扩域</strong> 或
<strong>循环扩张</strong>。</li>
</ul>
<p>特征为 <span class="math inline">\(0\)</span> 的分圆域是一个 Abel
扩张。</p>
<ul>
<li>若 <span class="math inline">\(E=F(d), d^n\in F\)</span> 其中 <span
class="math inline">\(n&gt;1\)</span> 且是使得 <span
class="math inline">\(d^n\in F\)</span> 的最小自然数，则称 <span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 关于根 <span
class="math inline">\(d\)</span> 的 <span
class="math inline">\(n\)</span> 次<strong>根扩张</strong>。</li>
</ul>
<p>接下来我们来看根扩张和循环扩张的关系：</p>
<ul>
<li>若 <span class="math inline">\(F\)</span> 含有 <span
class="math inline">\(1\)</span> 的 <span
class="math inline">\(n\)</span> 次本原根，则：
<ul>
<li><span class="math inline">\(F\)</span> 的 <span
class="math inline">\(n\)</span> 次根扩张必为循环扩张且这个扩域关于
<span class="math inline">\(F\)</span> 的维数是一个 <span
class="math inline">\(n\)</span> 的因子；</li>
<li>若 <span class="math inline">\(E\)</span> 是 <span
class="math inline">\(F\)</span> 的 <span
class="math inline">\(n\)</span> 维循环扩域，则存在 <span
class="math inline">\(d\in E\)</span> 使得 <span
class="math inline">\(E=F(d)\)</span> 且 <span
class="math inline">\(d^n\in F\)</span>.</li>
</ul></li>
</ul>
<h4 id="有理数域上的分圆域">有理数域上的分圆域</h4>
<p>设 <span class="math inline">\(R\)</span> 是 <span
class="math inline">\(1\)</span> 的 <span
class="math inline">\(n\)</span> 次根集，令 <span
class="math inline">\(\varphi_n(x)=\prod (x-z)\)</span>，其中 <span
class="math inline">\(z\)</span> 跑遍 <span
class="math inline">\(R\)</span> 中的本原根。</p>
<p>在 <span class="math inline">\(\mathbb{Q}\)</span> 上，<span
class="math inline">\(1\)</span> 的本原根形如 <span
class="math inline">\(\cos\cfrac{2k\pi}{n}+i\sin\cfrac{2k\pi}{n}\)</span>
且 <span class="math inline">\((k,n)=1\)</span> 的复数。</p>
<p>设分圆域为 <span class="math inline">\(E\)</span>，<span
class="math inline">\(\eta\in\text{Gal}E/Q\)</span>，则有 <span
class="math inline">\(\eta|_R\)</span> 是 <span
class="math inline">\(R\)</span> 的自同构，于是若 <span
class="math inline">\(x\)</span> 是本原根，则 <span
class="math inline">\(\eta(x)\)</span> 也是本原根。</p>
<p>考虑 <span class="math inline">\(\varphi_n(x)\)</span>，显然 <span
class="math inline">\(\eta\)</span> 作用在它上保持不变，故 <span
class="math inline">\(\varphi_n(x)\in\mathbb{Q}[x]\)</span>，从而 <span
class="math inline">\(\varphi_n(x)\mid (x^n-1)\)</span>.</p>
<p>我们称 <span class="math inline">\(\varphi_n(x)\)</span> 为 <span
class="math inline">\(\mathbb{Q}\)</span> 上的 <span
class="math inline">\(n\)</span>
阶<strong>分圆多项式</strong>，更多地，我们事实上可以证明 <span
class="math inline">\(\varphi_n(x)\)</span>
是整系数多项式。我们可以利用归纳法计算：</p>
<p><span class="math inline">\(\varphi_n(x)=(x^n-1)/\prod_{d&lt;n,d\mid
n}\varphi_d(x)\)</span>.</p>
<p>它有如下性质：</p>
<ul>
<li><span class="math inline">\(\varphi_n(x)\)</span> 是 <span
class="math inline">\(\mathbb{Q}[x]\)</span> 上的不可约多项式</li>
<li><span class="math inline">\(\varphi_n(x)\)</span> 是 <span
class="math inline">\(1\)</span> 的 <span
class="math inline">\(n\)</span> 次本原根的极小多项式，其次数为 <span
class="math inline">\(\varphi(n)\)</span></li>
<li>$ E/ _n $，即有理数域上 <span class="math inline">\(n\)</span>
阶分圆域在有理数域上的 Galois 群同构于 <span
class="math inline">\(n\)</span> 阶循环群的自同构群。</li>
</ul>
<p>于是可以有推论：</p>
<ul>
<li><span class="math inline">\(\mathbb{Q}\)</span> 上的 <span
class="math inline">\(p\)</span> 阶分圆域的 Galois 群是 <span
class="math inline">\(p-1\)</span> 阶循环群。</li>
</ul>
<hr />
<h3 id="一元多项式的根式求解">4.10 一元多项式的根式求解</h3>
<p>首先我们来看什么是根式求解：</p>
<h4 id="根式求解">根式求解</h4>
<p><strong>定义</strong></p>
<p>称 <span class="math inline">\(f(x)\in F[x]\)</span> 是域 <span
class="math inline">\(F\)</span> 上的非零首一多项式，方程 <span
class="math inline">\(f(x)=0\)</span> 称为在 <span
class="math inline">\(F\)</span> 上<strong>可用根式求解</strong>，若存在
<span class="math inline">\(F\)</span> 的一个扩张 <span
class="math inline">\(K/F\)</span> 满足下述条件：</p>
<p>存在 <span class="math inline">\(F\)</span> 与 <span
class="math inline">\(K\)</span> 之间的有限个中间域组成的“塔”：</p>
<p><span class="math inline">\(F=F_1\subseteq
F_2\subseteq\cdots\subseteq F_{r+1}=K\)</span>，其中 <span
class="math inline">\(F_{i+1}=F_{i}(d_i), d_i^{n_i}=a_i\in
F_i\)</span>，且 <span class="math inline">\(K\)</span> 包含多项式 <span
class="math inline">\(f(x)\)</span> 的一个分裂域。</p>
<p>这样的“塔”称之为<strong>根塔</strong>，注意到每个扩张都是根扩张，因此上述定理是在说：</p>
<p><span class="math inline">\(f(x)=0\)</span>
的每个根都可以通过有限次加减乘除得到。</p>
<p>接下来涉及的所有的域特征均为 0.</p>
<p><strong>关于多项式的 Galois 群</strong></p>
<p>设 <span class="math inline">\(f(x)\)</span> 是 <span
class="math inline">\(F\)</span> 上的多项式，<span
class="math inline">\(E\)</span> 是 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(F\)</span> 上的分裂域，则称 <span
class="math inline">\(\text{Gal}E/F\)</span> 为多项式 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(F\)</span> 上的 <strong>Galois 群</strong>，简记为
<span class="math inline">\(G_F(f)\)</span>.</p>
<p><strong>判别定理</strong></p>
<p>为证明判别定理，这里需要两个引理：</p>
<ul>
<li>设 <span class="math inline">\(f(x)\in F[x]\)</span>，<span
class="math inline">\(K\)</span> 是 <span
class="math inline">\(F\)</span> 的扩域，若将 <span
class="math inline">\(f\)</span> 看作 <span
class="math inline">\(K\)</span> 上的多项式，则 <span
class="math inline">\(G_K(f)\cong G_0\leq G_F(f)\)</span>，其中 <span
class="math inline">\(\leq\)</span> 指子群。</li>
<li>设 <span class="math inline">\(E/F\)</span> 有一个根塔 <span
class="math inline">\(F_1,F_2,\cdots,F_{r+1}\)</span>，则 <span
class="math inline">\(E/F\)</span> 的正规闭包 <span
class="math inline">\(K/F\)</span>
也有一个根塔，且这个根塔中互不相同的根指数 <span
class="math inline">\(n_i\)</span> 与原根塔相同。</li>
</ul>
<p>从而有判别定理：</p>
<ul>
<li><span class="math inline">\(\large{(*)}\)</span> 域 <span
class="math inline">\(F\)</span> 上一元 <span
class="math inline">\(n\)</span> 次方程 <span
class="math inline">\(f(x)\)</span> 可以根式求解的充要条件是 <span
class="math inline">\(f(x)\)</span> 的 Galois 群 <span
class="math inline">\(G_F(f)\)</span>
是一个<strong>可解群</strong>。（回忆：可解群的定义，商因子都是 Abel
群）</li>
</ul>
<p>另有其他定理：</p>
<ul>
<li>若 <span class="math inline">\(f(x)\)</span> 是一个次数为素数 <span
class="math inline">\(p\)</span> 的 <span
class="math inline">\(\mathbb{Q}[x]\)</span> 上的不可约多项式，假设
<span class="math inline">\(f(x)\)</span> 恰好有两个非实根，则 <span
class="math inline">\(f(x)\)</span> 的 Galois 群恰为 <span
class="math inline">\(S_p\)</span>，即 <span
class="math inline">\(p\)</span> 次对称群。</li>
<li>形如 <span
class="math inline">\(x^n-t_1x^{n-1}+t_2x^{n-2}+\cdots+(-1)^nt_n=0\)</span>
的方程的 Galois 方程同构于 <span
class="math inline">\(S_n\)</span>.</li>
</ul>
<p>还有推论：</p>
<ul>
<li><p>当 <span class="math inline">\(n\geq 5\)</span>，一元 <span
class="math inline">\(n\)</span> 次代数方程没有求根公式。</p>
<p>这是来自于 <span class="math inline">\(S_n(n\geq 5)\)</span>
不是可解群，参见群论。</p></li>
</ul>
<hr />
<p>结束了喵。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>抽象代数</tag>
        <tag>代数</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑学半期考试试题及答案</title>
    <url>/2023/11/14/Mid-term%20Exam/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="80610c6bfd0e06548764ae56c31e6c8ac1fec7a73799ef41cd48e3e6edb8c6aa">50d587fd195ba3e2fcf7fcd8dbdf856b9a680a370d09bf6ce814edf9fd0923179252f328ef7618dee66403d0c6a02047cac54c83a9c8f2bf05c4ef7c09cf883b2e564fb9de9cf220ef8093c46c5a73327c542db3fb2f1ae7cc2a20e22dc2159d72c6d2c1e90137e1bda70212fd04b4bab07a45c0e6b80b0183729b6429e25c24facc7b482aad9178693f201a809ab5ec720afb48d5408f9518edbfcdad13ea565ba93847fa0de1eef1207cecaf173a27dea375b91cc4c1c6eab35b03e6d84a5d592c67849c1ac8107e8afce0150e4eae81531b01c909e3c6fa96d7c2a6968a42abf62e9ec00ecfd7f27968147f3287e86d41d90d6137fea2dd4c059a4cf9694840580696b84ecb1c15c339ac08d391fd7113c8c4628b526a3823e400ed549db7a2a64a75c119f4e695a9ebb7e66cfc7d33cf4cfd7b1e46036646f7d4b8bfbd3c8f94941af79a63a47351814b8cd4df476e5394baa63522d4a10beab57bdcba5f2e704c59e67c4079133ace0037c228d00ababaf7ae93b37fdfb1915fa285a943ca165f913bda90cf4a707f7ef81db58b1235f21178123c2968ca0d3e13cbd31783dc00fd7ca907d0eb5d1552c957b12e1d29ad780fb021de60e9cd91cfb67df60a12ecbf51c769a4fa34d8d28cde0ef50855356158df936a1fb2dba5513c5086ecb2e45eb613a059b99d0cdc4e5fb5731b0f45155252d451f6df57e3bbd86a864549b20a204e8c7c043b370244788314006850b06af4f8362c1d6172e4e7d5014783253f1d474cf6e4919dd13d7f17f9322fd137231fc8eb487be2ee1790b2c978940e79281bd3fe790d061ec9136b162b1d61148ac423f5d26c02c45c8d9d14e20cfa69b047edfafd064fd442f9fe0717d6cf402c1fa631149e4a94dc78681ab7937e0152ec012ea9d7232ed0512180d7eefead9285d20342e38db474276f15e86182433660f0586c5a34adf09ac50a3d291abb34f5ce6e9f4160757ca23f4b5c20f8f83a11ebba8fc43a215f0d66db725bed889de2490670c153d65413acbf37285e7e56b7f45677515663c93d80fc221753c3ed03afb950a4cdc3bbdd992a3b478a99ecb99a18882ec2a791d9e5c853c6a56a4f2e4d65ba3d171234cf9e2114e6d860fcda1892b70c47a049caf03cb5346a90be3a927aa726a66da712ec32db8b368950369edbe1aefade295537b325f4ebd4c5c2f191336ceb1ff6d97daae913656f4305eefdac11302f809876a01ec159d08b2bb2e2310a735d283c9f0065e2498895408c4f77d86fea1deac85970488f8d0a10ccd5c7d1266a3be37d4ca205905b7a08c19918fd6a8bc203279ce5c3fe3e4e234014a104e70c028504eaf149ac8b36e1652ffbe8c28a927177b1a61053c800f33010212e7a83f1d6e654d7f147cc8aec78f7f8613e79b50a416d1b7d8b62f300b8386d144d617969dc52ab7dd61fb3a8b9e827153853e21a1996326a6bedb2c4f16319f6273391685dde611481000c1710e1641db73d3115e8827704ee5912e430ca1ba365a25376434e74e8dccb7576974c62c09d33389ceac7706d92cc057a97a0081b8e63b5b4931b59657b8b8513fa5851abbd1f07b7e1dd186e7dd236923269201244a1e0a7dbb6458e29460605d3c55e6f8672d17aa2d61a7425b436ba7132dc6fc09d281d6a8cc1a32d877fdbb11c20b73eb29da365e9ba4dda8042b5db069296e20a1692a28b6534809687496805c0d3f4c6b1487355cd52949ea38ee24cca0f41219de269a2c1a518c9f392198c8cd7cdc5ae698af0ff3de13a6489f593790415f1321196c567cb0ce247c9730b5ae7309d956fa4b653d43745ea3f47fe4507a042cbbe5a379efc2da19e10b2e1f0e322fdbf5beb331c7149c095c0ed24bd5730886a3b3f5ffeb53a44e0c873f0c6fff25e973bb0d16b48b35aec7cece23ff607f8fe25a9266840e896903a01bc1a3d88ca0e25c4f8bfc728adddcf1b5bce4df66a8e3a1a53b41b8240943f8d6a312aecfd38582ec8ec7e16ee51924b84f71d046ab316bea6e388d4bec46acc3aa2e03b1cac6e0954c65448525b428c739f11dcf26f79b1eb5d21ab49df598e6b6b5848a8190f602db53b86d06a9de756d7e576656863de65f3527e6faf4374a39411f605278afafa77494e6b9dc791bbb14ccd97b67db308e7997819b3fb5a6ef8d1d0d707390bc1084fd4ef8807c18d9f59a11e6fbea2af105ae282917c2eb1f4bd23d7ec157b4a32d99d50944d3e43dd0040ad073fc8de739a37548ebc8c6314e0201ff5229492522544bf20e2cd6029966d48d71ea031f95f1770f4a03d8a7620079e702c891eebf2fb707c7ff9fff7dfa516adfd2bd60d33c6c93704f685b32c9df8592d2217835a3d51aeec250758f02d021002ee6aa3cee5938717615703a54b02f7c012dfde11f52a697eab4efd66939beeb57005c4e2b683891e88033ba74bc09aa283dc476a2ab8956a645d29a7c68f9d5a2d49d79c54d7f29ff68e3e48b2bf0983449590ddd28cec877795eccdd06529982927109a88494bf69e1b67f2afc7a0145489f5ecffa81c586c00ed05963766b02fefcf35569b3236ff1edd8f443a8457835ed0c5824e481235d89fb3cc797ec01291c67224072f78ab75abc2361ef3c1ceaf130efda4497cc7e49ef37cf0050773678639857f9439c359d79d2fa208a6113c9b22993bed47a77a2dc8a09c0f78c01e8d6bd307204ef4711adb2b42838968baa0b55bdc451b3b1cea71a385e991550214e1dadbadbf96e35c3af72ddbdebcc15697b13b750a55f9258fd066b90351a892068177de8b3288ddecb81125a91b26cb10e3f619af7548e74f3c96d5758ea096981446c36b55015c87165cfe6b5858c233effc0cd1166f6c9334b9ac5c0f3f39fe05c3235fe8c158467b10e2932f9d7e4ce51615a83217a104980efed829dc518e019aa1872715cd5fcdfb212295aecb64e2f185f15c7cea7ea113b195adaf04818c717b091fa301c08a59e50449ecc69ce9cb2cf56fe7af67f56f25ba8d50b9c61ce00386173d20b7c4abe7b60b494e3383160e7ab263ca1f39b40f38ebf0937c96e1eee94ef1c905c3f69536fb432f0b3dddb68f76bb842fa6936a786ebfe1ea83f290f8f44b484c7713aba6b8dfb7f74bea4d5f9db6e6ac952393606e6fac411830ba21649c4f12c0d01a22fcb204bb4ea924ef353573cba3071f2e5ae809c9c50a01896eda29ecd31b20ae4b8d7bf73fa659dbbec18565276e500c58c80d161db86db033bf10268917acc93b6fdd8f143d309dc937e4730c2edd2da769b4b26ec9c228c5c86cefbd56189e9d0afb196f733d48c4b6fdbf8a6cc176d4c2e5427b6cd6cdcacc100d31a58f92182a608c4a3939e3d9638391b3e25c103fc26ec53c3e4491db92e75fd8173e8de2c4c4e51b37d8da433ecf53ae5846a95e18dcac9bb027d564f033496a8d2be0c03ae723e5491c7da69dad3485751d99f28ddd7e11ea36aa2b90a08e552da0a7b050e619225ade1aece071759acc0735b190d763095b3b1cb93f1faf930716389de793f899a23964374149a1f1ffe68e21249010873ba89820d0bfdf20d51c54ef736594110e266e101a3a2ddf71db92a6af076b719bd05b95f806d62791a072ce87c599379f982e383ebc2b33d4bcac8fbcbabbe014abf4914e914cd1041de61650ba104c94573bd5f68d3e85458eff0cbafc3cce9dd1ff064e0d8f94aa144176782dc02d7a0592aaff7c89ea134ae9c26a639d5f6ecf6644607fdbbbdf45e36130a6e51bbb8992426324a049cf2b72e3d831d8f001914676ddaede4ff90c22d75cbf13be5589066f679412f3b3257b66fa7622c3bba34262ba8504c8ff93647534a1d5b11c3ff17731ea7b428010c11f5306ae3722af2fb6b547b23701d7e3e3800218021fed7602aa3cd7398eff853e3053517ff8ccb950f5302f6ea1746cda72d29e80e554afcda71d6e4ddebe658f9970429bd91efd6e4aaeaa2c71a1735ba4c09ab9a7fe0b60ec8fc9d80454e4e8b498c1d9759cda0fdd90fbadaf1c9a32d7e199253ae09780fb82ae68a15be2b036a2308e31d9cc769c01653812491fc0fd6fba3bf97aaf295612dd355582d53d23884938229c134763613a48c100f8dfa7446eb23a3c98cd5e6539ca5aff3e97f2895a4cf8a6619b41ee7685e2f459bce9d46f74ce7b887ed2e22c78de49f67007b570dfedc97f4090b9c400d2d2b6594cb8773a4e0e90bcac530498148f6d9861e523bdc0a832d808c7f0b94496bf2c8f1deaf7b3ff193594f66569054e987a4cc738d469e6820d893f299c83f588afcaabbc5664ae9a588b28b0227808fb39dda4c14ce8d4c76f257239cd4e5eafe8b3846e0c8514b216db0602314d0c9fa7ce42d315d566280ca4f64e5617e8106f71c49fdeab8acadea6c92f91e55346abc539e124e45c45fc595e7baeaded45f759915732ea3887536594d7ebc5252a7a1cfa3ff3388da70a916ddd4c8fc4687b51e1fcf861acc50b00e3d45b16b15b2a2ed48d460a6fe3b36bc54b2bcc82d65d99722522775eb334d3900aa4c5962ac2b314735eca77a613d1b3539bda5c59b0e3b98f65be0d741f915507dab6612d3f92bfbc1fca8926efab88192791721315492df0df9f8ebd8214e4e04d40001c2e63f00f5d3de67baf8369427b3e1f8a809812be8c7839534dbb6c7d824da554b47e1ad4e4c71ec1077815384999c6743e965e4ff3c1dd235b9429c0e8d966f8464719239ace1b025b6006f93557f23fe797dc1f10af513b618fee31e92175c0b15c8ccf6e06d2a7267f2817396932b697028f451c6a369cc5600eda0cd141d9047a4602719921a057b67970acbab4df16c2d95954e18c84e88591d74b199527f054e64461154e0816777136de7571c1fd6bc7ac7f5de67d7794106f3db4042c0a8224b7f72ba2fc14a06574810085a3b2ab3ec804ca8ef2d499595b470d3f7116ccc870b4c30a56bf5d858986e1138fff9d8eaa29a42e1971eca0f5752afe301883df964131f088f85bfbaca4171f3b616ca859cfededafb2ff526d6ef7d97e96539ab172854da2f59012923d1d91b769877990116bc35b8002e1b6b88d1e2043945eeb113b0086e23554b9d58cb1ab3b01f6ab7d6d2f055dcf736c10b1644085e62372aa3c137074644e541e223199b4b24f88a1df2a84512c0a7a9a26009fc9fc08af0dd7fa9a4de1521f0e823d24a8b976da5c8654e7af44cbec22fab3e8701e84c7b18ee2015b32a44361839c5c4b211c20f215275a2ef13051c368ede0c096875cc86ed74c2951f34b3b68829651e8a8b388b13a72d0f78efdbaef3873dc05a6a0a5f6af06017229fd6a34a50e6a618f6984d4052799288840afef337df0c6f936147c2110f65b76ebfcabc4c889fd667aa93eb0ab125a657754d5eb0a6082093361a0f20715688f1c15d5abf6571afeb5f783eccf30f7a6b4262f4e6120c02a9084ef605ecc6962c4331342a5c4fcea611a033981da11052a23777302e4a44634c1fc4d428558dbbe08d8d430bbf2d3a781d33666f53eccae61f90a2cf549435e84a8642d9bfaf0e89f7d3eb1eb07ee5a0ec8337661267101c344c8865a393d4be75d932e6c0df7dc85b332ca3efbb03043b9a3dcb2aa67ab37cf8caad85c4ce53ff53d01b8e14b0abb08fb425357599f8ae24d2583455e94c6fa11304f83e128c9b8939d4882356e572a9b45a711082cf2f71a2fa404bfd25f310b27c8ca5b2580dfa015becb200041012743e87e444701ad4ffc31cfd24162cef927b5d9cbbfb2e7b8edafc798d5ba8fc83534155719821a224b9eeee706f5d11aa83ecc5edd8e9452f26a99d78818d9154b1034a26df47a747b74a88c9aaea3690a32b11fc242e77abf20c2976b93ee272d8e568a8d836434efa9e5d6750bb3754960d2d265cdfc1714e4d2f864f5bbf7a610e998ea518c5588e75cc9a6fa703548b2b253db4213183f636202b36e5a414c72eef4c517470b82b2cc50fcbadb364b7bb9556ffd9e9e1cd45540f2ef1a2163b2bc9b08b4285e7d6455aaf0e6ee69629fe14a03685ce809c109db66d5eae50a6a88ead3df7fd243cc1e04e49bcd113020e5fa59bcdca146b6823aac73591198381f7a7c5ca3f9fe0f69d95daf9e151847c878850b11f14e9ce9e71ba8570abc71dc47f8bdc823c4b5c7b577ae54587775a100ddf0689c446a86430966db171124086e0e41c6a7704d4e4d986d39ad8374577a71b4edf8f3021217190421ea33b4f7ecd4d70a42cae65d034420b1b609686e83e6a61aa89788b78bd636cc8842abb3ba4ae1b3161fc84457b624ac959b2ded91866abc9133a67eee4aa933a45009ab76b03192e3667eca3a6b2ce0f3820a7d11ae16fdd301b84051322cafd7eaac5878d439c4681331a508bb2daeb06df948ea9590d5ee33edb7dc8273256003f4baddd7bfb3c3643cfa3821477b1b299fa9d208f694fae0446edf0ef7ee2bb397b0cbfa2437fc704df5f4fd96d1f4b0aa5d5b4e3286288335be981afa5b3eb192082e146deec11905c70d22ec97cf765b94e33d65b139544ea2ac6721dd27dd26334a4c92b0e8406a410f93fd64a70d2da778c126f1ab227addd57ffb17c78b9c6c960103e88bef4cd6d29b2dbb5a86b097765da93eea3248853f5aaf36854908deabe94bb62e7e4352949c8e87331df296ccc27b30fd8f65d72adb997c1e47197ad2060d48f57e49ba55b20dee56da83dda652df5bdb315d3d39aa0158b1d2ad83135576de4fafad3f33a10805589c8af3c0e2405f0ad3c6da443255efbc618cbe79310114e127f3379ba4c16a6cfc3c3c7049e66ae587c6c15498602ab216d0acde1964120a008e471976b8e8fc02802c855d55cf1a525abf2903664aca2775a1535203c6f5184f0cbe2351854945915aa840a864bfedc88c2597f4a0be9141ef5c3a78248ed1586553fc8899e474c7e79214786f4b353201c3698af0a533f38c2055eead66758056e749020d49344babfe390d68d15dfe81eec855002498e400508fdf8044d84ce241d441e04ec30f3d1c55adccf902334728f25f9debe5f084ef1c8eb08962033da99f17f32de5aea431562110eaf0efca0cc8873705acb998dd9c42da959d451afcca5c19b109a2be2ad050ce36f616633424fcddf13fe97a7d121b1ada3063b132266120e9877ef2e59f399189459c10192ec48b49bcebb7ba8853bcfd2851937ecc4d15e50d9e055179044effc91904546583181c3b491b4ff79dd5b17981ba41fce0e09bbe7d4bf51c86d6535914f5d6ffadcfd8c4d023e6c2735727a9c2352fb9caff0a8ac940fcead8bb77228d2d1d62f525e967bb83d8b637a85c174fb9438df0c58f9f233052fc0ddda599978a66ffe5ff0cced3d6abd11b791279d394d80aa26fbe36971463953b9571419e04061c2145c17b96a1b07260a279ce8ecc5131e930e56a6a19ca64caab64f340c87f4e59915a69bc8778e479d221472194b63f192b703447cb5ffb9b3b41774b33001b09624810a04ff2c32c36ddcaf9c3cc0fb8cd921857df28f168fa5c297f486b75eb2553c115230c0b5c7aa907bbfd22a6d79c502a04887d62285ae4f889f8cae305ed8ef53bd15591d526630d5c3f8691adf2a99bbff35a46e1b9f0edba8ebab5c6aebd7be8b63701ba5431f2bc55abd54642f7b74e5a5e72c425fdeb26e930d5d7959cbf504c6dc68980976023fb6c182f5a0eb7ba9b60758bbbad6914aa1d1d0a3a81eac2a98d96bccc6a7ac2ab4bee174876ed79685cdecbbee2aea046c6f05f950f76ebb41053c2c948134337f2bd85c136184e14e7a3fde0bf3605221e5f0fcb3babc4c9c34b0d4bf1ac6f86ba487b6824c704ab1d2b7cfdfbad9f39a03e4d6c973291b0ba95bef651497ec4429be2b736815b6b2d2e71fba29ed92e60da05402c7b808fc3df45b1397a1085a4b593fe5dadb846a79531e196a32e2eb82a79d170468da74474d7225a6d81a5ce9ecac8c5ffa1cc52c41ed2e9e08e31834d27dfbfefc30f00f46bb59c7d6670564040c5a602948718171df668d1dad1521f84fa8a86a1b09771fd1ad65becf958d2e184073509245af0cce1f61427baf7707f05f3bb6057c3c16128778bff88564bee6f544e2dccd4eb82ece01e0ff6ad611838dbc877b31e64c71f1bbc7b91db86cef87ad662a67a41b8bc869c7124131c3732efd99e52de58787a700277a7c244d971adb768e9df1a647890314e5c6250750123f6b11a81a73c76806a1503f3dfc30c66ac0069815ff6350642327f027e15b698f0820b97375acef7a66114face850f61d52ef17199ba8346dae318d1df2d31276f5bbdf58f67b7480f4c7968fee331d4690dfbfa3eb97136253be633437d6a1503a3bb5ff49b7f3b326cd0983906f87b1760a34ae6a1ce8423af09e31fa75f5cfe365b3d02cf1a3e47166bc264300aef788e60618fb5b29a09b4279873caa10a91d95fd7534543e8ee297d5da06b03587e6a210ab5a898d682333c562314afc1682ff781cbaa91505dcf5c939bcbc8ebc34c2ece36c696541b640bc8e8e315b57873dfb1aa6d7fd9c838ff8430c1304c273f511756170df45cbdc8bf07aad466663faee1e1f083b7d8db9508925911f462f9ff97640f1b2028d62f7b73547de21815683b3c2adfab6ec3c4f9e1057572ef0eaf43db863547bb32f15f93e6bb5e2b51b30f09920bc83a1a548056e5582e0a180b4a57404e1ab008f7edfaef98c06e513bb451c13a9a84331137ac34a6893787b975728ea00c169d9d847e0d2144bc54c543115a06234eccf68ba713b7177b7279ad682767dbde7dc6cd62d35df0c3a8fd0885a81e48e352bbdc7f53c332bc06ae3d9127b97ebacd889638cf3c80069202d1235cc0b4c9ebee2c2dc9983b2c1f989a43f89cb45e73a7a844d0840fee45a327b04f74e6b0c29f10f1cffb13a018df32a644d0e1753035d0adcb4b4a88bc8175a2a61f3c33d518293334d017cf1eb17d3099c6701cedf701aae8966b352c19623f2a6d97a2a4b4ddf54e001819d5a6ed7afffb70742870390533b99a46ca47227d19aa4fa071191f4bb9b954766d4a74492ea18e78e58db80cad1ebf8b1f6a6b00cb9407c941ce697260c891e0839717ab9a404b51f61cc3c022bbec5a8a9ff31781b6144f1e1356e29a41dadc9921076045eee0117f8d1e7d4d136ea1838752c8bd0616aab92f88d047516ae7edd709870e845baa06087fad62f2d8a69595227cbd2f142bada6b88ae9a64e78a7dddf1be340491b2afe10ca9de37e842f36468f626cf84d41f1e45e26be39b1bc7323fb784218bc64d59820c88062c897d61bcf28ef2f25c072dd6074b998a1cf5b192b4058b61aa8b9dff1f145a4cd80767501618285caba267ace120aade72effc967e1ea1d6a94b788308787acb8403d6da6410fda0178d6e800d20d2efc13875ad95ed26fb1d9257dc84a493a74b01ddf444462229cdabbf0d13c0fbcdd539a3c7ce5eff7ed00381022613665cb64941aa4282a994d201fd71d3d2b7bf394b2a82906e76391de9f23df696bb07f529aa8015f2d92b5aaa7ba11358d1449a7b8fbd05cab22a79fddf1d16e01ade2fe4d31f2011c4fa2e34cfe7444d0f3116e082c8e9d76d7125edcacc8524828107dbc0834ca19919b4b8bb6fd67f030c883fa26af87279bf5072f2ba287e7fa06867f0572296aebff2e042227c8955e4798e8d08ee16d99ec795deb6641b03f0796096eb4a3316cf1cd6c211551bc23fb1d423d81ec3d40a97ecd5f4b6cf1951b5bb9b308a64fe049a5127a51892e14d9b13e95ffc7f505de846ae5fb00dc941fbed2e7a2fa3fef9618396fd4ad85b3d207a43c0ec8cee75638068280cab3434e4e7d333cc1d4ad9d500f1fb0660cee8e07c40b9cdfb648edb7610ab18638fa61e278212a2d9eaa2d093b8b75a9571fc7c784a2e8b9f1a19c8e5ec504ffe5061f1b7b57bcf0f606bb06c34b92581bb995553148b29b8e08ab5b01c87f8ea6afec64c0aa392c94b31e05e6d33730ec21e7b1fe9867d53ef8432a1b550d862e0ed3c988b0f69aa22f5f0dfb04a441b8804b630887bdc630fc4e40b21608b550f6ab147e397ef4b4ebefc849c4b9086a99abf383dfbffcba43ebe1e09db03194709a86d8257898899308cf164c4a904f05ff79e597a72fb3e2fdc955b448d422b74969674b0e4407435af21f8910b7112c66cbea4884a9eba8f6e9e172031e2d8257397610c65adffc2c8158c6748b8de4067b599130d497119061e63cda74f96c1b8557301384a61cc6e6055cd0d2018180ebe8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入拓扑学老师名称的首字母缩写以查看（因为插件问题，解密后请刷新页面以渲染数学公式）</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>拓扑学</tag>
      </tags>
  </entry>
</search>
